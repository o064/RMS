
==================================================
FILE PATH: .\include\CLIController.h
==================================================

//
// Created by Omar on 11/19/2025.
//

#ifndef RMS_CLICONTROLLER_H
#define RMS_CLICONTROLLER_H

#include "RMSFacade.h"
#include <string>
#include <iostream>
#include "./structures/vector.h"
using  std::string;


class CLIController {
private:
    RMSFacade* facade;

public:
    CLIController(RMSFacade* facade);
    //helpers to manipulate text
    static vector<string> tokenize(const string &args) ;
    static string readLine();
    static  void waitUser();
    // run
     void run();
     static void clear();
     // help
     static void show_help();

    // train commands
    void list_trains();
    void add_train(const vector<string>& args);
    void get_train_availability(const vector<string>& args);
    void update_train(const vector<string>& args);
    void add_seats(const vector<string>& args);
    void delete_train(const vector<string>& args);
    void get_train_status(const vector<string>& args);

    // passenger commands

    void add_passenger(const vector<string>& args);
    void update_passenger(const vector<string>& args);
    void delete_passenger(const vector<string>& args);
    void list_passengers();

    // ticket commands
    void list_tickets();

    void cancel_ticket(const vector<string>& args);
    void book_ticket(const vector<string>& args);


};
#endif //RMS_CLICONTROLLER_H


==================================================
FILE PATH: .\include\RMSApp.h
==================================================

//
// Created by Omar on 11/18/2025.
//

#ifndef RMS_RMSAPP_H
#define RMS_RMSAPP_H

#include "StartupManager.h"
#include "CLIController.h"

class RMSApp {
    std::unique_ptr<StartupManager> startupManager;
    std::unique_ptr<CLIController> cli;
public:
    RMSApp();
    ~RMSApp()= default;
    void run();
};
#endif //RMS_RMSAPP_H


==================================================
FILE PATH: .\include\RMSCommand.h
==================================================

// Created by Omar on 12/1/2025.

#ifndef RMS_RMSCOMMAND_H
#define RMS_RMSCOMMAND_H

#include <string>
#include "structures/unordered_map.h"

using   std::string;
    class RMSCommand {
    public:
        // enums to select the needed command
        enum class MainCmd { TRAIN, PASSENGER, TICKET, SYSTEM, UNKNOWN };
        enum class TrainCmd { LIST, ADD, DELETE, UPDATE, SEATS_ADD,STATUS, AVAILABILITY, UNKNOWN };
        enum class PassengerCmd { LIST, ADD, DELETE, UPDATE, UNKNOWN };
        enum class TicketCmd { LIST, BOOK, CANCEL, UNKNOWN };
        enum class SystemCmd { HELP, EXIT ,CLEAR, UNKNOWN };
        // lookup trees - static to use it without making objects
        static MainCmd getMainCmd(const string& cmd) ;

        static TrainCmd getTrainCmd(const string& sub) ;

        static PassengerCmd getPassengerCmd(const string& sub) ;

        static TicketCmd getTicketCmd(const string& sub) ;

        static SystemCmd getSystemCmd(const string& cmd) ;
    };





#endif //RMS_RMSCOMMAND_H


==================================================
FILE PATH: .\include\RMSFacade.h
==================================================

//
// Created by Omar on 11/19/2025.
//

#ifndef RMS_RMSFACADE_H
#define RMS_RMSFACADE_H

#include "./structures/vector.h"
#include <optional>
#include "Services/TicketService.h"
#include "Services/PassengerService.h"
#include "Services/TrainService.h"

class RMSFacade
{
private:
    TrainService *trainService;
    TicketService *ticketService;
    PassengerService *passengerService;

public:
    RMSFacade(TrainService *ts, TicketService *tks, PassengerService *ps);

    // train features
    vector<Train> listTrains();
    Train addTrain(std::string name,  int totalSeats);
    Train getTrain(int trainId);
    bool getTrainAvailability(int trainId);
    Train updateTrain(int trainId, const std::string& name  ,int seats=0);
    Train addSeats(int trainId,int seats=0);
    Train addSeats(const std::string& name,int seats=0);
    void deleteTrain(int trainId);
    void trainStatus(int trainId);

    // passenger features
    vector<Passenger> listPassengers();
    Passenger getPassenger(int totalSeats);
    Passenger addPassenger( const std::string& name);
    Passenger updatePassenger(int passengerId, const std::string &name);
    void deletePassenger(int passengerId);


    // ticket features
    vector<Ticket> listTickets();
    std::optional<Ticket> bookTicket(int trainId, const std::string& passengerName);
    void cancelTicket(int ticketId);


};
#endif // RMS_RMSFACADE_H


==================================================
FILE PATH: .\include\StartupManager.h
==================================================

//
// Created by Omar on 11/19/2025.
//

#ifndef RMS_STARTUPMANAGER_H
#define RMS_STARTUPMANAGER_H

#include "RMSFacade.h"
#include <memory>

class StartupManager {
private:
    std::unique_ptr<ITrainRepository> trainRepository;
    std::unique_ptr<ITicketRepository> ticketRepository;
    std::unique_ptr<IPassengerRepository> passengerRepository;
    std::unique_ptr<TrainService> trainService;
    std::unique_ptr<PassengerService> passengerService;
    std::unique_ptr<TicketService> ticketService;

    std::unique_ptr<RMSFacade> facade;
public:
    RMSFacade * buildFacade() ;

};
#endif //RMS_STARTUPMANAGER_H


==================================================
FILE PATH: .\include\models\Passenger.h
==================================================

//
// Created by Omar on 11/19/2025.
//

#ifndef RMS_PASSENGER_H
#define RMS_PASSENGER_H
#include <string>
class Passenger{
    std::string name;
    int id;
public:
    Passenger() = default;
    Passenger(const int id, const std::string& name);
    int getId() const;
    std::string getName() const;
    void setName(const std::string& name);

    void setId(const int & passengerId) ;

    void print(const std::string& msg) const ;

};
#endif //RMS_PASSENGER_H


==================================================
FILE PATH: .\include\models\SeatAllocator.h
==================================================

//
// Created by Omar on 11/19/2025.
//


#ifndef RMS_SEATALLOCATOR_H
#define RMS_SEATALLOCATOR_H

#include <queue>
#include <set>
#include "../structures/stack.h"
#include "../structures/unordered_map.h"

#include <string>
#include<memory>
#include <functional>

class SeatAllocator{
    std::set<int> availableSeats;
    std::queue<int> waitingList;
    std::set<int> waitingSet;              // prevent duplicate waiting entries
    unordered_map<int, int> allocatedSeats;
    stack<int> cancelledSeats;
    int totalSeats ;
public:

    SeatAllocator( int totalSeats = 10);
    // for copying
    std::unique_ptr<SeatAllocator> clone() const;
    SeatAllocator(const SeatAllocator& other);
    SeatAllocator& operator=(const SeatAllocator& other);

    void addSeats(int seats);
    void changeTotalSeats(int newTotalSeats);

    int freeSeat( int seatNumber);
    int allocateSeat( int passengerId);
    int processWaitingList(int seatsToAdd, std::function<void(int)> bookCallback)  ;


    int getAvailableSeatCount() const;
    int getAllocatedSeatCount() const;
    int getTotalSeats() const;
    int getWaitingListSize()const;

    std::queue<int> getWaitingList()const;

    bool hasAvailableSeats() const;

    void printStatus() const;

};
#endif //RMS_SEATALLOCATOR_H


==================================================
FILE PATH: .\include\models\Ticket.h
==================================================

//
// Created by Omar on 11/19/2025.
//

#ifndef RMS_TICKET_H
#define RMS_TICKET_H

#include "Passenger.h"

enum Status
{
    booked,
    cancelled
};
class Ticket
{
    int id;
    int ticketSeat;
    int trainId;
    Passenger passenger;
    Status status;

public:
public:
    Ticket() = default;
    Ticket(const int id,const int seat, const int trainId, Passenger p);
    int getId() const;
    int getSeat() const;
    Status getStatus() const;
    void setStatus(const Status& s);
    int getTrainId() const;
    Passenger getPassenger() const;
    void setPassenger(const Passenger &p);
    void setId(const int newId);
    void print(const std::string& msg) const ;

};
#endif // RMS_TICKET_H


==================================================
FILE PATH: .\include\models\Train.h
==================================================

#ifndef RMS_TRAIN_H
#define RMS_TRAIN_H

#include "SeatAllocator.h"
#include <string>

class Train {
private:
    int id;
    std::string name;
    int totalSeats;
    std::unique_ptr<SeatAllocator> seatAllocator;

public:
    // Constructor
    Train() = default;
    Train(const int id, const std::string& name, const int totalSeats = 10);
    ~Train() = default;


    //  copy operations for unique ptr
    std::unique_ptr<Train> clone() const ;
    Train(const Train& other);
    Train& operator=(const Train& other);

    // move operations
    Train(Train&&) = default;
    Train& operator=(Train&&) = default;

    int getTrainId() const;
    std::string getTrainName() const;
    SeatAllocator* getSeatAllocator() const;

    void setTrainName(const std::string& name);
    void setTrainId(int trainId);
    void setSeats(int seats);
    void addSeats(int seats);

    bool hasAvailableSeats() const;

    int getTotalSeats() const;
    void trainStatus() const ;
    void print(const std::string& msg) const ;

};

#endif //RMS_TRAIN_H

==================================================
FILE PATH: .\include\Repo\InMemoryPassengerRepository.h
==================================================

//
// Created by Omar on 11/19/2025.
//

#ifndef RMS_INMEMORYPASSENGERREPOSITORY_H
#define RMS_INMEMORYPASSENGERREPOSITORY_H

#include "../structures/vector.h"
#include <optional>

#include "../models/Passenger.h"
#include "../structures/map.h"
#include "IPassengerRepository.h"

class InMemoryPassengerRepository : public IPassengerRepository
{
private:
    Map<int, Passenger> passengers;
    int next_id = 1;
public:
    std::optional<Passenger> getPassenger(const int& passengerId) override;
    bool deletePassenger(const int& passengerId) override;
    void save( Passenger& passenger) override;
    vector<Passenger> getAllPassengers() override;
    void clear() override;
};
#endif // RMS_INMEMORYPASSENGERREPOSITORY_H


==================================================
FILE PATH: .\include\Repo\InMemoryTicketRepository.h
==================================================

//
// Created by Omar on 11/19/2025.
//

#ifndef RMS_INMEMORYTICKETREPOSITORY_H
#define RMS_INMEMORYTICKETREPOSITORY_H

#include "../structures/vector.h"
#include <optional>

#include "../structures/map.h"
#include "ITicketRepository.h"
#include "../models/Ticket.h"

class InMemoryTicketRepository : public ITicketRepository
{
private:
    Map<int, Ticket> tickets;
    int next_id = 1;

public:
    InMemoryTicketRepository() = default;
    ~InMemoryTicketRepository() override = default;
    std::optional<Ticket> getTicketByTrainAndPassenger(int trainId, int passengerId) override;
    bool deleteTicket(int ticketId) override;
    void save(Ticket& ticket) override;
    vector<Ticket> getAllTickets() override;
    std::optional<Ticket> getTicketById(int ticketId) override;
    void clear() override;
};
#endif // RMS_INMEMORYTICKETREPOSITORY_H


==================================================
FILE PATH: .\include\Repo\InMemoryTrainRepository.h
==================================================

#ifndef RMS_INMEMORYTRAINREPOSITORY_H
#define RMS_INMEMORYTRAINREPOSITORY_H

#include "../models/Train.h"
#include "ITrainRepository.h"
#include <optional>
#include <map>
 #include "../structures/map.h"


class InMemoryTrainRepository : public ITrainRepository {
private:
    Map<int, Train> trains;
    int next_id = 1;

public:
    InMemoryTrainRepository() = default;
    ~InMemoryTrainRepository() override = default;

    vector<Train> getAllTrains() const override;
    bool deleteTrain(int trainId) override;
    void  save( Train& newTrain) override;
    std::optional<Train> getTrainById(const int& trainId) const  override;
    void clear() override;
};

#endif

==================================================
FILE PATH: .\include\Repo\IPassengerRepository.h
==================================================

//
// Created by Omar on 11/19/2025.
//

#ifndef RMS_IPASSENGERREPOSITORY_H
#define RMS_IPASSENGERREPOSITORY_H

#include "../structures/vector.h"
#include "../models/Passenger.h"
#include <optional>

class IPassengerRepository
{
public:
    virtual std::optional<Passenger> getPassenger(const int& passengerId) = 0;
    virtual bool deletePassenger(const int& passengerId) = 0;
    virtual void save( Passenger& passenger) = 0;
    virtual vector<Passenger> getAllPassengers() = 0;
    virtual void clear() = 0;

    virtual ~IPassengerRepository() = default;
};
#endif // RMS_IPASSENGERREPOSITORY_H


==================================================
FILE PATH: .\include\Repo\ITicketRepository.h
==================================================

//
// Created by Omar on 11/19/2025.
//

#ifndef RMS_ITICKETREPOSITORY_H
#define RMS_ITICKETREPOSITORY_H

#include "../structures/vector.h"
#include <optional>

#include "../models/Ticket.h"

class ITicketRepository
{
public:
    virtual std::optional<Ticket> getTicketByTrainAndPassenger(int trainId, int passengerId) = 0;
    virtual bool deleteTicket(int ticketId) = 0;
    virtual void save(Ticket& ticket) = 0;
    virtual vector<Ticket> getAllTickets() = 0;
    virtual std::optional<Ticket> getTicketById(int) = 0;
    virtual void clear() = 0;

    virtual ~ITicketRepository() = default;
};
#endif // RMS_ITICKETREPOSITORY_H


==================================================
FILE PATH: .\include\Repo\ITrainRepository.h
==================================================

#ifndef RMS_ITRAINREPOSITORY_H
#define RMS_ITRAINREPOSITORY_H

#include "../models/Train.h"
#include "../structures/vector.h"
#include <optional>

class ITrainRepository {
public:
    virtual vector<Train> getAllTrains() const = 0;
    virtual bool deleteTrain(int) = 0;
    virtual void save(Train&) = 0;
    virtual std::optional<Train> getTrainById(const int& trainId) const   = 0;
    virtual void clear() = 0;
    virtual ~ITrainRepository() = default;
};

#endif

==================================================
FILE PATH: .\include\Services\PassengerService.h
==================================================

//
// Created by Omar on 11/19/2025.
//

#ifndef RMS_PASSENGERSERVICE_H
#define RMS_PASSENGERSERVICE_H

#include "../structures/vector.h"
#include "../models/Passenger.h"
#include "../Repo/IPassengerRepository.h"

class PassengerService
{
private:
    IPassengerRepository *passengerRepository;

public:
    PassengerService(IPassengerRepository *repo);
    Passenger getPassenger(const int& passengerId);
    vector<Passenger> getAllPassengers();
    Passenger createPassenger(const std::string& name);
    Passenger updatePassenger(const int passengerId , const std::string& name);
    void deletePassenger(const int& passengerId);
    Passenger find_or_create_passenger(const std::string& name);
};
#endif // RMS_PASSENGERSERVICE_H


==================================================
FILE PATH: .\include\Services\TicketService.h
==================================================

//
// Created by Omar on 11/19/2025.
//

#ifndef RMS_TICKETSERVICE_H
#define RMS_TICKETSERVICE_H

#include "../Repo/ITicketRepository.h"
#include "TrainService.h"
#include "PassengerService.h"
#include "../structures/vector.h"

class TicketService
{
private:
    ITicketRepository *ticketRepository;
    TrainService *trainService;
    PassengerService *passengerService;


public:
    TicketService(ITicketRepository *repo , TrainService* ts,PassengerService* ps);
    Ticket getTicket(const int& ticketId);
    vector<Ticket> getAllTickets();
    Ticket updateTicket(Ticket &t);

    std::optional<Ticket> bookTicket(const int& trainId, const int& passengerId);
    void cancelTicket(const int& ticketId);
};
#endif // RMS_TICKETSERVICE_H


==================================================
FILE PATH: .\include\Services\TrainService.h
==================================================

//
// Created by Omar on 11/19/2025.
//

#ifndef RMS_TRAINSERVICE_H
#define RMS_TRAINSERVICE_H
#include "../structures/vector.h"
#include "../Repo/ITrainRepository.h"
#include <optional>

class TrainService{
private:
    ITrainRepository* trainRepository;
public:
    TrainService(ITrainRepository* repo) ;
    ~TrainService();
    //crud
    Train getTrain(const int&);
    vector<Train> getAllTrains();
    Train createTrain(const std::string& name,int seats);
    Train updateTrain(const int& id , const std::string& name,int seats = 0);
    void deleteTrain(int trainId);

    //seats
    Train addSeats(const int trainId , const int seats);
    Train addSeats(const std::string name  , const int seats);
    // status
    void printStatus(int trainId);
    bool isAvailbleSeat(int trainId);
    void save(Train & train);
};
#endif //RMS_TRAINSERVICE_H


==================================================
FILE PATH: .\include\structures\list.h
==================================================

//
// Created by Omar on 12/11/2025.
//

#ifndef RMS_LIST_H
#define RMS_LIST_H
#include <iostream>
#include <functional>
#include <cassert>

template<typename T>
class List {
private:
    struct Node {
        T data;
        Node *prev;
        Node *next;
        Node(const T &v) : data(v), prev(nullptr), next(nullptr) {}
    };

    Node *head;
    Node *tail;
    size_t sz;

public:
    class iterator {
        friend class List;
    private:
        Node *node;
        explicit iterator(Node *n) : node(n) {}
    public:
        iterator() : node(nullptr) {}
        T& operator*() const { return node->data; }
        T* operator->() const { return std::addressof(node->data); }
        iterator& operator++() { if (node) node = node->next; return *this; }
        iterator operator++(int) { iterator tmp = *this; ++(*this); return tmp; }
        iterator& operator--() { if (node) node = node->prev; return *this; }
        iterator operator--(int) { iterator tmp = *this; --(*this); return tmp; }
        bool operator==(const iterator &o) const { return node == o.node; }
        bool operator!=(const iterator &o) const { return node != o.node; }
    };

    class reverse_iterator {
    private:
        Node *node;
        explicit reverse_iterator(Node *n) : node(n) {}
        friend class List;
    public:
        reverse_iterator() : node(nullptr) {}
        T& operator*() const { return node->data; }
        reverse_iterator& operator++() { if (node) node = node->prev; return *this; }
        reverse_iterator operator++(int) { reverse_iterator tmp = *this; ++(*this); return tmp; }
        bool operator==(const reverse_iterator &o) const { return node == o.node; }
        bool operator!=(const reverse_iterator &o) const { return node != o.node; }
    };

    List() : head(nullptr), tail(nullptr), sz(0) {}
    ~List() { clear(); }

    List(const List&) = delete;
    List& operator=(const List&) = delete;

    bool empty() const { return sz == 0; }
    size_t size() const { return sz; }

    T& front() { assert(head); return head->data; }
    const T& front() const { assert(head); return head->data; }
    T& back() { assert(tail); return tail->data; }
    const T& back() const { assert(tail); return tail->data; }

    void push_front(const T &val) {
        Node *n = new Node(val);
        n->next = head;
        if (head) head->prev = n;
        head = n;
        if (!tail) tail = head;
        ++sz;
    }

    void push_back(const T &val) {
        Node *n = new Node(val);
        n->prev = tail;
        if (tail) tail->next = n;
        tail = n;
        if (!head) head = tail;
        ++sz;
    }

    void pop_front() {
        assert(head);
        Node *n = head;
        head = head->next;
        if (head) head->prev = nullptr;
        else tail = nullptr;
        delete n;
        --sz;
    }

    void pop_back() {
        assert(tail);
        Node *n = tail;
        tail = tail->prev;
        if (tail) tail->next = nullptr;
        else head = nullptr;
        delete n;
        --sz;
    }

    iterator insert(iterator pos, const T &val) {
        Node *posNode = pos.node;
        if (!posNode) {
            push_back(val);
            return iterator(tail);
        }
        Node *n = new Node(val);
        n->next = posNode;
        n->prev = posNode->prev;
        posNode->prev = n;
        if (n->prev) n->prev->next = n;
        else head = n;
        ++sz;
        return iterator(n);
    }

    iterator erase(iterator pos) {
        Node *n = pos.node;
        assert(n);
        iterator nextIt(n->next);
        if (n->prev) n->prev->next = n->next;
        else head = n->next;
        if (n->next) n->next->prev = n->prev;
        else tail = n->prev;
        delete n;
        --sz;
        return nextIt;
    }

    void clear() {
        Node *cur = head;
        while (cur) {
            Node *nx = cur->next;
            delete cur;
            cur = nx;
        }
        head = tail = nullptr;
        sz = 0;
    }

    void resize(size_t new_size, const T &value = T()) {
        while (sz < new_size) push_back(value);
        while (sz > new_size) pop_back();
    }

    void remove(const T &value) {
        for (auto it = begin(); it != end(); ) {
            if (*it == value) it = erase(it);
            else ++it;
        }
    }

    iterator begin() { return iterator(head); }
    iterator end() { return iterator(nullptr); }

    reverse_iterator rbegin() { return reverse_iterator(tail); }
    reverse_iterator rend() { return reverse_iterator(nullptr); }

    void reverse() {
        Node *cur = head;
        Node *tmp = nullptr;
        while (cur) {
            tmp = cur->prev;
            cur->prev = cur->next;
            cur->next = tmp;
            cur = cur->prev;
        }
        tmp = head;
        head = tail;
        tail = tmp;
    }

    void merge(List &other) {
        if (this == &other) return;
        Node dummy(T());
        Node *last = &dummy;
        Node *a = head;
        Node *b = other.head;

        while (a && b) {
            if (b->data < a->data) {
                Node *bn = b->next;
                b->prev = last;
                last->next = b;
                b->next = nullptr;
                last = b;
                b = bn;
            } else {
                Node *an = a->next;
                a->prev = last;
                last->next = a;
                a->next = nullptr;
                last = a;
                a = an;
            }
        }
        while (a) {
            Node *an = a->next;
            a->prev = last;
            last->next = a;
            a->next = nullptr;
            last = a;
            a = an;
        }
        while (b) {
            Node *bn = b->next;
            b->prev = last;
            last->next = b;
            b->next = nullptr;
            last = b;
            b = bn;
        }

        Node *newHead = dummy.next;
        if (newHead) newHead->prev = nullptr;
        Node *newTail = newHead;
        while (newTail && newTail->next) newTail = newTail->next;

        head = newHead;
        tail = newTail;

        sz = 0;
        for (Node *p = head; p; p = p->next) ++sz;

        other.head = other.tail = nullptr;
        other.sz = 0;
    }

private:
    Node* split(Node* start) {
        if (!start) return nullptr;
        Node *slow = start, *fast = start->next;
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
        }
        Node *second = slow->next;
        slow->next = nullptr;
        if (second) second->prev = nullptr;
        return second;
    }

    Node* merge_sorted(Node* a, Node* b) {
        Node dummy(T());
        Node *tailLocal = &dummy;
        while (a && b) {
            if (a->data <= b->data) {
                tailLocal->next = a;
                a->prev = tailLocal;
                a = a->next;
                tailLocal = tailLocal->next;
                tailLocal->next = nullptr;
            } else {
                tailLocal->next = b;
                b->prev = tailLocal;
                b = b->next;
                tailLocal = tailLocal->next;
                tailLocal->next = nullptr;
            }
        }
        while (a) {
            tailLocal->next = a;
            a->prev = tailLocal;
            a = a->next;
            tailLocal = tailLocal->next;
            tailLocal->next = nullptr;
        }
        while (b) {
            tailLocal->next = b;
            b->prev = tailLocal;
            b = b->next;
            tailLocal = tailLocal->next;
            tailLocal->next = nullptr;
        }
        Node *res = dummy.next;
        if (res) res->prev = nullptr;
        return res;
    }

    Node* merge_sort(Node* start) {
        if (!start || !start->next) return start;
        Node *second = split(start);
        Node *l1 = merge_sort(start);
        Node *l2 = merge_sort(second);
        return merge_sorted(l1, l2);
    }

public:
    void sort() {
        if (!head || !head->next) return;
        head = merge_sort(head);
        tail = head;
        while (tail && tail->next) tail = tail->next;
        sz = 0;
        for (Node *p = head; p; p = p->next) ++sz;
    }

    void print_forward() const {
        for (Node *p = head; p; p = p->next) std::cout << p->data << " ";
        std::cout << "\n";
    }

    void print_backward() const {
        for (Node *p = tail; p; p = p->prev) std::cout << p->data << " ";
        std::cout << "\n";
    }
};

#endif //RMS_LIST_H


==================================================
FILE PATH: .\include\structures\map.h
==================================================

#ifndef MAP_HPP_
#define MAP_HPP_
#include <iostream>
#include <stdexcept>
#include <utility>
#include <algorithm>

template<typename Key, typename Value> class Map; // Forward declration 

template<typename Key, typename Value>
class MapNode{
public:
    std::pair<Key, Value> data;
    MapNode* left;
    MapNode* right;
    MapNode* parent;
    int height;

    MapNode(const std::pair<Key, Value>& data): data{data}, left{nullptr}, right{nullptr}, parent{nullptr}, height{}{ }
    MapNode(const std::pair<Key, Value>& data, MapNode* left, MapNode* right, int height = 0)
    :data{data}, left{left}, right{right}, parent{nullptr}, height{height}{ }
    MapNode(std::pair<Key, Value>&& data): data{std::move(data)}, left{nullptr}, right{nullptr}, parent{nullptr}, height{}{ }
    MapNode(std::pair<Key, Value>&& data, MapNode* left, MapNode* right, int height = 0)
    :data{std::move(data)}, left{left}, right{right}, parent{nullptr}, height{height}{ }

};

template<typename Key, typename Value>
class MapIterator{
private:
    MapNode<Key, Value>* node;

    // return the next node in a sorted order
    MapNode<Key, Value>* successor(MapNode<Key, Value>* nodePtr){
        if(nodePtr == nullptr) return nullptr;
        // If right subtree isn't empty
        // Go right then down to far left
        if(nodePtr->right != nullptr){
            nodePtr = nodePtr->right;
            while(nodePtr->left != nullptr) nodePtr = nodePtr->left; // Keep going down and to the left
            return nodePtr;
        }

        // If right subtreee is empty
        // Keep goind up until we approach from a left suptree
        MapNode<Key, Value>* p = nodePtr->parent;
        while(p != nullptr && nodePtr == p->right){ 
            nodePtr = p;
            p = nodePtr->parent;
        }
        // We either reached the top of the tree (no bigger value),
        // Or we approached the parent from the left
        return p;
    }

    MapNode<Key, Value>* predecessor(MapNode<Key, Value>* nodePtr){
        if(nodePtr == nullptr) return nullptr;

        // If left subtree isn't empty
        // Go left then down to far right
        if(nodePtr->left != nullptr){
            nodePtr = nodePtr->left;
            while(nodePtr->right != nullptr) nodePtr = nodePtr->right; // Keep going down and to the right
            return nodePtr;
        }    

        // If left subtreee is empty
        // Keep goind up until we approach from a right suptree
        MapNode<Key, Value>* p = nodePtr->parent;
        while(p != nullptr && nodePtr == p->left){ 
            nodePtr = p;
            p = nodePtr->parent;
        }
        // We either reached the top of the tree (no bigger value),
        // Or we approached the parent from the right
        return p;
    }
public:
    Key first;
    Value second;
    MapIterator(MapNode<Key, Value>* node): node{node} {
        if(node!= nullptr){
            first = node->data.first;
            second = node->data.second;
        }
    }

    // Dereference
    std::pair<Key, Value>& operator*() const{
        if(node == nullptr)
            throw std::out_of_range("Can't dereference iterator");
        return node->data;
    }
    std::pair<Key, Value>* operator->() const{
        if(node == nullptr)
            throw std::out_of_range("Can't dereference iterator");
        return &(node->data);
    }

    // ++ opeartor
    MapIterator<Key, Value>& operator++(){
        // Update the node pointer
        node = successor(node);
        return *this;
    }

    // -- operator
    MapIterator<Key, Value>& operator--(){
        // Update the node pointer
        node = predecessor(node);
        return *this;
    }

    bool operator==(const MapIterator<Key, Value>& rhs)const{
        return node == rhs.node;
    }
    
    bool operator!=(const MapIterator<Key, Value>& rhs)const{
        return node != rhs.node;
    }
    friend class Map<Key, Value>;
};

template<typename Key, typename Value>
class Map{
private:
    MapNode<Key, Value>* root;
    int s{}; // Size
    static const int ALLOWED_IMBALANCE = 1;

    int height(MapNode<Key, Value>* nodePtr){
        // Used to get the heights of the nodes
        return (nodePtr == nullptr?-1:nodePtr->height);    
    }

    void insert(const std::pair<Key, Value>& item, MapNode<Key, Value>*& nodePtr){
        if(nodePtr == nullptr) {// We reached a leaf, insert the node
            nodePtr = new MapNode{item};
            ++s;
        } 

        else if (item.first < nodePtr->data.first)// Move left
            insert(item, nodePtr->left);

        else if (item.first > nodePtr->data.first) // Move right 
            insert(item, nodePtr->right);

        else { // Duplicate was found
               // Update the value
            nodePtr->data.second = item.second;
        }; 
        // Update children's parent pointer
        updateParentPointer(nodePtr);
        // Rebalace the tree
        balance(nodePtr);
    }

    void updateParentPointer(MapNode<Key, Value>* nodePtr){
        if (nodePtr == nullptr) return;
        if(nodePtr->right != nullptr) nodePtr->right->parent = nodePtr;
        if(nodePtr->left != nullptr) nodePtr->left->parent = nodePtr;
    }

    void insert(std::pair<Key, Value>&& item, MapNode<Key, Value>*& nodePtr){
        if(nodePtr == nullptr) {// We reached a leaf, insert the node
            nodePtr = new MapNode{item};
            ++s;
        }      

        else if (item.first < nodePtr->data.first) // Move left
            insert(std::move(item), nodePtr->left);

        else if (item.first > nodePtr->data.first) // Move right 
            insert(std::move(item), nodePtr->right);

        else { // Duplicate was found
               // Update the value
            nodePtr->data.second = item.second;
        }; 
        // Update children's parent pointer
        updateParentPointer(nodePtr);
        // Rebalance the tree
        balance(nodePtr);
    }

    void balance(MapNode<Key, Value>*& nodePtr){
        if(nodePtr == nullptr) return;

        if(height(nodePtr->left) - height(nodePtr->right) > ALLOWED_IMBALANCE){
            // Left side causes imbalance
            if(height(nodePtr->left->left)>= height(nodePtr->left->right))
                // left side of the left child casuse imbalance, case 1
                rotateWithLeftChild(nodePtr); // Single rotation
            else
                // right side of the left child casuse imbalance, case 2
                doubleWithLeftChild(nodePtr); // Double rotation
        }
        else if(height(nodePtr->right) - height(nodePtr->left) > ALLOWED_IMBALANCE){
            // Right side causes imbalance
            if(height(nodePtr->right->right) >= height(nodePtr->right->left))
                // right side of the child casuse imbalance, case 4
                rotateWithRightChild(nodePtr);
            else 
                // left side of the right child casuse imbalance, case 3
                doubleWithRightChild(nodePtr);
        }
        // Update the height of the node
        nodePtr->height = std::max(height(nodePtr->left), height(nodePtr->right)) +1;
    }
    void rotateWithLeftChild(MapNode<Key, Value>*& parent){
        // Hold the child node with a pointer
        MapNode<Key, Value>* child = parent->left; 
        // Repoint the parent's left pointer with the child's right's child
        parent->left = child->right;
        // Repoint the child's right pointer to its parent, rotation is done
        child->right = parent;
        // Update grandchildren's parent pointers
        updateParentPointer(parent);
        // Update the heights of parent & child
        parent->height = std::max(height(parent->left), height(parent->right))+1;
        child->height = std::max(height(child->right), height(child->left))+1;

        // Repoint the passed-by-reference pointer to the new parent
        parent = child;
        // Update the parent of the new parent
        parent->parent = parent->right->parent;
        // Update parent pointer of the children of the new parent
        updateParentPointer(parent);

    }
    void doubleWithLeftChild(MapNode<Key, Value>*& nodePtr){
        rotateWithRightChild(nodePtr->left);
        rotateWithLeftChild(nodePtr);
    }
    void rotateWithRightChild(MapNode<Key, Value>*& parent){
        // Hold the child node with a pointer
        MapNode<Key, Value>* child = parent->right;
        // Repoint the the parent's left pointer to the right child of its child
        parent->right = child->left;
        // Repoint the child's left pointer to its parent, rotaion is done
        child->left = parent;
        // Update grandchildren's parent pointers
        updateParentPointer(parent);
        // Update the heights of parent & child
        parent->height = std::max(height(parent->left), height(parent->right)) + 1;
        child->height = std::max(height(child->left), height(child->right)) + 1;

        // Repoint the passed-by-reference pointer to the new parent
        parent = child; 
        // Update the parent of the new parent
        parent->parent = parent->left->parent;
        // Update parent pointer of the children of the new parent
        updateParentPointer(parent);
    }
    void doubleWithRightChild(MapNode<Key, Value>*& nodePtr){
        rotateWithLeftChild(nodePtr->right);
        rotateWithRightChild(nodePtr);
    }

    MapNode<Key, Value>* findMin(MapNode<Key, Value>* nodePtr) const{
        if(nodePtr == nullptr) return nullptr;
        if(nodePtr->left == nullptr) return nodePtr; // Reached a leaf, return its pointer
        else return findMin(nodePtr->left); // Keep moving down the tree
    }

    MapNode<Key, Value>* findMax(MapNode<Key, Value>* nodePtr) const{
        if(nodePtr == nullptr) return nullptr;
        if(nodePtr->right == nullptr) return nodePtr; // Reached a leaf, return its pointer
        else return findMax(nodePtr->right); // Keep moving down the tree
    }

    void clear(MapNode<Key, Value>* nodePtr){
        if(nodePtr == nullptr) return; // Base case
        
        clear(nodePtr->right); // Clear nodes on the right
        clear(nodePtr->left);  // Clear nodes on the left
        delete nodePtr; // Delete the current node
    }

    void erase(const Key& item,MapNode<Key, Value>*& nodePtr){
        if(nodePtr == nullptr) return; // Item not found, return

        if(item < nodePtr->data.first) // Move left
            erase(item, nodePtr->left);

        else if (item > nodePtr->data.first) // Move right
            erase (item, nodePtr->right);

        else if (nodePtr->left != nullptr && nodePtr->right != nullptr){ 
            // Wanted node has two children
            // Replace the wanted node with the Minumum node on its right
            nodePtr->data = findMin(nodePtr->right)->data;
            // Erase the reaplced node
            erase(nodePtr->data.first, nodePtr->right);
        }

        else{ // Single child or no children
            // Hold the wanted node with a pointer
            MapNode<Key, Value>* oldNode = nodePtr;
            // Repoint the parent's pointer to the child of the wanted node
            nodePtr = (nodePtr->right == nullptr)? nodePtr->left : nodePtr->right; 
            // Erase the wanted node
            delete oldNode;
            // Decrement the size
            --s;
        }
        // Update children parent pointers
        updateParentPointer(nodePtr);
        // Rebalance the tree
        balance(nodePtr);
    }

    void erase(Key&& item, MapNode<Key, Value>*& nodePtr){
        if(nodePtr == nullptr) return; // Item not found, return

        if(item < nodePtr->data.first) // Move left 
            erase(std::move(item), nodePtr->left);

        else if (item > nodePtr->data.first) // Move right
            erase (std::move(item), nodePtr->right);

        else if (nodePtr->left != nullptr && nodePtr->right != nullptr){ 
            // Wanted node has two children
            // Replace the wanted node with the Minumum node on its right
            nodePtr->data = findMin(nodePtr->right)->data;
            // Erase the reaplced node
            erase(nodePtr->data.first, nodePtr->right);
        }

        else{ // Single child or no children
            // Hold the wanted node with a pointer
            MapNode<Key, Value>* oldNode = nodePtr;
            // Repoint the parent's pointer to the child of the wanted node
            nodePtr = (nodePtr->right == nullptr)? nodePtr->left : nodePtr->right; 
            // Erase the wanted node
            delete oldNode;
            // Decrement the size
            --s;
        }
        // Update children parent pointers
        updateParentPointer(nodePtr);
        // Rebalance the tree
        balance(nodePtr);
    }

    bool count(const Key& item, MapNode<Key, Value>* nodePtr) const{
        if(nodePtr == nullptr) 
            return false; // Item not found, return false

        else if (item < nodePtr->data.first) // Move left
            return count(item, nodePtr->left); 

        else if (item > nodePtr->data.first) // Move right
            return count(item, nodePtr->right); 

        else return true; // Item found, return true
    }

    bool count(Key&& item, MapNode<Key, Value>* nodePtr)const {
        if(nodePtr == nullptr) return false; // Item not found, return false

        else if (item < nodePtr->data.first) // Move left
            return count(std::move(item), nodePtr->left); 

        else if (item > nodePtr->data.first) // Move right
            return count(std::move(item), nodePtr->right);

        else return true; // Item found, return true
    }
    void __clone__setParents(MapNode<Key, Value>* nodePtr){
        if(nodePtr == nullptr) return; // Base case
        __clone__setParents(nodePtr->left);
        __clone__setParents(nodePtr->right);
        updateParentPointer(nodePtr);
    }

    void print(MapNode<Key, Value>* nodePtr){
        if (nodePtr == nullptr) return; // Base case

        print(nodePtr->left); // Print left subtree
        std::cout << nodePtr->data.first << ':' << nodePtr->data.second << " "; // Print current node
        print(nodePtr->right); // Print right subtree
    }

    MapNode<Key, Value>* clone(MapNode<Key, Value>* rhsNodePtr){
        if(rhsNodePtr == nullptr) return nullptr; // Base case
        return new MapNode{rhsNodePtr->data, clone(rhsNodePtr->left), clone(rhsNodePtr->right)};
    }

    MapNode<Key, Value>* find(const Key& item, MapNode<Key, Value>* nodePtr) const{
        if(nodePtr == nullptr) return nullptr;
        if(item < nodePtr->data.first) // Move left
            return find(item, nodePtr->left);
        else if(item > nodePtr->data.first) // Move right
            return find(item, nodePtr->right);
        else // Found item, return its pointer
            return nodePtr;
    }


public:


    // Default constructor
    Map():root{nullptr}, s{}{ }

    // Copy constructor
    Map(const Map<Key, Value>& rhs):s{rhs.size()}{
        root = clone (rhs.root);
        __clone__setParents(root);
    }

    // Destructor
    ~Map(){
        clear(root);
    }

    int size() const{
        return s;
    }

    // Copy assignment operator
    void operator=(const Map<Key, Value>& rhs){
        clear(root); // Empty the tree
        root = clone(rhs.root);
        __clone__setParents(root);
        s = rhs.s;
    }

    MapIterator<Key, Value> begin() const{
        return MapIterator<Key, Value>(findMin(root));
    }
    MapIterator<Key, Value> end() const{
        return MapIterator<Key, Value>(nullptr);
    }

    void insert(const std::pair<Key, Value>& item){
        insert(item, root);
    }

    void insert(std::pair<Key, Value>&& item){
        insert(std::move(item), root);
    }

    [[nodiscard]]std::pair<Key, Value>& findMin() const{
        if(root == nullptr){
            throw std::out_of_range("Can't find minimum in an empty map");
        }
        return findMin(root)->data;
    }

    [[nodiscard]]std::pair<Key, Value>& findMax() const{
        if(root == nullptr){
            throw std::out_of_range("Can't find maximum in an empty map");
        }
        return findMax(root)->data;
    }

    std::pair<MapIterator<Key, Value>, bool> emplace(const Key& key, const Value& value){
        insert(std::make_pair(key, value), root);
        return std::make_pair(find(key), true);
    }
    

    void clear(){
        clear(root);
        root = nullptr;
        s = 0;
    }

    void erase(const Key& item){
        erase(item, root);
    }

    void erase(Key&& item){
        erase(std::move(item), root);
    }

    void erase(MapIterator<Key, Value> iterator){
        if(iterator.node == nullptr) return;
        erase(iterator->first);
    }

    [[nodiscard]]bool count(const Key& item) const{
        return count(item, root);
    }

    [[nodiscard]]bool count(Key&& item) const{
        return count(std::move(item), root);
    }

    [[nodiscard]]MapIterator<Key, Value> find(const Key& item) const{
        return MapIterator<Key, Value>{find(item,root)};
    }

    [[nodiscard]]bool empty() const{
        return root == nullptr;
    }

    void print(){
        if (root == nullptr) return; // Tree is empty
        print(root);
        std::cout << std::endl;
    }

    Value& operator[](const Key& item){
        MapNode<Key, Value>* temp = root;
        while(temp != nullptr){
            if(item < temp->data.first) // Move left
                temp = temp->left;
            else if (item > temp->data.first) // Move right
                temp = temp->right;
            else 
                // Key was found return a reference to its value
                return temp->data.second; 
        }
        // Key not found, insert it
        insert(std::make_pair(item, Value{}), root);

        // Research for the inserted node and return a reference to its value
        temp = root;
        while (temp != nullptr){
            if (item < temp->data.first) // Move left
                temp = temp->left; 
            else if (item > temp->data.first) // Move right
                temp = temp->right;
            else
                // Key was found return a frerence to its value
                return temp->data.second;
        }

        throw std::logic_error("Couldn't find the key after insertion");
    }
};



#endif

==================================================
FILE PATH: .\include\structures\minHeap.h
==================================================

//
// Created by Omar on 12/11/2025.
//

#ifndef RMS_MINHEAP_H
#define RMS_MINHEAP_H
#include <vector>
template <class T>
class MinHeap {
private:
    std::vector<T> h;

    void up(int i){
        while(i > 0){
            int p = (i-1)/2;
            if(h[i] < h[p]){
                swap(h[i], h[p]);
                i = p;
            } else break;
        }
    }

    void down(int i){
        int n = h.size();
        while(true){
            int l = 2*i+1, r = 2*i+2;
            int s = i;

            if(l < n && h[l] < h[s]) s = l;
            if(r < n && h[r] < h[s]) s = r;

            if(s != i){
                swap(h[i], h[s]);
                i = s;
            } else break;
        }
    }

    int findIdx(const T& v){
        for(int i=0;i<h.size();i++){
            if(h[i] == v) return i;
        }
        return -1;
    }

public:
    void push(T v){
        h.push_back(v);
        up(h.size()-1);
    }

    T top(){
        return h[0];
    }

    T pop(){
        T x = h[0];
        h[0] = h.back();
        h.pop_back();
        if(!h.empty()) down(0);
        return x;
    }

    bool remove(const T& v){
        int i = findIdx(v);
        if(i == -1) return false;

        h[i] = h.back();
        h.pop_back();

        if(i < h.size()){
            up(i);
            down(i);
        }

        return true;
    }

    bool empty(){
        return h.empty();
    }
};

#endif //RMS_MINHEAP_H


==================================================
FILE PATH: .\include\structures\stack.h
==================================================

#ifndef RMS_STACK_H
#define RMS_STACK_H

#include <stdexcept>

template <class T>
struct Node {
    T data;
    Node<T>* link;
    Node(const T& val =-99999, Node<T>* link_ptr= nullptr) : data(val), link(link_ptr) {}
};

template <class T>
class stack {
private:
    Node<T>* topPtr;
    int counter;

public:
    stack() : topPtr(nullptr), counter(0) {}

    ~stack() {
        while (!empty()) pop();
    }

    void push(const T& value) {
        topPtr = new Node<T>(value, topPtr);
        ++counter;
    }
    //copy constructor
    stack(const stack& other);
    // assignment overloading
    stack& operator=(stack other);
    friend void swap(stack<T>& first, stack<T>& second)  {
        using std::swap;
        swap(first.topPtr, second.topPtr);
        swap(first.counter, second.counter);
    }
    void pop() {
        if (empty())
            throw std::runtime_error("Stack underflow: pop() on empty stack");

        Node<T>* temp = topPtr;
        topPtr = topPtr->link;
        delete temp;
        --counter;
    }

    T& top() {
        if (empty())
            throw std::runtime_error("Stack underflow: top() on empty stack");

        return topPtr->data;
    }
    const T& top() const {
        if (empty())
            throw std::runtime_error("Stack underflow: top() on empty stack");
        return topPtr->data;
    }
    bool empty() const {
        return topPtr == nullptr;
    }

    int size() const {
        return counter;
    }
};
// --- Implementation of Copy Constructor ---
template <class T>
stack<T>::stack(const stack& other) : topPtr(nullptr), counter(0) {
    if (other.empty()) {
        return; //empty stack
    }

    Node<T>* otherCurrent = other.topPtr;
    Node<T>* lastNewNode = nullptr;

    Node<T>* newNode = new Node<T>();

    newNode->data = otherCurrent->data;
    newNode->link = nullptr;

    this->topPtr = newNode;
    lastNewNode = newNode;

    otherCurrent = otherCurrent->link;
    this->counter = 1;

    // Copy the rest of the nodes
    while (otherCurrent != nullptr) {
        Node<T>* newNode = new Node<T>();
        newNode->data = otherCurrent->data;
        newNode->link = nullptr;

        lastNewNode->link = newNode;
        lastNewNode = newNode;

        otherCurrent = otherCurrent->link;
        this->counter++;
    }

}

template <class T>
stack<T>& stack<T>::operator=(stack<T> other) {
    swap(*this, other);
    return *this;
}

#endif // RMS_STACK_H


==================================================
FILE PATH: .\include\structures\unordered_map.h
==================================================

//
// Created by Omar on 12/11/2025.
//

#ifndef RMS_UNORDERED_MAP_H
#define RMS_UNORDERED_MAP_H
#include <vector>
#include <list>
#include <functional>
#include <utility>
#include <stdexcept>
#include <cstddef>
#include <limits>
template <typename Key, typename Value>
class unordered_map
{
private:
    struct Node
    {
        Key key;
        Value value;
        Node(const Key &k, const Value &v) : key(k), value(v) {}
        Node(Key &&k, Value &&v) : key(std::move(k)), value(std::move(v)) {}
    };

    std::vector<std::list<Node>> buckets;
    size_t elements = 0;
    float maxLoadFactor = 0.75f;

    size_t bucket_index(const Key &k) const
    {
        return std::hash<Key>{}(k) % buckets.size();
    }

    void check_rehash()
    {
        if (buckets.empty())
        {
            buckets.resize(8);
            return;
        }
        if ((float)(elements + 1) / buckets.size() > maxLoadFactor)
        {
            rehash(buckets.size() * 2);
        }
    }

public:
    // ITERATOR
    class iterator
    {
        using BucketList = std::list<Node>;
        unordered_map *map = nullptr;
        size_t bucketIdx = 0;
        typename BucketList::iterator listIt;
        friend class unordered_map;

        iterator(unordered_map *m, size_t b, typename BucketList::iterator it)
                : map(m), bucketIdx(b), listIt(it) {}

    public:
        iterator() = default;

        std::pair<const Key &, Value &> operator*() const
        {
            return {listIt->key, listIt->value};
        }

        iterator &operator++()
        {
            if (!map)
                return *this;

            ++listIt;

            while (bucketIdx < map->buckets.size() &&
                   listIt == map->buckets[bucketIdx].end())
            {
                ++bucketIdx;
                if (bucketIdx < map->buckets.size())
                    listIt = map->buckets[bucketIdx].begin();
            }

            return *this;
        }

        bool operator==(const iterator &other) const
        {
            if (map != other.map)
                return false;

            if (bucketIdx >= map->buckets.size() &&
                other.bucketIdx >= other.map->buckets.size())
                return true;

            if (bucketIdx >= map->buckets.size() ||
                other.bucketIdx >= other.map->buckets.size())
                return false;

            return bucketIdx == other.bucketIdx && listIt == other.listIt;
        }

        bool operator!=(const iterator &other) const
        {
            return !(*this == other);
        }
    };
    class const_iterator
    {
        using BucketList = std::list<Node>;
        const unordered_map* map = nullptr;
        size_t bucketIdx = 0;
        typename BucketList::const_iterator listIt;
        friend class unordered_map;

        const_iterator(const unordered_map* m, size_t b, typename BucketList::const_iterator it)
                : map(m), bucketIdx(b), listIt(it) {}

    public:
        const_iterator() = default;

        std::pair<const Key&, const Value&> operator*() const
        {
            return {listIt->key, listIt->value};
        }

        const_iterator& operator++()
        {
            if (!map) return *this;

            ++listIt;

            while (bucketIdx < map->buckets.size() &&
                   listIt == map->buckets[bucketIdx].end())
            {
                ++bucketIdx;
                if (bucketIdx < map->buckets.size())
                    listIt = map->buckets[bucketIdx].begin();
            }

            return *this;
        }

        bool operator==(const const_iterator& other) const
        {
            if (map != other.map) return false;

            if (bucketIdx >= map->buckets.size() &&
                other.bucketIdx >= other.map->buckets.size())
                return true;

            if (bucketIdx >= map->buckets.size() ||
                other.bucketIdx >= other.map->buckets.size())
                return false;

            return bucketIdx == other.bucketIdx && listIt == other.listIt;
        }

        bool operator!=(const const_iterator& other) const
        {
            return !(*this == other);
        }
    };

    unordered_map() { buckets.resize(8); }
    ~unordered_map() { clear(); }
    unordered_map(const unordered_map &other)
            : buckets(other.buckets), elements(other.elements), maxLoadFactor(other.maxLoadFactor)
    {
    }

    unordered_map &operator=(const unordered_map &other)
    {
        if (this != &other)
        {
            buckets = other.buckets;
            elements = other.elements;
            maxLoadFactor = other.maxLoadFactor;
        }
        return *this;
    }
    //  for = { } assginment
    unordered_map(std::initializer_list<std::pair<const Key, Value>> init)
    {
        buckets.resize(8);
        for (const auto &kv : init)
            insert(kv);
    }


    // ELEMENT ACCESS

    Value &operator[](const Key &k)
    {
        check_rehash();
        size_t idx = bucket_index(k);
        for (auto it = buckets[idx].begin(); it != buckets[idx].end(); ++it)
        {
            if (it->key == k)
                return it->value;
        }
        // Not found, insert with default value
        buckets[idx].emplace_back(k, Value{});
        ++elements;
        return buckets[idx].back().value;
    }
    unordered_map &operator=(unordered_map &&other) noexcept
    {
        if (this != &other)
        {
            buckets = std::move(other.buckets);
            elements = other.elements;
            maxLoadFactor = other.maxLoadFactor;
            other.elements = 0;
        }
        return *this;
    }


    Value &at(const Key &k)
    {
        size_t idx = bucket_index(k);
        for (auto &node : buckets[idx])
        {
            if (node.key == k)
                return node.value;
        }
        throw std::out_of_range("unordered_map::at: key not found");
    }

    const Value &at(const Key &k) const
    {
        size_t idx = bucket_index(k);
        for (const auto &node : buckets[idx])
        {
            if (node.key == k)
                return node.value;
        }
        throw std::out_of_range("unordered_map::at: key not found");
    }
    // CAPACITY
    bool empty() const noexcept { return elements == 0; }
    size_t size() const noexcept { return elements; }
    size_t max_size() const noexcept { return std::numeric_limits<size_t>::max() / 2; }
    // MODIFIERS
    void clear() noexcept
    {
        for (auto &bucket : buckets)
            bucket.clear();
        elements = 0;
    }

    std::pair<iterator, bool> insert(const std::pair<Key, Value> &kv)
    {
        check_rehash();
        size_t idx = bucket_index(kv.first);
        // Check if key exists
        for (auto it = buckets[idx].begin(); it != buckets[idx].end(); ++it)
        {
            if (it->key == kv.first)
                return {iterator(this, idx, it), false};
        }
        // Insert new element
        buckets[idx].emplace_back(kv.first, kv.second);
        ++elements;
        auto it = buckets[idx].end();
        --it;
        return {iterator(this, idx, it), true};
    }

    std::pair<iterator, bool> insert(std::pair<Key, Value> &&kv)
    {
        check_rehash();
        size_t idx = bucket_index(kv.first);
        for (auto it = buckets[idx].begin(); it != buckets[idx].end(); ++it)
        {
            if (it->key == kv.first)
                return {iterator(this, idx, it), false};
        }
        buckets[idx].emplace_back(std::move(kv.first), std::move(kv.second));
        ++elements;
        auto it = buckets[idx].end();
        --it;
        return {iterator(this, idx, it), true};
    }

    template <typename... Args>
    std::pair<iterator, bool> emplace(Args &&...args)
    {
        check_rehash();
        Node node(std::forward<Args>(args)...);
        size_t idx = bucket_index(node.key);

        for (auto it = buckets[idx].begin(); it != buckets[idx].end(); ++it)
        {
            if (it->key == node.key)
                return {iterator(this, idx, it), false};
        }

        buckets[idx].push_back(std::move(node));
        ++elements;
        auto it = buckets[idx].end();
        --it;
        return {iterator(this, idx, it), true};
    }

    size_t erase(const Key &k)
    {
        size_t idx = bucket_index(k);
        auto &bucket = buckets[idx];
        for (auto it = bucket.begin(); it != bucket.end(); ++it)
        {
            if (it->key == k)
            {
                bucket.erase(it);
                --elements;
                return 1;
            }
        }
        return 0;
    }

    iterator erase(iterator pos)
    {
        if (!pos.map || pos.bucketIdx >= buckets.size())
            return end();
        auto &bucket = buckets[pos.bucketIdx];
        auto nextIt = pos.listIt;
        ++nextIt;
        bucket.erase(pos.listIt);
        --elements;
        return iterator(this, pos.bucketIdx, nextIt);
    }

    void swap(unordered_map &other)
    {
        buckets.swap(other.buckets);
        std::swap(elements, other.elements);
        std::swap(maxLoadFactor, other.maxLoadFactor);
    }
    // LOOKUP
    iterator find(const Key &k)
    {
        size_t idx = bucket_index(k);
        auto &bucket = buckets[idx];
        for (auto it = bucket.begin(); it != bucket.end(); ++it)
        {
            if (it->key == k)
                return iterator(this, idx, it);
        }
        return end();
    }
    const_iterator find(const Key &k) const
    {
        size_t idx = bucket_index(k);
        const auto &bucket = buckets[idx];
        for (auto it = bucket.begin(); it != bucket.end(); ++it)
            if (it->key == k)
                return const_iterator(this, idx, it);
        return end();
    }
    size_t count(const Key &k) const
    {
        size_t idx = bucket_index(k);
        const auto &bucket = buckets[idx];
        for (const auto &node : bucket)
        {
            if (node.key == k)
                return 1;
        }
        return 0;
    }

    iterator lower_bound(const Key &k) { return end(); } // unused
    iterator upper_bound(const Key &k) { return end(); } // unused

    // REHASH
    void rehash(size_t n)
    {
        if (n == 0)
            return;
        std::vector<std::list<Node>> newBuckets(n);
        for (auto &bucket : buckets)
        {
            for (auto &node : bucket)
            {
                size_t idx = std::hash<Key>{}(node.key) % n;
                newBuckets[idx].emplace_back(std::move(node.key), std::move(node.value));
            }
        }
        buckets.swap(newBuckets);
    }

    void reserve(size_t n)
    {
        size_t requiredBuckets = static_cast<size_t>(n / maxLoadFactor) + 1;
        if (requiredBuckets > buckets.size())
            rehash(requiredBuckets);
    }
    // ITERATORS
    iterator begin()
    {
        for (size_t i = 0; i < buckets.size(); ++i)
            if (!buckets[i].empty())
                return iterator(this, i, buckets[i].begin());
        return end();
    }

    iterator end()
    {
        if (buckets.empty())
            return iterator(this, 0, typename std::list<Node>::iterator{});
        return iterator(this, buckets.size(), {});
    }
    const_iterator begin() const
    {
        for (size_t i = 0; i < buckets.size(); ++i)
            if (!buckets[i].empty())
                return const_iterator(this, i, buckets[i].cbegin());
        return end();
    }

    const_iterator end() const
    {
        return const_iterator(this, buckets.size(), {});
    }

};
#endif //RMS_UNORDERED_MAP_H


==================================================
FILE PATH: .\include\structures\vector.h
==================================================

//
// Created by Omar on 12/11/2025.
//

#ifndef RMS_VECTOR_H
#define RMS_VECTOR_H

#include <iostream>
#include <algorithm> // for std::copy
#include <stdexcept> // for std::out_of_range
#include <initializer_list>

template <typename T>
class vector{
private:
    T* data;
    size_t current_size;
    size_t current_capacity;

    void resize(size_t new_capacity){
        //allocate new memory
        T* new_data = new T[new_capacity];
        //copy elements
        for(size_t i = 0; i < current_size; i++){
            new_data[i] = data[i];
        }
        //delete old memory
        delete[] data;
        //point to new mamory
        data = new_data;
        current_capacity = new_capacity;
    }
public:
    vector() : data(nullptr), current_size(0), current_capacity(0) {}
    ~vector(){
        delete[] data;
    }
    //copy constructor(Deep copy)
    vector(const vector& other)
            : data(new T[other.current_capacity]),
              current_size(other.current_size),
              current_capacity(other.current_capacity) {
        std::copy(other.data, other.data + current_size, data);
    }
    // initializer_list constructor
    vector(std::initializer_list<T> init)
            : data(new T[init.size()]),
              current_size(init.size()),
              current_capacity(init.size())
    {
        size_t i = 0;
        for (const T& val : init) {
            data[i++] = val;
        }
    }

    //copy assignment operator(Deep copy)
    vector& operator=(const vector& other){
        if(this != &other){
            delete[] data;
            current_size = other.current_size;
            current_capacity = other.current_capacity;
            data = new T[current_capacity];
            std::copy(other.data, other.data + current_size, data);
        }
        return *this;
    }
    //move constructor
    vector(vector&& other) noexcept
            : data(other.data), current_size(other.current_size), current_capacity(other.current_capacity){
        other.data = nullptr;
        other.current_size = 0;
        other.current_capacity = 0;
    }
    //move assignment constructor
    vector& operator=(vector&& other) noexcept{
        if(this != &other){
            delete[] data;
            data = other.data;
            current_size = other.current_size;
            current_capacity = other.current_capacity;
            other.data = nullptr;
            other.current_size = 0;
            other.current_capacity = 0;
        }
        return *this;
    }

    void push_back(const T& value){
        if (current_size == current_capacity){
            size_t new_capacity = (current_capacity == 0) ? 1 : current_capacity * 2;
            resize(new_capacity);
        }
        data[current_size] = value;
        current_size++;
    }

    void pop_back(){
        if (current_size > 0) {
            current_size--;
        }
    }

    size_t size() const{return current_size;}
    size_t capacity() const {return current_capacity;}

    T& operator[](size_t index){
        if (index >= current_size) {
            throw std::out_of_range("Index out of bounds");
        }
        return data[index];
    }

    const T& operator[](size_t index) const{
        if (index >= current_size) {
            throw std::out_of_range("Index out of bounds");
        }
        return data[index];
    }

    T* begin(){return data;}
    T* end(){return data + current_size;}

    const T* begin() const{return data;}
    const T* end() const {return data + current_size;}

    T& front(){
        if(current_size == 0) throw std::out_of_range("Vector is empty");
        return data[0];
    }
    T& back(){
        if(current_size == 0) throw std::out_of_range("Vector is empty");
        return data[current_size - 1];
    }
    bool empty() const{
        return current_size == 0;
    }
    void clear(){
        current_size = 0;
    }

    void insert(size_t index, const T& value){
        if(index > current_size){
            throw std::out_of_range("Index out of bounds");
        }
        if(current_size == current_capacity){
            size_t new_capacity = (current_capacity == 0) ? 1 : current_capacity * 2;
            resize(new_capacity);
        }
        for(size_t i = current_size; i > index; --i){
            data[i] = data[i - 1];
        }
        data[index] = value;
        current_size++;
    }

    void erase(size_t index){
        if(index >= current_size){
            throw std::out_of_range("Index out of bounds");
        }
        for(size_t i = index; i < current_size - 1; ++i){
            data[i] = data[i + 1];
        }
        current_size--;
    }


};

#endif //RMS_VECTOR_H


==================================================
FILE PATH: .\include\utils\helpers.h
==================================================

//
// Created by Omar on 11/24/2025.
//

#ifndef RMS_HELPERS_H
#define RMS_HELPERS_H
#include <string>
#include "../structures/vector.h"
#include "models/Train.h"
#include "models/Passenger.h"
#include "models/Ticket.h"

// string validation
std::string toLowerCase(std::string word);
std::string trim(const std::string &str);
bool isValidName(const std::string& name);
// string concat
std::string combineString(const vector<std::string>& args, int start);
std::string combineString(const vector<std::string>& args, int start , int end);
bool compareString(const std::string& str1 , const std::string& str2);
// integer helpers
bool isInteger(const std::string& str);
int parseInt(const std::string& arg , const std::string& argName);

// print msg

void printCurrentDate();

#endif //RMS_HELPERS_H


==================================================
FILE PATH: .\src\CLIController.cpp
==================================================

//
// Created by Omar on 11/25/2025.
//

#include <sstream>
#include <iomanip> // required for setw()
#include <limits> // for numeric_limits
#include <cstdlib> // Required for system()

#include "CLIController.h"
#include "utils/helpers.h" // parseInt , trim
#include "RMSCommand.h"
using std::cout ;
using std::endl;
using std::string;
using std::cin;
using  std::stringstream;
using  std::left;
using  std::setw;
using  std::exception;

//enums [MainCmd instead of RMSCommand::MainCmd
using MainCmd = RMSCommand::MainCmd;
using TrainCmd = RMSCommand::TrainCmd;
using PassengerCmd = RMSCommand::PassengerCmd;
using TicketCmd = RMSCommand::TicketCmd;
using SystemCmd = RMSCommand::SystemCmd;
// getters
// pointer fo functions
auto getMainCmd =  RMSCommand::getMainCmd;
auto getTrainCmd =  RMSCommand::getTrainCmd;
auto getPassengerCmd=  RMSCommand::getPassengerCmd;
auto getTicketCmd = RMSCommand::getTicketCmd;
auto getSystemCmd =RMSCommand::getSystemCmd;


vector<string> CLIController::tokenize(const string &args) { // split the sentence to args
    stringstream ss(args);
    vector<string> tokens ;
    string token;
    while(ss >> token){
        tokens.push_back(token);
    }
    return tokens;
}
void CLIController::waitUser(){
//    cin.ignore(numeric_limits<streamsize>::max(), '\n'); //  clear buffer to ingnore '\n'
    cout << "Press Enter to exit...";
    cin.get(); // wait for Enter
}
string CLIController::readLine() {
    string line;
    getline(cin ,line);
    return line;
}

void CLIController::show_help() {
    cout << "\n=================================================\n";
    cout << "        RMS - Railway Management System          \n";
    cout << "=================================================\n\n";

    cout << "Usage: <command> [arguments]\n\n";

    cout << "---------------------- Commands ----------------------\n\n";


    // ======================== TRAIN ========================
    cout << "train:\n";
    cout << "   train list                                     - Show all trains\n";
    cout << "   train add <name> <seats>                       - Add a new train\n";
    cout << "   train delete <id>                              - Remove a train\n";
    cout << "   train update <id> <seats> <name>               - Update a train\n";
    cout << "   train seats add <id> <count>                   - Increase seat count\n";
    cout << "   train availability <id>                        - Show seat status\n\n";
    cout << "   train status <id>                              - Show full train status\n\n";

    // ====================== PASSENGER ======================
    cout << "passenger:\n";
    cout << "   passenger list                                 - Show all passengers\n";
    cout << "   passenger add <name>                           - Add a passenger\n";
    cout << "   passenger delete <id>                          - Remove a passenger\n";
    cout << "   passenger update <id> <newName>                - Rename passenger\n\n";

    // ======================== TICKET ========================
    cout << "ticket:\n";
    cout << "   ticket list                                    - Show all tickets\n";
    cout << "   ticket book <trainId> <passengerId|name>       - Book a ticket\n";
    cout << "   ticket cancel <ticketId>                       - Cancel a ticket\n\n";

    // ========================= SYSTEM ========================
    cout << "system:\n";
    cout << "   help | h | ?                                   - Show help menu\n";
    cout << "   exit | quit | q                                - Exit program\n";
    cout << "   clear                                          - Clear Screen\n";

    cout << "--------------------------------------------------------\n\n";
}



void CLIController::list_trains() {
    const auto trains = facade->listTrains();
    if(trains.empty())
        cout << "No trains avialble \n";
    cout << "\n======== Trains ==========\n";
    cout << left << setw(6) << "ID"
         << left << setw(20) << "Name"
         << left << setw(20) << "Status"
         << "\n";

    for (auto &train : trains) {

        int seats = train.getSeatAllocator()->getAvailableSeatCount();

        string status = (seats == 0)
                        ? "Full"
                        : std::to_string(seats) + " seats available";

        cout << left << setw(6)  << train.getTrainId()
             << left << setw(20) << train.getTrainName()
             << left << setw(20) << status
             << "\n";
    }

}

void CLIController::list_passengers() {
    const auto passengers = facade->listPassengers();
    if(passengers.empty())
        cout << "No passengers avialble \n";
    cout << "\n======== Passengers ==========\n\n";
    cout << left << setw(6) << "ID"
         << left << setw(20) << "Name" << "\n";

    for (auto &passenger : passengers) {
        cout << left << setw(6) << passenger.getId()
             << left << setw(20) << passenger.getName()
             << "\n";
    }
}

void CLIController::list_tickets() {
    const auto tickets = facade->listTickets();
    if(tickets.empty())
        cout << "No tickets available \n";
    cout << "\n====================================== Tickets =======================================\n";

    cout << left
         << setw(8)  << "id"
         << setw(12) << "trainId"
         << setw(15) << "ticket_seat"
         << setw(15) << "passengerId"
         << setw(20) << "passenger_name"
         << setw(15) << "status"
         << endl;

    for (auto &ticket : tickets) {
        cout << left
             << setw(8)  << ticket.getId()
             << setw(12) << ticket.getTrainId()
             << setw(15) << ticket.getSeat()
             << setw(15) << ticket.getPassenger().getId()
             << setw(20) << ticket.getPassenger().getName()
             << setw(15) << ((ticket.getStatus() == booked) ? "Booked" : "Cancelled")
             << endl;
    }
}





CLIController::CLIController(RMSFacade *facade) :facade(facade){

}
void sayWelcome(){
    cout << "===============================================\n";
    cout << "  Welcome to the Railway Reservation System  \n";
    cout << "===============================================\n";
    cout << "Type 'help' to show the list of commands.\n";
    cout << "-----------------------------------------------\n";
    printCurrentDate();
    cout << "-----------------------------------------------\n";
    cout << "Author : Dangerous Team .\n";
    cout << "Under the supervision of Dr.Iman and Eng/Mariem Abdelrahman.\n\n";
}
void CLIController::run() {
    clear();
    sayWelcome();
//lambad function
    auto printUsage = [](MainCmd cmd) {
        switch(cmd) {
            case MainCmd::TRAIN:      cout << "Usage: train <list|add|delete|update|seats|availability>\n"; break;
            case MainCmd::PASSENGER:  cout << "Usage: passenger <list|add|delete|update>\n"; break;
            case MainCmd::TICKET:     cout << "Usage: ticket <list|book|cancel>\n"; break;
            default:                  cout << "Unknown command. Type 'help' for available commands.\n";
        }
    };

    while (true) {
        cout << "\ncmd > ";
        string line = readLine();
        vector<string> args = tokenize(line);

        if (args.empty()) {
            cout << "Please enter a command. Type 'help' for available commands.\n";
            continue;
        }

        MainCmd mainCmd = getMainCmd(args[0]);

        switch (mainCmd) {

            // ===================== TRAIN =====================
            case MainCmd::TRAIN: {
                if (args.size() < 2) { printUsage(mainCmd); break; }
                TrainCmd tCmd = getTrainCmd(args[1]);
                switch (tCmd) {
                    case TrainCmd::LIST:         list_trains(); break;
                    case TrainCmd::ADD:          add_train(args); break;
                    case TrainCmd::DELETE:       delete_train(args); break;
                    case TrainCmd::UPDATE:       update_train(args); break;
                    case TrainCmd::SEATS_ADD:    add_seats(args); break;
                    case TrainCmd::AVAILABILITY: get_train_availability(args); break;
                    case TrainCmd::STATUS: get_train_status(args); break;

                    default: cout << "Invalid train command.\n";
                }
                break;
            }

                // ===================== PASSENGER =====================
            case MainCmd::PASSENGER: {
                if (args.size() < 2) { printUsage(mainCmd); break; }
                PassengerCmd pCmd = getPassengerCmd(args[1]);
                switch (pCmd) {
                    case PassengerCmd::LIST:   list_passengers(); break;
                    case PassengerCmd::ADD:    add_passenger(args); break;
                    case PassengerCmd::DELETE: delete_passenger(args); break;
                    case PassengerCmd::UPDATE: update_passenger(args); break;
                    default: cout << "Invalid passenger command.\n";
                }
                break;
            }

                // ===================== TICKET =====================
            case MainCmd::TICKET: {
                if (args.size() < 2) { printUsage(mainCmd); break; }
                TicketCmd tkCmd = getTicketCmd(args[1]);
                switch (tkCmd) {
                    case TicketCmd::LIST:   list_tickets(); break;
                    case TicketCmd::BOOK:   book_ticket(args); break;
                    case TicketCmd::CANCEL: cancel_ticket(args); break;
                    default: cout << "Invalid ticket command.\n";
                }
                break;
            }

                // ===================== SYSTEM =====================
            case MainCmd::SYSTEM: {
                SystemCmd sCmd = getSystemCmd(args[0]);
                switch (sCmd) {
                    case SystemCmd::HELP: show_help(); break;
                    case SystemCmd::CLEAR :
                        clear();
                        sayWelcome();
                        break;
                    case SystemCmd::EXIT:
                        cout << "Goodbye!\n";
                        waitUser();
                        return;
                    default: cout << "Invalid system command.\n";
                }
                break;
            }

                // ===================== UNKNOWN =====================
            default:
                cout << "Unknown command. Type 'help' for available commands.\n";
        }
    }
}

void CLIController::add_passenger(const vector<string> &args) {
//add passenger <name>
    if(args.size() < 3) {
        cout << "Usage: passenger add  <name>\n";

        return;
    }
     string name;
    try{
        name = combineString(args,2);
        auto p = facade->addPassenger(name);
        p.print("--- Passenger Added Successfully ---\n");

    } catch(const exception& e) {
        cout << "ERROR: Could not add passenger " << name << ". " << "\n";
        cout << "Details: " << e.what() << "\n";

    }
}

void CLIController::get_train_availability(const vector<string> &args) {
//    train availability <train_id>
    if(args.size() < 3) {
        cout << "Usage: train availability <train_id>\n";
        return;
    }
    int id ;
    try{
        id = parseInt(args[2],"id");
        bool isAvailable = facade->getTrainAvailability(id);
        if(!isAvailable)
            cout << "This train is full \n";
        else
            cout << "This train is available \n";

    }catch(const exception& e){
        cout << "Error while get_train_availability : " << e.what() << endl;
        return;
    }



}
void CLIController::clear(){
    system("cls");
}

void CLIController::add_train(const vector<string> &args) {
    if(args.size() < 4) {
        cout << "Usage: train add  <name> <seats> \n";
        return;
    }
    const string& seatArgs = args[args.size()-1];
    string name;
    try {
        const int &seats = parseInt(seatArgs,"seats");
        name = combineString(args,2,-1);
        cout << name << " ";
        auto t = facade->addTrain(name,seats);
        t.print("--- Train Added Successfully ---\n");

    }
    catch (const exception& e) {
        cout << "ERROR: Could not add train " << name << ". " << e.what() << "\n";
    }
}
void CLIController::book_ticket(const vector<string> &args) {
    if(args.size() < 4) { // book ticket <train_id> <passenger_name>
        cout << "Usage: ticket book  <train_id> <passenger_name>\n";
        return;
    }

    const string& trainIdArg = args[2];
     string passengerName ;

    try {
        int trainId = parseInt(trainIdArg, "train ID");
        passengerName = combineString(args,3);

        auto t = facade->bookTicket(trainId, passengerName);
        if(t.has_value())
            t->print("--- Ticket Booked Successfully ---\n");
        else
            cout << "train is full so the passenger added to the waiting list \n";

    } catch (const exception& e) {
        cout << "ERROR: Could not book ticket for " << passengerName << " on Train ID " << trainIdArg << ".\n";
        cout << "Details: " << e.what() << "\n";
    }
}

void CLIController::cancel_ticket(const vector<string> &args) {
    if(args.size() < 3) { // cancel ticket <ticket_id>
        cout << "Usage: ticket cancel  <ticket_id>\n";
        return;
    }

    const string& ticketIdArg = args[2];

    try {
        int ticketId = parseInt(ticketIdArg, "ticket ID");
        facade->cancelTicket(ticketId);

        cout << "--- Ticket Cancelled Successfully ---\n";
        cout << "Ticket ID: " << ticketId << " has been cancelled.\n";
        cout << "-------------------------------------\n";

    } catch (const exception& e) {
        // Error Message
        cout << "ERROR: Could not cancel ticket " << ticketIdArg << ".\n";
        cout << "Details: " << e.what() << "\n";
    }
}

void CLIController::update_train(const vector<string> &args) {

    if(args.size() < 5) {
        cout << "Usage: train update  <train_id> <name> <seats>\n";
        return;
    }

    const string& tarinIdArg = args[2];
    const string& seatArg = args[args.size()-1];;
    try {
        int trainId = parseInt(tarinIdArg , "train id");
        int seats = parseInt(seatArg, "seat number");
        string name = combineString(args,3,-1);
        auto t =facade->updateTrain(trainId , name , seats);

        t.print( "------ Train updated successfully ------ \n");


    } catch (const exception& e) {
        cout << "ERROR: Could not updateTrain " << tarinIdArg << ".\n";
        cout << "Details: " << e.what() << "\n";
    }
}

void CLIController::add_seats(const vector<string> &args) {
    if(args.size() < 5) {
        cout << "Usage: train seats  <trainId|trainName> <seats>\n";
        return;
    }

    const string& trainArg = args[2];
    const string& seatArg = args[3];
    try {
        int seats = parseInt(seatArg, "seat number");
        // add seats trainId
        if(isInteger(trainArg)){
            int trainId = parseInt(trainArg , "train id");
            const auto &t = facade->addSeats(trainId, seats);
            t.print( "--- Train updated successfully. --- \n");

        }else{  // add seats trainName
            string name = combineString(args,2,-1); // until last field
            const auto &t =facade->addSeats(name, seats);
            t.print( "Train updated successfully.\n");

        }



    } catch (const exception& e) {
        cout << "ERROR: Could not update Train " << trainArg << ".\n";
        cout << "Details: " << e.what() << "\n";
    }
}

void CLIController::update_passenger(const vector<string> &args) {
    if(args.size() < 5) {
        cout << "Usage: passenger update <passengerId> <newName>\n";
        return;
    }

    const string& passengerArg = args[2];
    try {
        int passengerId = parseInt(passengerArg , "passenger Id");
        string name = combineString(args,3);
        auto p = facade->updatePassenger(passengerId, name);
        p.print( "------ Passenger updated successfully ------ \n");

    } catch (const exception& e) {
        cout << "ERROR: Could not update passenger " << passengerArg<< ".\n";
        cout << "Details: " << e.what() << "\n";
    }
}

void CLIController::delete_train(const vector<string> &args) {
    if(args.size() < 3) {
        cout << "Usage: train delete  <trainId>\n";
        return;
    }
    const string& trainArg = args[2];
    try {
        int trainId = parseInt(trainArg,"train Id");
        facade->deleteTrain(trainId);
        cout << "train with id " << trainId << " deleted successfully \n";
    }catch (const exception& e) {
        cout << "ERROR: Could not delete train" << ".\n";
        cout << "Details: " << e.what() << "\n";
    }
}

void CLIController::delete_passenger(const vector<string> &args) {
    if(args.size() < 3) {
        cout << "Usage: passenger delete  <passengerId>\n";
        return;
    }
    const string& passengerArg = args[2];
    try {
        int passengerId = parseInt(passengerArg,"train Id");
        facade->deletePassenger(passengerId);
        cout << "passenger with id " << passengerId << " deleted successfully \n";
    }catch (const exception& e) {
        cout << "ERROR: Could not delete passenger" << ".\n";
        cout << "Details: " << e.what() << "\n";
    }
}

void CLIController::get_train_status(const vector<string> &args) {
    if(args.size() < 3) {
        cout << "Usage: train status  <trainId>\n";
        return;
    }
    const string& trainArg = args[2];
    try {
        int trainId = parseInt(trainArg,"train Id");
        facade->trainStatus(trainId);
    }catch (const exception& e) {
        cout << "ERROR: could not print train data with id : " << trainArg << ".\n";
        cout << "Details: " << e.what() << "\n";
    }
}




==================================================
FILE PATH: .\src\main.cpp
==================================================

#include "models/SeatAllocator.h"
#include <iostream>
#include "RMSApp.h"



int main(int argc, char **argv)
{
    RMSApp app;
    app.run();
    return 0;
}

==================================================
FILE PATH: .\src\RMSApp.cpp
==================================================

//
// Created by Omar on 12/1/2025.
//

#include "RMSApp.h"

RMSApp::RMSApp() {
    startupManager = std::make_unique<StartupManager>();

    auto facade = startupManager->buildFacade(); // build the app with startup manager

    cli = std::make_unique<CLIController>(facade);// pass facade to startup manager
}

void RMSApp::run() {
    cli->run();
}


==================================================
FILE PATH: .\src\RMSCommand.cpp
==================================================

//
// Created by Omar on 12/1/2025.
//
#include "RMSCommand.h"

RMSCommand::MainCmd RMSCommand::getMainCmd(const string &cmd){
    static const unordered_map<string, MainCmd> table = {
            {"train", MainCmd::TRAIN},
            {"passenger", MainCmd::PASSENGER},
            {"ticket", MainCmd::TICKET},
            {"help", MainCmd::SYSTEM},
            {"h", MainCmd::SYSTEM},
            {"?", MainCmd::SYSTEM},
            {"exit", MainCmd::SYSTEM},
            {"quit", MainCmd::SYSTEM},
            {"q", MainCmd::SYSTEM},
            {"clear", MainCmd::SYSTEM},


    };
    auto it = table.find(cmd);
    return (it != table.end()) ? (*it).second : MainCmd::UNKNOWN;
}

RMSCommand::TrainCmd RMSCommand::getTrainCmd(const string &sub) {
    static const unordered_map<string, TrainCmd> table = { // static map to initializing only once
            {"list", TrainCmd::LIST},
            {"add", TrainCmd::ADD},
            {"delete", TrainCmd::DELETE},
            {"update", TrainCmd::UPDATE},
            {"seats", TrainCmd::SEATS_ADD},
            {"availability", TrainCmd::AVAILABILITY},
            {"status" , TrainCmd::STATUS}
    };
    auto it = table.find(sub);
    return (it != table.end()) ? (*it).second : TrainCmd::UNKNOWN;
}
RMSCommand::PassengerCmd RMSCommand::getPassengerCmd(const string &sub)  {
    static const unordered_map<string, PassengerCmd> table = {
            {"list", PassengerCmd::LIST},
            {"add", PassengerCmd::ADD},
            {"delete", PassengerCmd::DELETE},
            {"update", PassengerCmd::UPDATE}
    };
    auto it = table.find(sub);
    return (it != table.end()) ? (*it).second : PassengerCmd::UNKNOWN;
}
RMSCommand::TicketCmd RMSCommand::getTicketCmd(const string &sub) {
    static const unordered_map<string, TicketCmd> table = {
            {"list", TicketCmd::LIST},
            {"book", TicketCmd::BOOK},
            {"cancel", TicketCmd::CANCEL}
    };
    auto it = table.find(sub);
    return (it != table.end()) ? (*it).second : TicketCmd::UNKNOWN;
}


RMSCommand::SystemCmd RMSCommand::getSystemCmd(const string &cmd) {
    if(cmd == "help" || cmd == "h" || cmd == "?") return SystemCmd::HELP;
    if(cmd == "exit" || cmd == "quit" || cmd == "q") return SystemCmd::EXIT;
    if(cmd == "clear") return SystemCmd::CLEAR;

    return SystemCmd::UNKNOWN;
}


==================================================
FILE PATH: .\src\RMSFacade.cpp
==================================================

//
// Created by Omar on 11/21/2025.
//
#include "RMSFacade.h"
#include <stdexcept> //for run time exception
#include <iostream>
#include "utils/helpers.h"

RMSFacade::RMSFacade(TrainService *ts, TicketService *tks, PassengerService *ps)
{
    this->trainService = ts;
    this->ticketService = tks;
    this->passengerService = ps;
}

// ============ Trains =============
vector<Train> RMSFacade::listTrains()
{
    return trainService->getAllTrains();
}

Train RMSFacade::addTrain(std::string name, int totalSeats)
{
    name = trim(name);
    if (name.empty())
    {
        throw std::invalid_argument("Train name cannot be empty");
    }

    if (totalSeats <= 0)
    {
        throw std::invalid_argument("Total seats must be greater than 0");
    }

    return trainService->createTrain(name, totalSeats);
}

Train RMSFacade::getTrain(int trainId)
{
    return trainService->getTrain(trainId);
}
// ============ Passengers =============

Passenger RMSFacade::getPassenger(int passengerId)
{
    return passengerService->getPassenger(passengerId);
}

Passenger RMSFacade::addPassenger(const std::string& name)
{
    std::string trimmedName = trim(name);
    if (!isValidName(trimmedName))
        throw std::invalid_argument("Passenger name is not valid");

    return passengerService->createPassenger(trimmedName);
}

vector<Ticket> RMSFacade::listTickets()
{
    return ticketService->getAllTickets();
}

vector<Passenger> RMSFacade::listPassengers()
{
    return passengerService->getAllPassengers();
}

// ============ Tickets =============
std::optional<Ticket> RMSFacade::bookTicket(int trainId, const std::string &passengerName)
{
    // input validation
    if (trainId <= 0)
        throw std::invalid_argument("Train ID must be greater than 0");
    std::string trimmedName = trim(passengerName);

    if (!isValidName(trimmedName))
        throw std::invalid_argument("Passenger name cannot be empty");


    Passenger ps = passengerService->find_or_create_passenger(trimmedName);
    return ticketService->bookTicket(trainId, ps.getId());

}

void RMSFacade::cancelTicket(int ticketId)
{
    // input validation

    if (ticketId <= 0)
        throw std::invalid_argument("Ticket ID must be greater than 0");

    ticketService->cancelTicket(ticketId);


}

bool RMSFacade::getTrainAvailability(int trainId)
{
    return  trainService->isAvailbleSeat(trainId);

}

Train RMSFacade::updateTrain(int trainId, const std::string& name, int seats) {
    // validation
    if (trainId <= 0) throw std::invalid_argument("Train ID must be > 0");
    std::string trimmedName = trim(name);
    if (!isValidName(trimmedName)) throw std::invalid_argument("Train name cannot be empty");
    if (seats < 0) throw std::invalid_argument("Seats cannot be negative");

    // current Train
    auto currentTrain = trainService->getTrain(trainId);

    int currentSeats = currentTrain.getTotalSeats();

    // update train
    Train updatedTrain = trainService->updateTrain(trainId, trimmedName, seats);

    // process waiting
    int seatsAdded = seats - currentSeats;
    if (seatsAdded > 0) {
        auto cb =[this,&updatedTrain ,trainId](int passengerId){ // access to this object& trainId + passengerId as argument
            trainService->save(updatedTrain);
            ticketService->bookTicket(trainId, passengerId);
        };
        updatedTrain.getSeatAllocator()->processWaitingList(seatsAdded,cb);

        // Save updated train after processing waiting list
        trainService->save(updatedTrain);
    }

    return updatedTrain;
}

Train RMSFacade::addSeats(int trainId, int seats)
{
    return trainService->addSeats(trainId, seats);
}

Train RMSFacade::addSeats(const std::string &name, int seats)
{
    return trainService->addSeats(name, seats);
}

Passenger RMSFacade::updatePassenger(int passengerId, const std::string &name)
{

    auto passenger = passengerService->getPassenger(passengerId);
    // update passenger
    auto newPassenger = passengerService->updatePassenger(passengerId, name);
    // update tickets with this id
    auto tickets = ticketService->getAllTickets();
    for (auto &t : tickets)
    {
        if (compareString(t.getPassenger().getName(), passenger.getName()))
        {
            t.setPassenger(newPassenger);
            ticketService->updateTicket(t);
        }
    }

    return newPassenger;
}

void RMSFacade::deleteTrain(int trainId)
{
    if (trainId <= 0) throw std::invalid_argument("Train ID must be > 0");
    trainService->deleteTrain(trainId);
}

void RMSFacade::deletePassenger(int passengerId)
{
    if (passengerId <= 0) throw std::invalid_argument("Passenger ID must be > 0");
    passengerService->deletePassenger(passengerId);
}

void RMSFacade::trainStatus(int trainId) {
    trainService->printStatus(trainId);
}


==================================================
FILE PATH: .\src\StartupManager.cpp
==================================================

//
// Created by Omar on 11/25/2025.
//
#include "StartupManager.h"
#include "Repo/InMemoryTrainRepository.h"
#include "Repo/InMemoryTicketRepository.h"
#include "Repo/InMemoryPassengerRepository.h"
void loadMockData(RMSFacade* facade) {
    // ---- Add Trains ----
    facade->addTrain("Alex NightLine", 30);
    facade->addTrain("Luxor Premium", 40);
    facade->addTrain("Cairo Express", 25);
    facade->addTrain("Aswan Sleeper", 20);
    facade->addTrain("Mediterranean Star", 35);

    // ---- Add Passengers ----
    facade->addPassenger("Omar");
    facade->addPassenger("Sara");
    facade->addPassenger("Mohamed");
    facade->addPassenger("Nour");
    facade->addPassenger("Ali");
    facade->addPassenger("Mona");
    facade->addPassenger("Youssef");
    facade->addPassenger("Laila");
    facade->addPassenger("Karim");
    facade->addPassenger("Dina");

    // ---- Book Tickets ----
    facade->bookTicket(1, "Omar");
    facade->bookTicket(1, "Sara");
    facade->bookTicket(1, "Ali");
    facade->bookTicket(2, "Mohamed");
    facade->bookTicket(2, "Nour");
    facade->bookTicket(3, "Mona");
    facade->bookTicket(3, "Youssef");
    facade->bookTicket(4, "Karim");
    facade->bookTicket(4, "Laila");
    facade->bookTicket(5, "Dina");
    facade->bookTicket(5, "Omar");
}

RMSFacade *StartupManager::buildFacade() {
    // all services and repos only deleted when startup manger deleted (unique)

    // build repos
    // liskov principle
    this->trainRepository= std::make_unique<InMemoryTrainRepository>();
    this->ticketRepository= std::make_unique<InMemoryTicketRepository>();
    this->passengerRepository= std::make_unique<InMemoryPassengerRepository>();

    // build services
    //dependancy injection  + giving access (only not the ownership) to the services
    this->trainService = std::make_unique<TrainService>(trainRepository.get());
    this->passengerService = std::make_unique<PassengerService>(passengerRepository.get());
    this->ticketService = std::make_unique<TicketService>(ticketRepository.get(),trainService.get(),passengerService.get());

    // build facade + dependancy injection
    // give facade access to the services
    this->facade = std::make_unique<RMSFacade>(trainService.get(),ticketService.get(),passengerService.get());
    loadMockData(facade.get());

    // allow acces to facade
    return facade.get();
}


==================================================
FILE PATH: .\src\models\Passenger.cpp
==================================================

//
// Created by Omar on 11/19/2025.
//
#include <stdexcept>
#include "models/Passenger.h"
#include "utils/helpers.h"

#include <iostream>
using std::cout;
using std::endl;




Passenger::Passenger(const int id, const std::string &name) {
    if(!isValidName(name)) throw std::invalid_argument("Invalid input name");
    if(id <0) throw std::invalid_argument("Invalid id");
    this->id = id;
    this->name = trim(name);
}

int Passenger::getId() const {
    return this->id;
}

std::string Passenger::getName() const {
    return this->name;
}

void Passenger::setId(const int &passengerId) {
    if(passengerId <=0) throw std::invalid_argument("Invalid id");
    this->id = passengerId;
}

void Passenger::setName(const std::string& name) {
    if(!isValidName(name)) throw std::invalid_argument("Invalid input name");
    this->name = trim(name);
}

void Passenger::print(const std::string &msg) const {
    cout << "--------------------------------------------------\n";
    cout << msg << endl;
    cout << "Passenger ID   : " << id << "\n";
    cout << "Name   : " << name << "\n";
    cout << "--------------------------------------------------\n";
}





==================================================
FILE PATH: .\src\models\SeatAllocator.cpp
==================================================

//
// Created by Omar on 11/20/2025.
//

#include "models/SeatAllocator.h"
#include <iostream>
#include <functional>

SeatAllocator::SeatAllocator(int totalSeats)
{
    if (totalSeats <= 0)
        this->totalSeats = 10;
    else
        this->totalSeats = totalSeats;
    //    add the seats to the set
    for (int seat = 1; seat <= this->totalSeats; seat++)
        availableSeats.insert(seat);
}

int SeatAllocator::allocateSeat(int passengerId)
{
    // prevent duplicate passenger allocation
    for (const auto &p : allocatedSeats)
    {
        if (p.second == passengerId)
            throw std::runtime_error("Passenger " + std::to_string(passengerId) + " already has a seat.\n");
    }

    // prevent duplicate waiting list insertion
    if (waitingSet.count(passengerId))
        throw std::runtime_error("Passenger " + std::to_string(passengerId) + " already in waiting list.\n");

    // No available seats , push to waiting list
    if (!hasAvailableSeats())
    {
        waitingList.push(passengerId);
        waitingSet.insert(passengerId);
        std::cout << "Train full, passenger added to waiting list.\n";
        return -1;
    }

    int seatNumber;

    // prefer reusing cancelled seats first
    if (!cancelledSeats.empty())
    {
        seatNumber = cancelledSeats.top();
        cancelledSeats.pop();
    }
    else
    {
        // smallest seat in the set
        seatNumber = *availableSeats.begin();
        availableSeats.erase(availableSeats.begin());
        std::cout << "seat : " << seatNumber;
    }

    allocatedSeats[seatNumber] = passengerId;
    return seatNumber;
}

int SeatAllocator::freeSeat(int seatNumber)
{
    if (seatNumber <= 0 || seatNumber > totalSeats)
        throw std::invalid_argument("Invalid seat number.\n");

    auto it = allocatedSeats.find(seatNumber);
    if (it == allocatedSeats.end())
        throw std::out_of_range("Invalid seat number.\n");

    // delete from the hash map and add to the stack
    allocatedSeats.erase(seatNumber);
    cancelledSeats.push(seatNumber);

    // assign to waiting passenger if any
    if (!waitingList.empty())
    {
        int firstPassenger = waitingList.front();
        waitingList.pop();
        waitingSet.erase(firstPassenger);
        std::cout << "\n";
        std::cout << "Seat " << seatNumber
                  << " freed and assigned to waiting passenger "
                  << firstPassenger << "\n";

        return firstPassenger;
    }

    return 0; // no waiting passengers
}

void SeatAllocator::addSeats(int seats)
{
    if (seats <= 0)
        throw std::invalid_argument("Seats must be greater than zero.\n");

    int oldTotal = totalSeats;
    totalSeats += seats;

    for (int i = oldTotal + 1; i <= totalSeats; i++)
        availableSeats.insert(i);
}

void SeatAllocator::changeTotalSeats(int newTotalSeats)
{
    if (newTotalSeats < getAllocatedSeatCount())
        throw std::out_of_range("Cannot shrink below allocated count.\n");

    if (newTotalSeats > totalSeats)
    {
        // expand
        for (int i = totalSeats + 1; i <= newTotalSeats; i++)
            availableSeats.insert(i);
    }
    else
    {
        // shrink
        int seatsToRemove = totalSeats - newTotalSeats;

        if (availableSeats.size() < seatsToRemove)
            throw std::runtime_error("Cannot shrink: not enough free seats.\n");

        while (seatsToRemove-- > 0)
        {
            auto it = std::prev(availableSeats.end());
            availableSeats.erase(it);
        }
    }

    totalSeats = newTotalSeats;
}

void SeatAllocator::printStatus() const
{
    std::cout << "\n========== Seat Allocation Status ==========\n";

    std::cout << "Total Seats          : " << totalSeats << "\n";
    std::cout << "Allocated Seat Count : " << getAllocatedSeatCount() << "\n";
    std::cout << "Available Seat Count : " << getAvailableSeatCount() << "\n\n";

    // ---- Allocated Seats ----
    std::cout << "--- Allocated Seats (Seat -> Passenger ID) ---\n";
    if (allocatedSeats.empty())
    {
        std::cout << "No seats allocated.\n";
    }
    else
    {
        for (const auto &p : allocatedSeats)
        {
            if (p.second != -1)
                std::cout << "Seat " << p.first << " -> Passenger " << p.second << "\n";
        }
    }
    std::cout << "\n";

    // ---- Available Seats ----
    std::cout << "--- Available Seats ---\n";
    if (availableSeats.empty())
    {
        std::cout << "No free seats.\n";
    }
    else
    {
        for (int s : availableSeats)
            std::cout << s << " ";
        std::cout << "\n";
    }
    std::cout << "\n";

    // ---- Cancelled Seats Stack ----
    std::cout << "--- Cancelled Seats Stack (top to bottom) ---\n";
    if (cancelledSeats.empty())
    {
        std::cout << "Empty\n";
    }
    else
    {
        stack<int> temp = cancelledSeats;
        while (!temp.empty())
        {
            std::cout << temp.top() << " ";
            temp.pop();
        }
        std::cout << "\n";
    }
    std::cout << "\n";

    // ---- Waiting List ----
    std::cout << "--- Waiting List (front -> back) ---\n";
    if (waitingList.empty())
    {
        std::cout << "No passengers in waiting list.\n";
    }
    else
    {
        std::queue<int> temp = waitingList;
        while (!temp.empty())
        {
            std::cout << temp.front() << " ";
            temp.pop();
        }
        std::cout << "\n";
    }

    std::cout << "=============================================\n\n";
}

bool SeatAllocator::hasAvailableSeats() const
{
    // if the is seat in cancelled tickets or minHeap
    //   return avaiable(true) if availableSeats or cancelledSeats is not  empty
    return !availableSeats.empty() || !cancelledSeats.empty();
}
int SeatAllocator::getAvailableSeatCount() const
{
    //    return the numbers of seats in the heap and the cancelled seats
    return availableSeats.size() + cancelledSeats.size();
}
std::unique_ptr<SeatAllocator> SeatAllocator::clone() const
{
    return std::make_unique<SeatAllocator>(*this);
}

SeatAllocator::SeatAllocator(const SeatAllocator &other)
    : availableSeats(other.availableSeats),
      waitingList(other.waitingList),
      allocatedSeats(other.allocatedSeats),
      cancelledSeats(other.cancelledSeats),
      waitingSet(other.waitingSet),
      totalSeats(other.totalSeats) {}

SeatAllocator &SeatAllocator::operator=(const SeatAllocator &other)
{
    if (this != &other)
    {
        availableSeats = other.availableSeats;
        waitingList = other.waitingList;
        allocatedSeats = other.allocatedSeats;
        cancelledSeats = other.cancelledSeats;
        waitingSet = other.waitingSet;
        totalSeats = other.totalSeats;
    }
    return *this;
}

int SeatAllocator::getAllocatedSeatCount() const
{
    return allocatedSeats.size();
}

std::queue<int> SeatAllocator::getWaitingList() const
{
    return waitingList;
}

int SeatAllocator::getTotalSeats() const
{
    return totalSeats;
}

int SeatAllocator::getWaitingListSize() const
{
    return waitingList.size();
}

int SeatAllocator::processWaitingList(int seatsToAdd, std::function<void(int)> bookCallback)
{
    int processed = 0;

    std::queue<int> newWaitingList;
    std::set<int> newWaitingset;

    while (!waitingList.empty())
    {
        int passengerId = waitingList.front();
        waitingList.pop();
        waitingSet.erase(passengerId); // remove from set

        if (seatsToAdd > 0)
        {
            try
            {
                bookCallback(passengerId);
                seatsToAdd--;
                processed++;
                continue;                      // do NOT add to new list
            }
            catch (const std::exception &e)
            {
                std::cout << "Failed to book ticket for waiting passenger "
                          << passengerId << ": " << e.what() << "\n";
                // Booking failed , keep in waiting list
            }
        }

        // Either no seats left OR booking failed ,so  keep them
        newWaitingList.push(passengerId);
        newWaitingset.insert(passengerId);
    }

    waitingList = std::move(newWaitingList); //  update the existing waiting list
    waitingSet = std::move(newWaitingset); //  update the existing waiting set

    return processed;
}


==================================================
FILE PATH: .\src\models\Ticket.cpp
==================================================

#include <stdexcept>
#include <iostream>
#include <utility>
#include "models/Ticket.h"
using std::cout;
using std::endl;

Ticket::Ticket(const int id, const int seat, const int trainId, Passenger  p)
        :passenger(std::move(p)), status(booked){
    if(id <0 || trainId <= 0 ) throw std::invalid_argument("Invalid id");
    if(seat<=0) throw std::invalid_argument("Invalid seat");
    this->id = id;
    this->ticketSeat = seat;
    this->trainId = trainId;
}
int Ticket::getId() const
{
    return id;
}

int Ticket::getSeat() const
{
    return this->ticketSeat;
}

Status Ticket::getStatus() const
{
    return status;
}

void Ticket::setStatus(const Status& s)
{
    this->status = s;
}

int Ticket::getTrainId() const
{
    return trainId;
}

Passenger Ticket::getPassenger() const
{
    return passenger;
}

void Ticket::setId(const int newId)
{
    if(newId <=0 )throw std::invalid_argument("Invalid id");
    this->id = newId;
}

void Ticket::print(const std::string &msg) const {
    cout << "--------------------------------------------------\n";
    cout << msg << endl;
    cout << "Ticket ID: " << id << "\n";
    cout << "Seat: " << ticketSeat<< "\n";
    cout << "Train ID: " << trainId << "\n";
    cout << "Passenger: " << passenger.getName() << "\n";
    cout << "Status : " << ((status == Status::booked) ? "Booked" : "Cancelled") << "\n";
    cout << "--------------------------------------------------\n";
}

void Ticket::setPassenger(const Passenger &p) {
    this->passenger =p ;

}



==================================================
FILE PATH: .\src\models\Train.cpp
==================================================

#include "models/Train.h"
#include "utils/helpers.h"

#include <iostream>
using std::cout;
using std::endl;

Train::Train(const int id, const std::string& name, const int totalSeats ){
    if(id < 0 ) throw std::invalid_argument("Invalid  negative id");
    if(!isValidName(name)) throw std::invalid_argument("Invalid input name");
    if(totalSeats < 0) throw std::invalid_argument("total seat must be greater than 0");
    this->id = id;
    this->name = trim(name);
    this->totalSeats = totalSeats;
    this->seatAllocator = std::make_unique<SeatAllocator>(totalSeats);

}

int Train::getTrainId() const {
    return id;
}

std::string Train::getTrainName() const {
    return name;
}

void Train::setTrainName(const std::string& name) {
    if(!isValidName(name) )
        throw std::invalid_argument("Invalid input name");
    this->name = trim(name);
}

void Train::setTrainId(int trainId) {
    if(trainId <= 0 ) throw std::runtime_error("Invalid id");
    this->id = trainId;
}

SeatAllocator* Train::getSeatAllocator() const {
    return seatAllocator.get();
}

bool Train::hasAvailableSeats() const {
    return seatAllocator->hasAvailableSeats();
}

int Train::getTotalSeats() const {
    return totalSeats;
}

std::unique_ptr<Train> Train::clone() const {

        auto newTrain = std::make_unique<Train>(id, name, totalSeats);
        if (seatAllocator) {
            newTrain->seatAllocator = seatAllocator->clone();
        }
        return newTrain;

}

Train::Train(const Train &other)
        : id(other.id), name(other.name), totalSeats(other.totalSeats),
          seatAllocator(other.seatAllocator ? other.seatAllocator->clone() : nullptr) {}

Train &Train::operator=(const Train &other) {

        if (this != &other) {
            id = other.id;
            name = other.name;
            totalSeats = other.totalSeats;
            seatAllocator = other.seatAllocator ? other.seatAllocator->clone() : nullptr;
        }
        return *this;

}

void Train::addSeats(int seats) {
    if(seats <= 0 )
        throw std::invalid_argument("Seats must be greater than zero");
    seatAllocator->addSeats(seats);

    this->totalSeats = seatAllocator->getTotalSeats();
}

void Train::setSeats(int seats) {
    if(seats <= 0)
        throw std::invalid_argument("Seats must be greater than zero");
    seatAllocator->changeTotalSeats(seats);

    totalSeats =seatAllocator->getTotalSeats();
}

void Train::trainStatus()const {
    if (!seatAllocator) {
        cout << "Train " << name << " has no seat allocator initialized.\n";
        return;
    }

    int waitingSize = seatAllocator->getWaitingListSize();
    cout << "\n=========== Train Status ===========\n";
    cout << "Train ID      : " << id << "\n";
    cout << "Train Name    : " << name << "\n";
    cout << "Total Seats   : " << totalSeats << "\n";
    cout << "Waiting List  : " << waitingSize << "\n";
    cout << "====================================\n\n";

    seatAllocator->printStatus();

}

void Train::print(const std::string& msg) const{
    cout << "--------------------------------------------------\n";
    cout << msg << endl;
    cout << "Train ID   : " << id<< "\n";
    cout << "Name   : " << name << "\n";
    cout << "Seats  : " << totalSeats << "\n";
    cout << "Availability: " << (hasAvailableSeats() ? "Available" : "full") << "\n";
    cout << "--------------------------------------------------\n";
}



==================================================
FILE PATH: .\src\Repo\InMemoryPassengerRepository.cpp
==================================================

//
// Created by Omar on 11/24/2025.
//


#include <iostream>
#include <optional>
#include "Repo/InMemoryPassengerRepository.h"

std::optional<Passenger> InMemoryPassengerRepository::getPassenger(const int &passengerId) {
    auto  result = passengers.find(passengerId);
    if(result != passengers.end()){
        return result->second;
    }
    return std::nullopt; // not found
}

vector<Passenger> InMemoryPassengerRepository::getAllPassengers() {
    vector<Passenger> results ;
    for(const auto & ps : passengers){
        results.push_back(ps.second);
    }
    return results;
}

void InMemoryPassengerRepository::save(Passenger &passenger) {
    if(passenger.getId() == 0 ){
        passenger.setId(next_id++);
    }else if(passenger.getId() >= next_id){
        next_id =passenger.getId() + 1;
    }
    const int id =passenger.getId();
    auto res = passengers.emplace(id,passenger);

    // If the key is found it's already updated
    // if(!res.second){ //update
    //     res.first->second = passenger;
    // }


}

bool InMemoryPassengerRepository::deletePassenger(const int &passengerId) {
    auto it = passengers.find(passengerId);
    if (it != passengers.end()) {
        passengers.erase(it);
        return true;
    }
    return false;
}

void InMemoryPassengerRepository::clear() {
    passengers.clear();
    next_id= 1;
    std::cout << "All passengers destroyed\n";
}



==================================================
FILE PATH: .\src\Repo\InMemoryTicketRepository.cpp
==================================================

#include "Repo/InMemoryTicketRepository.h"
#include <stdexcept>
#include <iostream>

std::optional<Ticket> InMemoryTicketRepository::getTicketByTrainAndPassenger(int trainId, int passengerId)
{
    for (const auto &p : tickets)
    {
        const Ticket &t = p.second;
        if (t.getTrainId() == trainId && t.getPassenger().getId() == passengerId)
        {
            return t;
        }
    }
    return std::nullopt;//not found
}

bool InMemoryTicketRepository::deleteTicket(int ticketId)
{
    auto it = tickets.find(ticketId);
    if (it != tickets.end())
    {
        tickets.erase(it);
        return true;
    }
    return false;
}

void InMemoryTicketRepository::save( Ticket& ticket)
{
    // later
    if (ticket.getId() == 0)
    {
        ticket.setId(next_id++);
    }
    else if (ticket.getId() >= next_id)
    {
        next_id = ticket.getId() + 1;
    }

    int id = ticket.getId();
    auto result = tickets.emplace(id, ticket);
    if (!result.second)
    {
        result.first->second = ticket; // update existing
    }

}

vector<Ticket> InMemoryTicketRepository::getAllTickets()
{
    vector<Ticket> results;
    for (const auto &p : tickets)
    {
        results.push_back(p.second);
    }
    return results;
}

std::optional<Ticket> InMemoryTicketRepository::getTicketById(int ticketId)
{
    auto it = tickets.find(ticketId);
    if (it != tickets.end())
    {
        return it->second;
    }
    throw std::runtime_error("Ticket not found");
}

void InMemoryTicketRepository::clear()
{
    tickets.clear();
    next_id= 1;
    std::cout << "All tickets destroyed\n";

}


==================================================
FILE PATH: .\src\Repo\InMemoryTrainRepository.cpp
==================================================

#include "Repo/InMemoryTrainRepository.h"
#include <iostream>
#include <stdexcept>

vector<Train> InMemoryTrainRepository::getAllTrains() const {
    vector<Train> result;
    for (const auto& train : trains) {
        result.push_back(train.second);
    }
    return result;
}

void InMemoryTrainRepository::save(Train & newTrain) {
    // assign id if needed
    if (newTrain.getTrainId() == 0) {
        newTrain.setTrainId(next_id++);
    }else if(newTrain.getTrainId() >= next_id){
        next_id = newTrain.getTrainId() + 1;
    }

    int trainId = newTrain.getTrainId();

    auto result = trains.emplace(trainId, newTrain);

    // If trainId already existed, update it
    if (!result.second) {
        result.first->second = newTrain;
    }

}

bool InMemoryTrainRepository::deleteTrain(int trainId) {
    auto it = trains.find(trainId);
    if (it != trains.end()) {
        trains.erase(it);
        return true;
    }
    return false;
}

std::optional<Train>   InMemoryTrainRepository::getTrainById(const int& trainId) const {
    auto it = trains.find(trainId);
    if (it != trains.end()) {
        return it->second;
    }
    return std::nullopt; // not found
}

void InMemoryTrainRepository::clear() {
    trains.clear();
    next_id= 1;
    std::cout << "All trains destroyed\n";
}


==================================================
FILE PATH: .\src\Services\PassengerService.cpp
==================================================

//
// Created by Omar on 11/24/2025.
//
#include <stdexcept>
#include "Services/PassengerService.h"
#include "utils/helpers.h"
PassengerService::PassengerService(IPassengerRepository *repo) {
    this->passengerRepository =repo;
}

Passenger PassengerService::getPassenger(const int &passengerId) {
    auto p = passengerRepository->getPassenger(passengerId);
    if(!p.has_value())
        throw std::out_of_range("Passenger with id " + std::to_string(passengerId) + " does not exist");

    return  p.value();
}

vector<Passenger> PassengerService::getAllPassengers() {
    return passengerRepository->getAllPassengers();
}

void PassengerService::deletePassenger(const int &passengerId) {
    bool deleted = passengerRepository->deletePassenger(passengerId);
    if (!deleted)
        throw std::out_of_range("failed to delete passenger with id : " + std::to_string(passengerId));
}

Passenger PassengerService::createPassenger(const std::string& name) {
    Passenger p(0,trim(name));
    passengerRepository->save(p);
    return p;
}
Passenger PassengerService::updatePassenger(const int passengerId , const std::string& name) {
    auto passenger = this->getPassenger(passengerId);
    passenger.setName(name); //update name
    passengerRepository->save(passenger);
    return passenger;
}

Passenger PassengerService::find_or_create_passenger(const std::string &name) {
    const vector<Passenger> passengers = passengerRepository->getAllPassengers();
    // search if it is existed
    for(const auto & p : passengers)
        if(toLowerCase(p.getName()) == toLowerCase(name))
            return   p;
    //else  create passenger
    Passenger p(0,name);
    passengerRepository->save(p);
    return p;
}



==================================================
FILE PATH: .\src\Services\TicketService.cpp
==================================================

#include "Services/TicketService.h"
#include <stdexcept> //for run time exception
#include <iostream>

TicketService::TicketService(ITicketRepository *repo, TrainService *ts, PassengerService *ps):ticketRepository(repo),trainService(ts),passengerService(ps) {

}


Ticket TicketService::getTicket(const int& ticketId)
{
    auto t =ticketRepository->getTicketById(ticketId);
    if(!t.has_value())
        throw std::out_of_range("ticket with id : " +  std::to_string(ticketId) + " does not exit");

    return t.value();
}

vector<Ticket> TicketService::getAllTickets()
{
    return ticketRepository->getAllTickets();
}



std::optional<Ticket> TicketService::bookTicket(const int& trainId, const int& passengerId)
{

    // 1) get train by id if exist
    auto train = trainService->getTrain(trainId);


    // 2) get passenger by id if exist
    auto  passenger = passengerService->getPassenger(passengerId);

    // 3) check if passenger has already ticket for this train
    auto  existTicket = ticketRepository->getTicketByTrainAndPassenger(trainId,passengerId);
    if(existTicket.has_value()){//  found
        throw std::runtime_error("cannot allocate more than one ticket for the same passenger in the same train\n");
    }

    // 4) assign seat to passenger if avialble
    int seat_number=train.getSeatAllocator()->allocateSeat(passengerId);
    trainService->save(train);
    if(seat_number == -1) // added to waiting list
        return std::nullopt;
    // 5)  create ticket if available
    Ticket t(0,seat_number,trainId , passenger);
    ticketRepository->save(t);
    return t;
}

void TicketService::cancelTicket(const int& ticketId)
{

    // get ticket
    auto ticket =this->getTicket(ticketId);


    // return error if it is already cancelled
    if(ticket.getStatus() == cancelled){
        throw std::runtime_error("ticket with id : " +  std::to_string(ticketId) + " is already cancelled");
    }

    //find train
    auto train = trainService->getTrain(ticket.getTrainId());
    if(train.getSeatAllocator() == nullptr){
        throw std::runtime_error("train  not has seat allocator");
    }

    // pass seat to waiting list
    auto waitingPassengerId  = train.getSeatAllocator()->freeSeat(ticket.getSeat());
    if(waitingPassengerId  == -1)
        throw std::runtime_error("fail to free the seat \n");
    trainService->save(train);
    // book seat to another passenger from waiting list if available
    if (waitingPassengerId > 0)   // >0 means there was a waiting passenger
        try {
            auto t = bookTicket(train.getTrainId(), waitingPassengerId);
            if(t.has_value())
                t->print("======Ticket booked to passenger " + std::to_string(waitingPassengerId) + " Successfully ========== \n" );
        } catch (const std::exception &e) {
            // Log error and continue with cancellation
            std::cerr << "Failed to book ticket for waiting passenger "
                      << waitingPassengerId << ": " << e.what() << "\n";
        }


    // cancel ticket
    ticket.setStatus(cancelled);
    ticketRepository->save(ticket);
}

Ticket TicketService::updateTicket(Ticket &t) {
    ticketRepository->save(t);
    return t;

}



==================================================
FILE PATH: .\src\Services\TrainService.cpp
==================================================

//
// Created by Omar on 11/21/2025.
//

#include "Services/TrainService.h"
#include "utils/helpers.h"
#include <stdexcept> //for run time exception

Train TrainService::getTrain(const int& trainId) {
    auto t =  trainRepository->getTrainById(trainId);
    if(!t.has_value())
        throw std::out_of_range("train with id : " +  std::to_string(trainId) + " does not exit");
    return t.value();

}

TrainService::TrainService(ITrainRepository *repo) {
    this->trainRepository = repo;
}

TrainService::~TrainService() {
    // do not delete repo because service is not owning the  repo it just use it
}

vector<Train> TrainService::getAllTrains() {
    return trainRepository->getAllTrains();
}

Train TrainService::createTrain(const std::string& name,int seats) {
    Train t(0,name ,seats);
    trainRepository->save(t); // save the train  and give id by the repo
    return t;
}

void TrainService::deleteTrain(int trainId) {
    bool deleted = trainRepository->deleteTrain(trainId);
    if (!deleted)
        throw std::out_of_range("failed to delete train with id : " + std::to_string(trainId));
}

bool TrainService::isAvailbleSeat(int trainId) {
    auto train = this->getTrain(trainId);
    return train.hasAvailableSeats() ;
}

void TrainService::save(Train &train) {
    trainRepository->save(train);
}

Train TrainService::updateTrain(const int &trainId, const std::string &name, int seats) {
    auto train = this->getTrain(trainId);

    // update name
    if(!name.empty())
        train.setTrainName(name);
    // update seats
    if(seats != 0)
        train.setSeats(seats);

    auto& updated =train;
    trainRepository->save(updated);
    return updated;
}

Train TrainService::addSeats(const int trainId, const int seats) {
    auto train =this->getTrain(trainId);;

    train.addSeats(seats);
    trainRepository->save(train);

    return train;
}

Train TrainService::addSeats(const std::string name, const int seats) {
    if(name.empty())
        throw std::runtime_error("invalid name (empty string)");

    auto trains = trainRepository->getAllTrains();
    if(trains.empty())
        throw std::runtime_error("train with name : " + name +" does not exit");
    for(auto &train : trains){ // search train
        // if match update
        if(compareString(train.getTrainName() ,name))
            return  addSeats(train.getTrainId(),seats);
    }
    throw std::runtime_error("train with name : " + name +" does not exit");

}

void TrainService::printStatus(int trainId) {
    auto train = this->getTrain(trainId);

    train.trainStatus();
}


==================================================
FILE PATH: .\src\utils\helpers.cpp
==================================================



#include "utils/helpers.h"
#include <cctype> // for toLower
#include <stdexcept>
#include <regex>
#include <iostream>
#include <chrono>
#include <iomanip>

using std::cout;
using std::endl;
using std::string;

std::string toLowerCase(std::string word)
{
    for (char &ch : word)
    {
        ch = (char)tolower(ch);
    }
    return word;
}
// Function to trim leading and trailing whitespace
std::string trim(const std::string &str)
{
    if (str.empty())
        return "";

    auto start = 0;
    auto end = str.length() - 1;

    // find first char from the left
    while (start < str.size() && str[start] == ' ')
    {
        start++;
    }

    // all string is space
    if (start == str.size())
        return "";

    // find first char from the right
    while (end > start && str[end] == ' ')
    {
        end--;
    }

    // return actual string
    return str.substr(start, end - start + 1);
}

int parseInt(const std::string &arg, const std::string &argName)
{
    try
    {
        std::size_t pos; // have the index of non int char
        int res = stoi(arg, &pos);
        if (pos == 0 || pos != arg.size()) // to pass 12a and abc
            throw std::invalid_argument("");

        return res;
    }
    catch (std::invalid_argument &e)
    {
        throw std::invalid_argument(argName + " must be a number");
    }
    catch (std::out_of_range &e)
    {
        throw std::out_of_range(argName + " value is too large");
    }
}

bool isValidName(const std::string &name)
{

    static const std::regex pattern("^[A-Za-z0-9]+([' -][A-Za-z0-9]+)*$"); // a-z - '
    // Do NOT trim here: tests expect names with leading/trailing whitespace
    // to be considered invalid. Validation should be applied to the raw input.
    return std::regex_match(name, pattern);
}

std::string combineString(const vector<std::string> &args, int start)
{
    return combineString(args, start, args.size()); // not including the end
}

std::string combineString(const vector<std::string> &args, int start, int end)
{
    if (start < 0 || start >= args.size())
        throw std::runtime_error("Start index out of range");

    if (end == -1)
        end = args.size() - 1;

    if (end < start || end > args.size())
        throw std::runtime_error("Invalid end index");

    std::string text;
    for (int i = start; i < end; i++)
    { // inclusive
        if (!isValidName(args[i]) || isInteger(args[i]))
            throw std::runtime_error("invalid name");
        text += args[i] + " ";
    }

    if (!text.empty())
        text.pop_back(); // remove last space

    return text;
}
bool compareString(const std::string &str1, const std::string &str2)
{
    return toLowerCase(trim(str1)) == toLowerCase(trim(str2));
}
bool isInteger(const std::string &str)
{
    try
    {
        std::size_t pos; // have the index of non int char

        stoi(trim(str), &pos);
        if (pos == 0 || pos != trim(str).size()) // to pass 12a and abc
            throw std::invalid_argument("");

        return true;
    }
    catch (std::invalid_argument &e)
    {
        return false;
    }
    catch (std::out_of_range &e)
    {
        throw std::out_of_range(str + " value is too large");
    }
}

void printCurrentDate()
{
    auto now = std::chrono::system_clock::now();
    auto time = std::chrono::system_clock::to_time_t(now);

    std::cout << "Current Date & Time: "
              << std::put_time(std::localtime(&time), "%Y-%m-%d %H:%M:%S")
              << "\n";
}


==================================================
FILE PATH: .\tests\test_cliController.cpp
==================================================

#include <gtest/gtest.h>
#include "CLIController.h"
#include "RMSFacade.h"
#include "StartupManager.h"
#include <sstream>

class CLIControllerTest : public ::testing::Test {
protected:
    std::unique_ptr<StartupManager> startupManager;
    RMSFacade* facade;
    std::unique_ptr<CLIController> controller;

    void SetUp() override {
        startupManager = std::make_unique<StartupManager>();
        facade = startupManager->buildFacade();
        controller = std::make_unique<CLIController>(facade);
    }

    void TearDown() override {
        // Cleanup handled by unique_ptr
    }
};

// ===================== Tokenize Tests =====================

TEST_F(CLIControllerTest, Tokenize_SingleWord) {
    auto tokens = CLIController::tokenize("help");
    ASSERT_EQ(tokens.size(), 1);
    EXPECT_EQ(tokens[0], "help");
}

TEST_F(CLIControllerTest, Tokenize_MultipleWords) {
    auto tokens = CLIController::tokenize("train add Express 20");
    ASSERT_EQ(tokens.size(), 4);
    EXPECT_EQ(tokens[0], "train");
    EXPECT_EQ(tokens[1], "add");
    EXPECT_EQ(tokens[2], "Express");
    EXPECT_EQ(tokens[3], "20");
}

TEST_F(CLIControllerTest, Tokenize_ExtraSpaces) {
    auto tokens = CLIController::tokenize("  train   list  ");
    ASSERT_EQ(tokens.size(), 2);
    EXPECT_EQ(tokens[0], "train");
    EXPECT_EQ(tokens[1], "list");
}

TEST_F(CLIControllerTest, Tokenize_EmptyString) {
    auto tokens = CLIController::tokenize("");
    EXPECT_TRUE(tokens.empty());
}

TEST_F(CLIControllerTest, Tokenize_OnlySpaces) {
    auto tokens = CLIController::tokenize("     ");
    EXPECT_TRUE(tokens.empty());
}

TEST_F(CLIControllerTest, Tokenize_WithNumbers) {
    auto tokens = CLIController::tokenize("ticket book 1 John");
    ASSERT_EQ(tokens.size(), 4);
    EXPECT_EQ(tokens[0], "ticket");
    EXPECT_EQ(tokens[1], "book");
    EXPECT_EQ(tokens[2], "1");
    EXPECT_EQ(tokens[3], "John");
}

TEST_F(CLIControllerTest, Tokenize_CommandWithName) {
    auto tokens = CLIController::tokenize("passenger add John Doe");
    ASSERT_EQ(tokens.size(), 4);
    EXPECT_EQ(tokens[0], "passenger");
    EXPECT_EQ(tokens[1], "add");
    EXPECT_EQ(tokens[2], "John");
    EXPECT_EQ(tokens[3], "Doe");
}

// ===================== Train Command Tests =====================

TEST_F(CLIControllerTest, ListTrains_InitialState) {
    // Should list the 5 mock trains loaded by StartupManager
    std::ostringstream output;
    std::streambuf* oldCout = std::cout.rdbuf(output.rdbuf());

    controller->list_trains();

    std::cout.rdbuf(oldCout);

    std::string result = output.str();
    EXPECT_NE(result.find("Trains"), std::string::npos);
}

TEST_F(CLIControllerTest, AddTrain_ValidInput) {
    vector<std::string> args = {"train", "add", "TestTrain", "25"};

    EXPECT_NO_THROW(controller->add_train(args));

    auto trains = facade->listTrains();
    EXPECT_EQ(trains.size(), 6); // 5 mock + 1 new
}

TEST_F(CLIControllerTest, AddTrain_InsufficientArgs) {
    vector<std::string> args = {"train", "add", "TestTrain"};

    std::ostringstream output;
    std::streambuf* oldCout = std::cout.rdbuf(output.rdbuf());

    controller->add_train(args);

    std::cout.rdbuf(oldCout);

    std::string result = output.str();
    EXPECT_NE(result.find("Usage"), std::string::npos);
}

TEST_F(CLIControllerTest, AddTrain_InvalidSeats) {
    vector<std::string> args = {"train", "add", "TestTrain", "invalid"};

    std::ostringstream output;
    std::streambuf* oldCout = std::cout.rdbuf(output.rdbuf());

    controller->add_train(args);

    std::cout.rdbuf(oldCout);

    std::string result = output.str();
    EXPECT_NE(result.find("ERROR"), std::string::npos);
}

TEST_F(CLIControllerTest, AddTrain_MultiWordName) {
    vector<std::string> args = {"train", "add", "Super", "Express", "Train", "25"};

    EXPECT_NO_THROW(controller->add_train(args));

    auto trains = facade->listTrains();
    bool found = false;
    for (const auto& train : trains) {
        if (train.getTrainName() == "Super Express Train") {
            found = true;
            break;
        }
    }
    EXPECT_TRUE(found);
}

TEST_F(CLIControllerTest, DeleteTrain_ValidId) {
    auto trains = facade->listTrains();
    ASSERT_FALSE(trains.empty());

    vector<std::string> args = {
            "train", "delete", std::to_string(trains[0].getTrainId())
    };

    EXPECT_NO_THROW(controller->delete_train(args));

    auto updatedTrains = facade->listTrains();
    EXPECT_EQ(updatedTrains.size(), trains.size() - 1);
}

TEST_F(CLIControllerTest, DeleteTrain_InsufficientArgs) {
    vector<std::string> args = {"train", "delete"};

    std::ostringstream output;
    std::streambuf* oldCout = std::cout.rdbuf(output.rdbuf());

    controller->delete_train(args);

    std::cout.rdbuf(oldCout);

    std::string result = output.str();
    EXPECT_NE(result.find("Usage"), std::string::npos);
}

TEST_F(CLIControllerTest, UpdateTrain_ValidInput) {
    auto trains = facade->listTrains();
    ASSERT_FALSE(trains.empty());

    vector<std::string> args = {
            "train", "update", std::to_string(trains[0].getTrainId()),
            "UpdatedName", "30"
    };

    EXPECT_NO_THROW(controller->update_train(args));
}

TEST_F(CLIControllerTest, AddSeats_ValidInput) {
    auto trains = facade->listTrains();
    ASSERT_FALSE(trains.empty());

    vector<std::string> args = {
            "train", "seats", std::to_string(trains[0].getTrainId()), "10"
    };

    EXPECT_NO_THROW(controller->add_seats(args));
}

TEST_F(CLIControllerTest, GetTrainAvailability_Available) {
    auto trains = facade->listTrains();
    ASSERT_FALSE(trains.empty());

    vector<std::string> args = {
            "train", "availability", std::to_string(trains[0].getTrainId())
    };

    std::ostringstream output;
    std::streambuf* oldCout = std::cout.rdbuf(output.rdbuf());

    controller->get_train_availability(args);

    std::cout.rdbuf(oldCout);

    std::string result = output.str();
    EXPECT_NE(result.find("available"), std::string::npos);
}

TEST_F(CLIControllerTest, GetTrainStatus_ValidId) {
    auto trains = facade->listTrains();
    ASSERT_FALSE(trains.empty());

    vector<std::string> args = {
            "train", "status", std::to_string(trains[0].getTrainId())
    };

    EXPECT_NO_THROW(controller->get_train_status(args));
}

// ===================== Passenger Command Tests =====================

TEST_F(CLIControllerTest, ListPassengers_InitialState) {
    std::ostringstream output;
    std::streambuf* oldCout = std::cout.rdbuf(output.rdbuf());

    controller->list_passengers();

    std::cout.rdbuf(oldCout);

    std::string result = output.str();
    EXPECT_NE(result.find("Passengers"), std::string::npos);
}

TEST_F(CLIControllerTest, AddPassenger_ValidInput) {
    vector<std::string> args = {"passenger", "add", "TestPassenger"};

    EXPECT_NO_THROW(controller->add_passenger(args));

    auto passengers = facade->listPassengers();
    EXPECT_EQ(passengers.size(), 11); // 10 mock + 1 new
}

TEST_F(CLIControllerTest, AddPassenger_MultiWordName) {
    vector<std::string> args = {"passenger", "add", "John", "Doe"};

    EXPECT_NO_THROW(controller->add_passenger(args));

    auto passengers = facade->listPassengers();
    bool found = false;
    for (const auto& p : passengers) {
        if (p.getName() == "John Doe") {
            found = true;
            break;
        }
    }
    EXPECT_TRUE(found);
}

TEST_F(CLIControllerTest, AddPassenger_InsufficientArgs) {
    vector<std::string> args = {"passenger", "add"};

    std::ostringstream output;
    std::streambuf* oldCout = std::cout.rdbuf(output.rdbuf());

    controller->add_passenger(args);

    std::cout.rdbuf(oldCout);

    std::string result = output.str();
    EXPECT_NE(result.find("Usage"), std::string::npos);
}

TEST_F(CLIControllerTest, UpdatePassenger_ValidInput) {
    auto passengers = facade->listPassengers();
    ASSERT_FALSE(passengers.empty());

    vector<std::string> args = {
            "passenger", "update", std::to_string(passengers[0].getId()),
            "UpdatedName"
    };

    EXPECT_NO_THROW(controller->update_passenger(args));
}

TEST_F(CLIControllerTest, DeletePassenger_ValidId) {
    Passenger temp = facade->addPassenger("TempPassenger");

    vector<std::string> args = {
            "passenger", "delete", std::to_string(temp.getId())
    };

    EXPECT_NO_THROW(controller->delete_passenger(args));
}

// ===================== Ticket Command Tests =====================

TEST_F(CLIControllerTest, ListTickets_InitialState) {
    std::ostringstream output;
    std::streambuf* oldCout = std::cout.rdbuf(output.rdbuf());

    controller->list_tickets();

    std::cout.rdbuf(oldCout);

    std::string result = output.str();
    EXPECT_NE(result.find("Tickets"), std::string::npos);
}

TEST_F(CLIControllerTest, BookTicket_ValidInput) {
    auto trains = facade->listTrains();
    ASSERT_FALSE(trains.empty());

    vector<std::string> args = {
            "ticket", "book", std::to_string(trains[0].getTrainId()),
            "NewPassenger"
    };

    EXPECT_NO_THROW(controller->book_ticket(args));
}

TEST_F(CLIControllerTest, BookTicket_InsufficientArgs) {
    vector<std::string> args = {"ticket", "book", "1"};

    std::ostringstream output;
    std::streambuf* oldCout = std::cout.rdbuf(output.rdbuf());

    controller->book_ticket(args);

    std::cout.rdbuf(oldCout);

    std::string result = output.str();
    EXPECT_NE(result.find("Usage"), std::string::npos);
}

TEST_F(CLIControllerTest, BookTicket_InvalidTrainId) {
    vector<std::string> args = {"ticket", "book", "invalid", "John"};

    std::ostringstream output;
    std::streambuf* oldCout = std::cout.rdbuf(output.rdbuf());

    controller->book_ticket(args);

    std::cout.rdbuf(oldCout);

    std::string result = output.str();
    EXPECT_NE(result.find("ERROR"), std::string::npos);
}

TEST_F(CLIControllerTest, CancelTicket_ValidId) {
    auto tickets = facade->listTickets();
    ASSERT_FALSE(tickets.empty());

    vector<std::string> args = {
            "ticket", "cancel", std::to_string(tickets[0].getId())
    };

    EXPECT_NO_THROW(controller->cancel_ticket(args));
}

TEST_F(CLIControllerTest, CancelTicket_InsufficientArgs) {
    vector<std::string> args = {"ticket", "cancel"};

    std::ostringstream output;
    std::streambuf* oldCout = std::cout.rdbuf(output.rdbuf());

    controller->cancel_ticket(args);

    std::cout.rdbuf(oldCout);

    std::string result = output.str();
    EXPECT_NE(result.find("Usage"), std::string::npos);
}

// ===================== Helper Function Tests =====================

TEST_F(CLIControllerTest, ReadLine_ReturnsString) {
    // Simulate stdin
    std::istringstream input("test input\n");
    std::streambuf* oldCin = std::cin.rdbuf(input.rdbuf());

    std::string result = CLIController::readLine();

    std::cin.rdbuf(oldCin);

    EXPECT_EQ(result, "test input");
}

// ===================== Edge Cases =====================

TEST_F(CLIControllerTest, HandleEmptyCommand) {
    vector<std::string> args = {};

    // Commands with empty args should handle gracefully
    EXPECT_NO_THROW(controller->add_train(args));
    EXPECT_NO_THROW(controller->add_passenger(args));
    EXPECT_NO_THROW(controller->book_ticket(args));
}

TEST_F(CLIControllerTest, HandleInvalidNumbers) {
    vector<std::string> args = {"train", "add", "Test", "abc"};

    std::ostringstream output;
    std::streambuf* oldCout = std::cout.rdbuf(output.rdbuf());

    controller->add_train(args);

    std::cout.rdbuf(oldCout);

    std::string result = output.str();
    EXPECT_NE(result.find("ERROR"), std::string::npos);
}

TEST_F(CLIControllerTest, HandleNegativeNumbers) {
    vector<std::string> args = {"train", "add", "Test", "-5"};

    std::ostringstream output;
    std::streambuf* oldCout = std::cout.rdbuf(output.rdbuf());

    controller->add_train(args);

    std::cout.rdbuf(oldCout);

    std::string result = output.str();
    EXPECT_NE(result.find("ERROR"), std::string::npos);
}

// ===================== Integration Tests =====================

TEST_F(CLIControllerTest, CompleteWorkflow) {
    // Add train
    vector<std::string> trainArgs = {"train", "add", "WorkflowTrain", "10"};
    controller->add_train(trainArgs);

    // Add passenger
    vector<std::string> passengerArgs = {"passenger", "add", "WorkflowPassenger"};
    controller->add_passenger(passengerArgs);

    // Get the train ID
    auto trains = facade->listTrains();
    int trainId = -1;
    for (const auto& train : trains) {
        if (train.getTrainName() == "WorkflowTrain") {
            trainId = train.getTrainId();
            break;
        }
    }
    ASSERT_GT(trainId, 0);

    // Book ticket
    vector<std::string> ticketArgs = {
            "ticket", "book", std::to_string(trainId), "WorkflowPassenger"
    };
    controller->book_ticket(ticketArgs);

    // Verify
    auto tickets = facade->listTickets();
    bool found = false;
    for (const auto& ticket : tickets) {
        if (ticket.getTrainId() == trainId &&
            ticket.getPassenger().getName() == "WorkflowPassenger") {
            found = true;
            break;
        }
    }
    EXPECT_TRUE(found);
}

==================================================
FILE PATH: .\tests\test_facade.cpp
==================================================

#include <gtest/gtest.h>
#include "RMSFacade.h"
#include "Services/TrainService.h"
#include "Services/PassengerService.h"
#include "Services/TicketService.h"
#include "Repo/InMemoryTrainRepository.h"
#include "Repo/InMemoryPassengerRepository.h"
#include "Repo/InMemoryTicketRepository.h"

class RMSFacadeTest : public ::testing::Test {
protected:
    std::unique_ptr<InMemoryTrainRepository> trainRepo;
    std::unique_ptr<InMemoryPassengerRepository> passengerRepo;
    std::unique_ptr<InMemoryTicketRepository> ticketRepo;

    std::unique_ptr<TrainService> trainService;
    std::unique_ptr<PassengerService> passengerService;
    std::unique_ptr<TicketService> ticketService;

    std::unique_ptr<RMSFacade> facade;

    void SetUp() override {
        trainRepo = std::make_unique<InMemoryTrainRepository>();
        passengerRepo = std::make_unique<InMemoryPassengerRepository>();
        ticketRepo = std::make_unique<InMemoryTicketRepository>();

        trainService = std::make_unique<TrainService>(trainRepo.get());
        passengerService = std::make_unique<PassengerService>(passengerRepo.get());
        ticketService = std::make_unique<TicketService>(
                ticketRepo.get(),
                trainService.get(),
                passengerService.get()
        );

        facade = std::make_unique<RMSFacade>(
                trainService.get(),
                ticketService.get(),
                passengerService.get()
        );
    }

    void TearDown() override {
        trainRepo->clear();
        passengerRepo->clear();
        ticketRepo->clear();
    }
};

// ===================== Train Operations =====================

TEST_F(RMSFacadeTest, AddTrain_Success) {
    Train train = facade->addTrain("Express", 20);
    EXPECT_GT(train.getTrainId(), 0);
    EXPECT_EQ(train.getTrainName(), "Express");
    EXPECT_EQ(train.getTotalSeats(), 20);
}

TEST_F(RMSFacadeTest, AddTrain_Invalid) {
    EXPECT_THROW(facade->addTrain("", 20), std::invalid_argument);
    EXPECT_THROW(facade->addTrain("   ", 20), std::invalid_argument);
    EXPECT_THROW(facade->addTrain("Express", 0), std::invalid_argument);
    EXPECT_THROW(facade->addTrain("Express", -5), std::invalid_argument);
}

TEST_F(RMSFacadeTest, ListTrains_Multiple) {
    facade->addTrain("Express", 20);
    facade->addTrain("Local", 30);
    auto trains = facade->listTrains();
    EXPECT_EQ(trains.size(), 2);
}

TEST_F(RMSFacadeTest, GetTrain_SuccessAndNotFound) {
    Train added = facade->addTrain("Express", 20);
    auto retrieved = facade->getTrain(added.getTrainId());
    EXPECT_EQ(retrieved.getTrainName(), "Express");
    EXPECT_THROW(facade->getTrain(999), std::out_of_range);
}

TEST_F(RMSFacadeTest, UpdateTrain_SuccessAndEdgeCases) {
    Train train = facade->addTrain("Old Name", 10);
    Train updated = facade->updateTrain(train.getTrainId(), "New Name", 15);
    EXPECT_EQ(updated.getTrainName(), "New Name");
    EXPECT_EQ(updated.getTotalSeats(), 15);
    EXPECT_THROW(facade->updateTrain(0, "Test", 10), std::invalid_argument);
    EXPECT_THROW(facade->updateTrain(train.getTrainId(), "", 10), std::invalid_argument);
    EXPECT_THROW(facade->updateTrain(train.getTrainId(), "Test", -5), std::invalid_argument);
    EXPECT_THROW(facade->updateTrain(999, "Test", 10), std::out_of_range);
}

TEST_F(RMSFacadeTest, AddSeatsByIdAndName) {
    Train train = facade->addTrain("Test", 10);
    Train updatedById = facade->addSeats(train.getTrainId(), 5);
    EXPECT_EQ(updatedById.getTotalSeats(), 15);

    facade->addTrain("Test Train", 10);
    Train updatedByName = facade->addSeats("Test Train", 5);
    EXPECT_EQ(updatedByName.getTotalSeats(), 15);
}

TEST_F(RMSFacadeTest, DeleteTrain_SuccessAndNotFound) {
    Train train = facade->addTrain("Test", 10);
    EXPECT_NO_THROW(facade->deleteTrain(train.getTrainId()));
    EXPECT_THROW(facade->deleteTrain(999), std::out_of_range);
}

TEST_F(RMSFacadeTest, GetTrainAvailability) {
    Train train = facade->addTrain("Test", 1);
    EXPECT_TRUE(facade->getTrainAvailability(train.getTrainId()));
    facade->addPassenger("John");
    facade->bookTicket(train.getTrainId(), "John");
    EXPECT_FALSE(facade->getTrainAvailability(train.getTrainId()));
}

// ===================== Passenger Operations =====================

TEST_F(RMSFacadeTest, AddPassenger_SuccessAndInvalid) {
    Passenger p = facade->addPassenger("John Doe");
    EXPECT_GT(p.getId(), 0);
    EXPECT_EQ(p.getName(), "John Doe");

    EXPECT_THROW(facade->addPassenger(""), std::invalid_argument);
    EXPECT_THROW(facade->addPassenger("   "), std::invalid_argument);
}

TEST_F(RMSFacadeTest, UpdatePassenger_SuccessAndTickets) {
    Train train = facade->addTrain("Test", 10);
    Passenger p = facade->addPassenger("John");
    facade->bookTicket(train.getTrainId(), "John");
    EXPECT_THROW( facade->bookTicket(train.getTrainId(), "John"), std::runtime_error);

    Passenger updated = facade->updatePassenger(p.getId(), "John Updated");

    EXPECT_EQ(updated.getName(), "John Updated");
    auto tickets = facade->listTickets();
    for (auto& t : tickets) {
        if (t.getPassenger().getId() == p.getId())
            EXPECT_EQ(t.getPassenger().getName(), "John Updated");
    }

    EXPECT_THROW(facade->updatePassenger(999, "Test"), std::out_of_range);
}

TEST_F(RMSFacadeTest, DeletePassenger_SuccessAndNotFound) {
    Passenger p = facade->addPassenger("John");
    EXPECT_NO_THROW(facade->deletePassenger(p.getId()));
    EXPECT_THROW(facade->deletePassenger(999), std::out_of_range);
}

// ===================== Ticket Operations =====================

TEST_F(RMSFacadeTest, BookTicket_SuccessAndEdgeCases) {
    Train train = facade->addTrain("Express", 3);
    facade->addPassenger("John");

    auto ticket = facade->bookTicket(train.getTrainId(), "John");
    ASSERT_TRUE(ticket.has_value());
    EXPECT_EQ(ticket->getPassenger().getName(), "John");

    // passenger auto-created
    auto ticket2 = facade->bookTicket(train.getTrainId(), "New Passenger");
    ASSERT_TRUE(ticket2.has_value());
    EXPECT_EQ(ticket2->getPassenger().getName(), "New Passenger");

    EXPECT_THROW(facade->bookTicket(0, "John"), std::invalid_argument);
    EXPECT_THROW(facade->bookTicket(train.getTrainId(), ""), std::invalid_argument);
    auto ticket3 = facade->bookTicket(train.getTrainId(), "   Trim Test   ");
    ASSERT_TRUE(ticket3.has_value());
    EXPECT_EQ(ticket3->getPassenger().getName(), "Trim Test");
}


// ===================== Integration Tests =====================

TEST_F(RMSFacadeTest, CompleteWorkflowAndWaitingList) {
    Train train = facade->addTrain("Express", 1);
    auto t1 = facade->bookTicket(train.getTrainId(), "John");
    auto t2 = facade->bookTicket(train.getTrainId(), "Jane");
    EXPECT_FALSE(t2.has_value());

    facade->cancelTicket(t1->getId());

    auto tickets = facade->listTickets();
    int bookedCount = 0;
    for (const auto& t : tickets) if (t.getStatus() == booked) bookedCount++;
    EXPECT_EQ(bookedCount, 1);
}

TEST_F(RMSFacadeTest, UpdateTrainExpandsCapacityAndFulfillsWaitingList) {
    Train train = facade->addTrain("Test", 2);
    facade->bookTicket(train.getTrainId(), "Passenger1");
    facade->bookTicket(train.getTrainId(), "Passenger2");
    facade->bookTicket(train.getTrainId(), "Waiting1");
    facade->bookTicket(train.getTrainId(), "Waiting2");

    facade->updateTrain(train.getTrainId(), "Test", 5);

    auto tickets = facade->listTickets();
    int bookedCount = 0;
    for (const auto& t : tickets) if (t.getStatus() == booked) bookedCount++;
    EXPECT_GE(bookedCount, 4); // 2 waiting passengers booked after expansion
}


==================================================
FILE PATH: .\tests\test_helpers.cpp
==================================================

#include <gtest/gtest.h>
#include "utils/helpers.h"
#include <regex>

TEST(HelpersTest, TrimFunction) {
    EXPECT_EQ("hello", trim("hello"));
    EXPECT_EQ("hello", trim("  hello"));
    EXPECT_EQ("hello", trim("hello  "));
    EXPECT_EQ("hello", trim("  hello  "));
    EXPECT_EQ("", trim(""));
    EXPECT_EQ("", trim("   "));
    EXPECT_EQ("hello world", trim("  hello world  "));
}

TEST(HelpersTest, ToLowerCaseFunction) {
    EXPECT_EQ("hello", toLowerCase("HELLO"));
    EXPECT_EQ("hello", toLowerCase("Hello"));
    EXPECT_EQ("123", toLowerCase("123"));
    EXPECT_EQ("", toLowerCase(""));
    EXPECT_EQ("hello world", toLowerCase("HELLO WORLD"));
}

TEST(HelpersTest, ParseIntFunction) {
    EXPECT_EQ(123, parseInt("123", "ID"));
    EXPECT_EQ(-50, parseInt("-50", "Balance"));
    EXPECT_THROW(parseInt("12a", "ID"), std::invalid_argument);
    EXPECT_THROW(parseInt("abc", "ID"), std::invalid_argument);
    EXPECT_THROW(parseInt("", "ID"), std::invalid_argument);
    EXPECT_THROW(parseInt("   ", "ID"), std::invalid_argument);
    EXPECT_THROW(parseInt("12.5", "ID"), std::invalid_argument);
    EXPECT_THROW(parseInt("9999999999999999999", "ID"), std::out_of_range);
}

TEST(HelpersTest, IsValidNameFunction) {
    EXPECT_TRUE(isValidName("John"));
    EXPECT_TRUE(isValidName("Sarah Connor"));
    EXPECT_TRUE(isValidName("Jean-Luc"));
    EXPECT_TRUE(isValidName("O'Neil"));
//    EXPECT_FALSE(isValidName("John123"));
    EXPECT_FALSE(isValidName(" John"));
    EXPECT_FALSE(isValidName("John "));
    EXPECT_FALSE(isValidName(""));
    EXPECT_FALSE(isValidName("-John"));
    EXPECT_FALSE(isValidName("John--Doe"));
}

TEST(HelpersTest, CombineStringFunction) {
    const vector<std::string> args = {"cmd", "John", "Doe", "Smith"};
    const vector<std::string> invalidArgs = {"cmd", "John", "123"};

    EXPECT_EQ("John Doe Smith", combineString(args, 1));
    EXPECT_EQ("Doe Smith", combineString(args, 2));
    EXPECT_THROW(combineString(invalidArgs, 1), std::runtime_error);
    EXPECT_EQ("John Doe", combineString(args, 1, 3));
    EXPECT_THROW(combineString(args, 10, 12), std::runtime_error);
    EXPECT_THROW(combineString(args, 2, 1), std::runtime_error);
}

TEST(HelpersTest, CompareStringFunction) {
    EXPECT_TRUE(compareString("Hello", "hello"));
    EXPECT_TRUE(compareString("  JoHn  ", "john"));
    EXPECT_FALSE(compareString("Apple", "Banana"));
}

TEST(HelpersTest, IsIntegerFunction) {
    EXPECT_TRUE(isInteger("123"));
    EXPECT_TRUE(isInteger("-123"));
    EXPECT_FALSE(isInteger("12a"));
    EXPECT_FALSE(isInteger("abc"));
    EXPECT_TRUE(isInteger(" 123 "));
}

==================================================
FILE PATH: .\tests\test_models.cpp
==================================================

#include <gtest/gtest.h>
#include "models/Passenger.h"
#include "models/Train.h"
#include "models/Ticket.h"
#include "structures/vector.h"
class IntegrationTest : public ::testing::Test {
protected:
    void SetUp() override {}
    void TearDown() override {}
};

TEST_F(IntegrationTest, CompleteBookingFlow) {
    Train train(1, "Express", 5);
    Passenger passenger(101, "John Doe");

    int seatNumber = train.getSeatAllocator()->allocateSeat(passenger.getId());
    EXPECT_GT(seatNumber, 0);

    Ticket ticket(1, seatNumber, train.getTrainId(), passenger);
    EXPECT_EQ(ticket.getSeat(), seatNumber);
    EXPECT_EQ(ticket.getTrainId(), train.getTrainId());
    EXPECT_EQ(ticket.getPassenger().getId(), passenger.getId());
    EXPECT_EQ(ticket.getStatus(), booked);
}

TEST_F(IntegrationTest, MultiplePassengersBooking) {
    Train train(1, "Express", 10);
    vector<Passenger> passengers;
    vector<Ticket> tickets;

    for (int i = 1; i <= 5; i++) {
        Passenger p(100 + i, "Passenger " + std::to_string(i));
        passengers.push_back(p);
        int seat = train.getSeatAllocator()->allocateSeat(p.getId());
        EXPECT_EQ(seat, i);
        Ticket ticket(i, seat, train.getTrainId(), p);
        tickets.push_back(ticket);
    }

    EXPECT_EQ(tickets.size(), 5);
    EXPECT_EQ(train.getSeatAllocator()->getAllocatedSeatCount(), 5);
    EXPECT_TRUE(train.hasAvailableSeats());
}

TEST_F(IntegrationTest, BookingUntilFull) {
    Train train(1, "Express", 3);

    Passenger p1(101, "John");
    Passenger p2(102, "Jane");
    Passenger p3(103, "Bob");

    int seat1 = train.getSeatAllocator()->allocateSeat(p1.getId());
    int seat2 = train.getSeatAllocator()->allocateSeat(p2.getId());
    int seat3 = train.getSeatAllocator()->allocateSeat(p3.getId());

    EXPECT_EQ(seat1, 1);
    EXPECT_EQ(seat2, 2);
    EXPECT_EQ(seat3, 3);
    EXPECT_FALSE(train.hasAvailableSeats());
}

TEST_F(IntegrationTest, BookingCancellationFlow) {
    Train train(1, "Express", 5);
    Passenger passenger(101, "John Doe");

    int seatNumber = train.getSeatAllocator()->allocateSeat(passenger.getId());
    Ticket ticket(1, seatNumber, train.getTrainId(), passenger);

    ticket.setStatus(cancelled);
    int result = train.getSeatAllocator()->freeSeat(seatNumber);

    EXPECT_EQ(ticket.getStatus(), cancelled);
    EXPECT_EQ(result, 0);
    EXPECT_TRUE(train.hasAvailableSeats());
}

TEST_F(IntegrationTest, CancellationWithReallocation) {
    Train train(1, "Express", 2);

    Passenger p1(101, "John");
    Passenger p2(102, "Jane");

    int seat1 = train.getSeatAllocator()->allocateSeat(p1.getId());
    int seat2 = train.getSeatAllocator()->allocateSeat(p2.getId());

    Ticket ticket1(1, seat1, train.getTrainId(), p1);
    Ticket ticket2(2, seat2, train.getTrainId(), p2);

    ticket1.setStatus(cancelled);
    train.getSeatAllocator()->freeSeat(seat1);

    Passenger p3(103, "Bob");
    int seat3 = train.getSeatAllocator()->allocateSeat(p3.getId());
    EXPECT_EQ(seat3, seat1);
}

TEST_F(IntegrationTest, WaitingListBasicFlow) {
    Train train(1, "Express", 2);

    Passenger p1(101, "John");
    Passenger p2(102, "Jane");
    Passenger p3(103, "Bob");

    train.getSeatAllocator()->allocateSeat(p1.getId());
    train.getSeatAllocator()->allocateSeat(p2.getId());
    int seat3 = train.getSeatAllocator()->allocateSeat(p3.getId());

    EXPECT_EQ(seat3, -1);
    EXPECT_FALSE(train.getSeatAllocator()->getWaitingList().empty());
}

TEST_F(IntegrationTest, WaitingListAutoAllocation) {
    Train train(1, "Express", 2);

    Passenger p1(101, "John");
    Passenger p2(102, "Jane");
    Passenger p3(103, "Bob");

    int seat1 = train.getSeatAllocator()->allocateSeat(p1.getId());
    int seat2 = train.getSeatAllocator()->allocateSeat(p2.getId());
    train.getSeatAllocator()->allocateSeat(p3.getId());

    int newPassenger = train.getSeatAllocator()->freeSeat(seat1);
    EXPECT_EQ(newPassenger, p3.getId());
    EXPECT_TRUE(train.getSeatAllocator()->getWaitingList().empty());
}

TEST_F(IntegrationTest, AddSeatsWithActiveBookings) {
    Train train(1, "Express", 5);

    train.getSeatAllocator()->allocateSeat(101);
    train.getSeatAllocator()->allocateSeat(102);
    train.getSeatAllocator()->allocateSeat(103);

    train.addSeats(5);

    EXPECT_EQ(train.getTotalSeats(), 10);
    EXPECT_EQ(train.getSeatAllocator()->getAllocatedSeatCount(), 3);
    EXPECT_EQ(train.getSeatAllocator()->getAvailableSeatCount(), 7);
}

TEST_F(IntegrationTest, FullOperationalDay) {
    Train train(1, "Morning Express", 5);
    vector<Ticket> activeTickets;

    for (int i = 1; i <= 5; i++) {
        Passenger p(100 + i, "Passenger " + std::to_string(i));
        int seat = train.getSeatAllocator()->allocateSeat(p.getId());
        activeTickets.push_back(Ticket(i, seat, train.getTrainId(), p));
    }

    EXPECT_FALSE(train.hasAvailableSeats());

    activeTickets[0].setStatus(cancelled);
    activeTickets[2].setStatus(cancelled);
    train.getSeatAllocator()->freeSeat(activeTickets[0].getSeat());
    train.getSeatAllocator()->freeSeat(activeTickets[2].getSeat());

    EXPECT_TRUE(train.hasAvailableSeats());

    Passenger p6(106, "Late Passenger 1");
    Passenger p7(107, "Late Passenger 2");
    int seat6 = train.getSeatAllocator()->allocateSeat(p6.getId());
    int seat7 = train.getSeatAllocator()->allocateSeat(p7.getId());

    EXPECT_GT(seat6, 0);
    EXPECT_GT(seat7, 0);
    EXPECT_FALSE(train.hasAvailableSeats());
}

TEST_F(IntegrationTest, SingleSeatTrainOperations) {
    Train train(1, "Mini Train", 1);
    Passenger p1(101, "John");

    int seat = train.getSeatAllocator()->allocateSeat(p1.getId());
    EXPECT_EQ(seat, 1);
    EXPECT_FALSE(train.hasAvailableSeats());

    Passenger p2(102, "Jane");
    int seat2 = train.getSeatAllocator()->allocateSeat(p2.getId());
    EXPECT_EQ(seat2, -1);

    train.getSeatAllocator()->freeSeat(1);
    EXPECT_TRUE(train.getSeatAllocator()->getWaitingList().empty());
}

==================================================
FILE PATH: .\tests\test_passenger.cpp
==================================================

#include <gtest/gtest.h>
#include "models/Passenger.h"

class PassengerTest : public ::testing::Test {
protected:
    void SetUp() override {}
    void TearDown() override {}
};

TEST_F(PassengerTest, ValidConstruction) {
    Passenger p(1, "John Doe");
    EXPECT_EQ(p.getId(), 1);
    EXPECT_EQ(p.getName(), "John Doe");
}

TEST_F(PassengerTest, InvalidIdThrowsException) {
    EXPECT_THROW(Passenger(-1, "John Doe"), std::invalid_argument);
}

TEST_F(PassengerTest, EmptyNameThrowsException) {
    EXPECT_THROW(Passenger(1, ""), std::invalid_argument);
}

TEST_F(PassengerTest, SetValidId) {
    Passenger p(1, "John Doe");
    p.setId(2);
    EXPECT_EQ(p.getId(), 2);
}

TEST_F(PassengerTest, SetInvalidIdThrowsException) {
    Passenger p(1, "John Doe");
    EXPECT_THROW(p.setId(-1), std::invalid_argument);
}

TEST_F(PassengerTest, SetValidName) {
    Passenger p(1, "John Doe");
    p.setName("Jane Smith");
    EXPECT_EQ(p.getName(), "Jane Smith");
}

TEST_F(PassengerTest, SetEmptyNameThrowsException) {
    Passenger p(1, "John Doe");
    EXPECT_THROW(p.setName(""), std::invalid_argument);
}

==================================================
FILE PATH: .\tests\test_passengerRepoMemo.cpp
==================================================

#include <gtest/gtest.h>
#include "models/Passenger.h"
#include "Repo/InMemoryPassengerRepository.h"
#include <optional>

class InMemoryPassengerRepositoryTest : public ::testing::Test {
protected:
    InMemoryPassengerRepository repo;

    void SetUp() override {
        repo.clear();
    }

    void TearDown() override {
        repo.clear();
    }
};

TEST_F(InMemoryPassengerRepositoryTest, SavePassengerWithZeroIdGeneratesNewId) {
    Passenger p(0, "Alice");
    repo.save(p);
    EXPECT_GT(p.getId(), 0);
}

TEST_F(InMemoryPassengerRepositoryTest, SaveGeneratesSequentialIds) {
    Passenger p1(0, "Alice");
    Passenger p2(0, "Bob");
    repo.save(p1);
    repo.save(p2);
    EXPECT_EQ(1, p1.getId());
    EXPECT_EQ(2, p2.getId());
}

TEST_F(InMemoryPassengerRepositoryTest, SavePassengerWithExistingIdPreservesId) {
    Passenger p(42, "Charlie");
    repo.save(p);
    EXPECT_EQ(42, p.getId());
}

TEST_F(InMemoryPassengerRepositoryTest, SaveUpdatesExistingPassenger) {
    Passenger p(0, "David");
    repo.save(p);
    int originalId = p.getId();
    Passenger updated(originalId, "David Updated");
    repo.save(updated);
    auto retrieved = repo.getPassenger(originalId);
    ASSERT_TRUE(retrieved.has_value());
    EXPECT_EQ(originalId, retrieved->getId());
    EXPECT_EQ("David Updated", retrieved->getName());
}

TEST_F(InMemoryPassengerRepositoryTest, SaveMultipleTimesWithSameId) {
    Passenger p1(5, "Eve");
    repo.save(p1);
    Passenger p2(5, "Eve Updated");
    repo.save(p2);
    auto retrieved = repo.getPassenger(5);
    ASSERT_TRUE(retrieved.has_value());
    EXPECT_EQ("Eve Updated", retrieved->getName());
    EXPECT_EQ(1, repo.getAllPassengers().size());
}

TEST_F(InMemoryPassengerRepositoryTest, GetPassengerReturnsCorrectPassenger) {
    Passenger p(0, "Frank");
    repo.save(p);
    auto retrieved = repo.getPassenger(p.getId());
    ASSERT_TRUE(retrieved.has_value());
    EXPECT_EQ(p.getId(), retrieved->getId());
    EXPECT_EQ("Frank", retrieved->getName());
}

TEST_F(InMemoryPassengerRepositoryTest, GetPassengerReturnsNulloptWhenNotFound) {
    auto result = repo.getPassenger(999);
    EXPECT_FALSE(result.has_value());
}

TEST_F(InMemoryPassengerRepositoryTest, GetAllPassengersReturnsEmptyWhenEmpty) {
    vector<Passenger> passengers = repo.getAllPassengers();
    EXPECT_TRUE(passengers.empty());
}

TEST_F(InMemoryPassengerRepositoryTest, GetAllPassengersReturnsAllSavedPassengers) {
    Passenger p1(0, "Jack");
    Passenger p2(0, "Kate");
    Passenger p3(0, "Liam");
    repo.save(p1);
    repo.save(p2);
    repo.save(p3);
    vector<Passenger> passengers = repo.getAllPassengers();
    EXPECT_EQ(3, passengers.size());
}

TEST_F(InMemoryPassengerRepositoryTest, DeletePassengerRemovesPassenger) {
    Passenger p(0, "Olivia");
    repo.save(p);
    int id = p.getId();
    bool deleted = repo.deletePassenger(id);
    EXPECT_TRUE(deleted);
    auto result = repo.getPassenger(id);
    EXPECT_FALSE(result.has_value());
}

TEST_F(InMemoryPassengerRepositoryTest, DeletePassengerReturnsFalseWhenNotFound) {
    bool deleted = repo.deletePassenger(999);
    EXPECT_FALSE(deleted);
}

TEST_F(InMemoryPassengerRepositoryTest, DeletePassengerReducesCount) {
    Passenger p1(0, "Paul");
    Passenger p2(0, "Quinn");
    repo.save(p1);
    repo.save(p2);
    EXPECT_EQ(2, repo.getAllPassengers().size());
    repo.deletePassenger(p1.getId());
    EXPECT_EQ(1, repo.getAllPassengers().size());
}

TEST_F(InMemoryPassengerRepositoryTest, ClearRemovesAllPassengers) {
    Passenger p1(0, "Uma");
    Passenger p2(0, "Victor");
    repo.save(p1);
    repo.save(p2);
    repo.clear();
    vector<Passenger> passengers = repo.getAllPassengers();
    EXPECT_TRUE(passengers.empty());
}

TEST_F(InMemoryPassengerRepositoryTest, ClearResetsNextId) {
    Passenger p1(0, "Wendy");
    repo.save(p1);
    repo.clear();
    Passenger p2(0, "Xavier");
    repo.save(p2);
    EXPECT_EQ(1, p2.getId());
}

==================================================
FILE PATH: .\tests\test_passengerService.cpp
==================================================

#include <gtest/gtest.h>
#include "models/Passenger.h"
#include "Repo/InMemoryPassengerRepository.h"
#include "Services/PassengerService.h"
#include "utils/helpers.h"
#include <set>

class PassengerServiceTest : public ::testing::Test {
protected:
    InMemoryPassengerRepository repo;
    PassengerService* service;

    void SetUp() override {
        repo.clear();
        service = new PassengerService(&repo);
    }

    void TearDown() override {
        delete service;
        repo.clear();
    }
};

//
// CREATE PASSENGER TESTS
//

TEST_F(PassengerServiceTest, CreatePassenger_AssignsUniqueIds) {
    Passenger a = service->createPassenger("A");
    Passenger b = service->createPassenger("B");
    EXPECT_NE(a.getId(), b.getId());
}

TEST_F(PassengerServiceTest, CreatePassenger_TrimsName) {
    Passenger p = service->createPassenger("  Omar  ");
    EXPECT_EQ("Omar", p.getName());
}

TEST_F(PassengerServiceTest, CreatePassenger_EmptyNameThrows) {
    EXPECT_THROW(service->createPassenger(""), std::invalid_argument);
}

//
// GET PASSENGER TESTS
//

TEST_F(PassengerServiceTest, GetPassenger_ThrowsForNegativeId) {
    EXPECT_THROW(service->getPassenger(-1), std::out_of_range);
}

TEST_F(PassengerServiceTest, GetPassenger_ReturnsCorrectPassenger) {
    Passenger a = service->createPassenger("A");
    Passenger b = service->createPassenger("B");

    Passenger retrieved = service->getPassenger(b.getId());
    EXPECT_EQ("B", retrieved.getName());
}

TEST_F(PassengerServiceTest, GetPassenger_ThrowsForNonExistentId) {
    service->createPassenger("A");
    EXPECT_THROW(service->getPassenger(999), std::out_of_range);
}

//
// GET ALL PASSENGERS
//

TEST_F(PassengerServiceTest, GetAllPassengers_SizeCorrect) {
    service->createPassenger("A");
    service->createPassenger("B");
    service->createPassenger("C");

    auto all = service->getAllPassengers();
    EXPECT_EQ(3, all.size());
}

//
// DELETE PASSENGER
//
TEST_F(PassengerServiceTest, DeletePassenger_RemovesOnlyTarget) {
    Passenger p1 = service->createPassenger("A");
    Passenger p2 = service->createPassenger("B");

    service->deletePassenger(p1.getId());  // throws on failure

    auto all = service->getAllPassengers();
    EXPECT_EQ(1, all.size());
    EXPECT_EQ("B", all[0].getName());
}

TEST_F(PassengerServiceTest, DeletePassenger_ThrowsForNonExistent) {
    EXPECT_THROW(service->deletePassenger(999), std::out_of_range);
}

TEST_F(PassengerServiceTest, DeletePassenger_SuccessDoesNotThrow) {
    Passenger p = service->createPassenger("A");
    EXPECT_NO_THROW(service->deletePassenger(p.getId()));
}

//
// UPDATE PASSENGER
//

TEST_F(PassengerServiceTest, UpdatePassenger_Success) {
    Passenger p = service->createPassenger("Original");
    int id = p.getId();

    Passenger updated = service->updatePassenger(id, "Updated");

    EXPECT_EQ(id, updated.getId());
    EXPECT_EQ("Updated", updated.getName());
}

TEST_F(PassengerServiceTest, UpdatePassenger_ThrowsForNonExistent) {
    EXPECT_THROW(service->updatePassenger(999, "Name"), std::out_of_range);
}

//
// FIND OR CREATE PASSENGER
//

TEST_F(PassengerServiceTest, FindOrCreate_FindsExistingIgnoringCase) {
    service->createPassenger("Omar");

    Passenger found = service->find_or_create_passenger("oMaR");

    EXPECT_EQ("Omar", found.getName());
    EXPECT_EQ(1, service->getAllPassengers().size());
}

TEST_F(PassengerServiceTest, FindOrCreate_ReturnsExistingEvenIfCaseDiffers) {
    Passenger p = service->createPassenger("HELLO");

    Passenger found = service->find_or_create_passenger("hello");

    EXPECT_EQ(p.getId(), found.getId());
    EXPECT_EQ("HELLO", found.getName());
}

TEST_F(PassengerServiceTest, FindOrCreate_DoesNotMatchDifferentNames) {
    service->createPassenger("John");

    Passenger p = service->find_or_create_passenger("Johnny");

    EXPECT_EQ("Johnny", p.getName());
    EXPECT_EQ(2, service->getAllPassengers().size());
}



TEST_F(PassengerServiceTest, Create100Passengers_AllIdsUnique) {
    std::set<int> ids;

    for (int i = 0; i < 100; i++) {
        Passenger p = service->createPassenger("P" + std::to_string(i));
        ids.insert(p.getId());
    }

    EXPECT_EQ(100, ids.size());
}


==================================================
FILE PATH: .\tests\test_SeatAllocator.cpp
==================================================

#include <gtest/gtest.h>
#include "models/SeatAllocator.h"
#include "structures/vector.h"
class SeatAllocatorTest : public ::testing::Test {
protected:
    void SetUp() override {}
    void TearDown() override {}
};

TEST_F(SeatAllocatorTest, DefaultConstruction) {
    SeatAllocator allocator;
    EXPECT_EQ(allocator.getTotalSeats(), 10);
    EXPECT_EQ(allocator.getAvailableSeatCount(), 10);
    EXPECT_TRUE(allocator.hasAvailableSeats());
}

TEST_F(SeatAllocatorTest, CustomSeatCount) {
    SeatAllocator allocator(20);
    EXPECT_EQ(allocator.getTotalSeats(), 20);
    EXPECT_EQ(allocator.getAvailableSeatCount(), 20);
}

TEST_F(SeatAllocatorTest, AllocateSingleSeat) {
    SeatAllocator allocator(5);
    int seat = allocator.allocateSeat(101);
    EXPECT_EQ(seat, 1);
    EXPECT_EQ(allocator.getAvailableSeatCount(), 4);
    EXPECT_EQ(allocator.getAllocatedSeatCount(), 1);
}

TEST_F(SeatAllocatorTest, AllocateMultipleSeats) {
    SeatAllocator allocator(5);
    EXPECT_EQ(allocator.allocateSeat(101), 1);
    EXPECT_EQ(allocator.allocateSeat(102), 2);
    EXPECT_EQ(allocator.allocateSeat(103), 3);
    EXPECT_EQ(allocator.getAvailableSeatCount(), 2);
    EXPECT_EQ(allocator.getAllocatedSeatCount(), 3);
}

TEST_F(SeatAllocatorTest, DuplicatePassengerIdThrows) {
    SeatAllocator allocator(5);
    allocator.allocateSeat(101);
    EXPECT_THROW(allocator.allocateSeat(101), std::runtime_error);
}

TEST_F(SeatAllocatorTest, DuplicatePassengerInWaitingListThrows) {
    SeatAllocator allocator(2);
    allocator.allocateSeat(101);
    allocator.allocateSeat(102);
    allocator.allocateSeat(103);
    EXPECT_THROW(allocator.allocateSeat(103), std::runtime_error);
}

TEST_F(SeatAllocatorTest, FullTrainAddsToWaitingList) {
    SeatAllocator allocator(2);
    allocator.allocateSeat(101);
    allocator.allocateSeat(102);
    int result = allocator.allocateSeat(103);
    EXPECT_EQ(result, -1);
    EXPECT_FALSE(allocator.getWaitingList().empty());
    EXPECT_FALSE(allocator.hasAvailableSeats());
}

TEST_F(SeatAllocatorTest, FreeSeatValid) {
    SeatAllocator allocator(5);
    allocator.allocateSeat(101);
    EXPECT_EQ(allocator.freeSeat(1), 0);
    EXPECT_EQ(allocator.getAvailableSeatCount(), 5);
}

TEST_F(SeatAllocatorTest, FreeSeatInvalidSeatNumberZero) {
    SeatAllocator allocator(5);
    EXPECT_THROW(allocator.freeSeat(0), std::invalid_argument);
}

TEST_F(SeatAllocatorTest, FreeSeatInvalidSeatNumberNegative) {
    SeatAllocator allocator(5);
    EXPECT_THROW(allocator.freeSeat(-1), std::invalid_argument);
}

TEST_F(SeatAllocatorTest, FreeSeatInvalidSeatNumberTooLarge) {
    SeatAllocator allocator(5);
    EXPECT_THROW(allocator.freeSeat(10), std::invalid_argument);
}

TEST_F(SeatAllocatorTest, FreeSeatNotAllocated) {
    SeatAllocator allocator(5);
    EXPECT_THROW(allocator.freeSeat(1), std::out_of_range);
}

TEST_F(SeatAllocatorTest, FreeAlreadyFreedSeat) {
    SeatAllocator allocator(5);
    allocator.allocateSeat(101);
    allocator.freeSeat(1);
    EXPECT_THROW(allocator.freeSeat(1), std::out_of_range);
}

TEST_F(SeatAllocatorTest, CancelledSeatReusedBeforeNewSeats) {
    SeatAllocator allocator(5);
    allocator.allocateSeat(101);
    allocator.allocateSeat(102);
    allocator.freeSeat(1);
    int newSeat = allocator.allocateSeat(103);
    EXPECT_EQ(newSeat, 1);
}

TEST_F(SeatAllocatorTest, MultipleCancelledSeatsReusedLIFO) {
    SeatAllocator allocator(5);
    allocator.allocateSeat(101);
    allocator.allocateSeat(102);
    allocator.allocateSeat(103);
    allocator.freeSeat(1);
    allocator.freeSeat(2);
    EXPECT_EQ(allocator.allocateSeat(104), 2);
    EXPECT_EQ(allocator.allocateSeat(105), 1);
}

TEST_F(SeatAllocatorTest, AddSeats) {
    SeatAllocator allocator(5);
    allocator.addSeats(5);
    EXPECT_EQ(allocator.getTotalSeats(), 10);
    EXPECT_EQ(allocator.getAvailableSeatCount(), 10);
}

TEST_F(SeatAllocatorTest, AddSeatsWithAllocations) {
    SeatAllocator allocator(5);
    allocator.allocateSeat(101);
    allocator.allocateSeat(102);
    allocator.addSeats(3);
    EXPECT_EQ(allocator.getTotalSeats(), 8);
    EXPECT_EQ(allocator.getAvailableSeatCount(), 6);
    EXPECT_EQ(allocator.getAllocatedSeatCount(), 2);
}

TEST_F(SeatAllocatorTest, AddInvalidSeatsThrowsZero) {
    SeatAllocator allocator(5);
    EXPECT_THROW(allocator.addSeats(0), std::invalid_argument);
}

TEST_F(SeatAllocatorTest, AddInvalidSeatsThrowsNegative) {
    SeatAllocator allocator(5);
    EXPECT_THROW(allocator.addSeats(-5), std::invalid_argument);
}

TEST_F(SeatAllocatorTest, ChangeTotalSeatsToSameSize) {
    SeatAllocator allocator(10);
    allocator.changeTotalSeats(10);
    EXPECT_EQ(allocator.getTotalSeats(), 10);
}

TEST_F(SeatAllocatorTest, CopyConstructor) {
    SeatAllocator allocator(5);
    allocator.allocateSeat(101);
    allocator.allocateSeat(102);
    SeatAllocator copy(allocator);
    EXPECT_EQ(copy.getTotalSeats(), allocator.getTotalSeats());
    EXPECT_EQ(copy.getAvailableSeatCount(), allocator.getAvailableSeatCount());
    EXPECT_EQ(copy.getAllocatedSeatCount(), allocator.getAllocatedSeatCount());
}

TEST_F(SeatAllocatorTest, AssignmentOperator) {
    SeatAllocator allocator(5);
    allocator.allocateSeat(101);
    SeatAllocator other(10);
    other = allocator;
    EXPECT_EQ(other.getTotalSeats(), 5);
    EXPECT_EQ(other.getAllocatedSeatCount(), 1);
}

TEST_F(SeatAllocatorTest, CloneMethod) {
    SeatAllocator allocator(5);
    allocator.allocateSeat(101);
    auto cloned = allocator.clone();
    EXPECT_EQ(cloned->getTotalSeats(), allocator.getTotalSeats());
    EXPECT_EQ(cloned->getAvailableSeatCount(), allocator.getAvailableSeatCount());
    EXPECT_EQ(cloned->getAllocatedSeatCount(), allocator.getAllocatedSeatCount());
}

TEST_F(SeatAllocatorTest, FreeSeatReturnsWaitingPassengerId) {
    SeatAllocator allocator(1);
    allocator.allocateSeat(101);
    allocator.allocateSeat(102);
    int waitingPassengerId = allocator.freeSeat(1);
    EXPECT_EQ(waitingPassengerId, 102);
}

TEST_F(SeatAllocatorTest, ProcessWaitingList_Basic) {
    SeatAllocator allocator(2);
    allocator.allocateSeat(101);
    allocator.allocateSeat(102);
    allocator.allocateSeat(103);
    allocator.allocateSeat(104);

    vector<int> bookedPassengers;
    auto callback = [&bookedPassengers](int passengerId) {
        bookedPassengers.push_back(passengerId);
    };

    allocator.addSeats(2);
    int processed = allocator.processWaitingList(2, callback);

    EXPECT_EQ(processed, 2);
    EXPECT_EQ(bookedPassengers.size(), 2);
    EXPECT_EQ(bookedPassengers[0], 103);
    EXPECT_EQ(bookedPassengers[1], 104);
    EXPECT_EQ(allocator.getWaitingListSize(), 0);
}

TEST_F(SeatAllocatorTest, ProcessWaitingList_MoreSeatsThanWaiting) {
    SeatAllocator allocator(2);
    allocator.allocateSeat(101);
    allocator.allocateSeat(102);
    allocator.allocateSeat(103);

    vector<int> bookedPassengers;
    auto callback = [&bookedPassengers](int passengerId) {
        bookedPassengers.push_back(passengerId);
    };

    allocator.addSeats(3);
    int processed = allocator.processWaitingList(3, callback);

    EXPECT_EQ(processed, 1);
    EXPECT_EQ(bookedPassengers.size(), 1);
    EXPECT_EQ(bookedPassengers[0], 103);
    EXPECT_EQ(allocator.getWaitingListSize(), 0);
}

TEST_F(SeatAllocatorTest, ProcessWaitingList_NoWaitingList) {
    SeatAllocator allocator(5);
    allocator.allocateSeat(101);

    vector<int> bookedPassengers;
    auto callback = [&bookedPassengers](int passengerId) {
        bookedPassengers.push_back(passengerId);
    };

    allocator.addSeats(2);
    int processed = allocator.processWaitingList(2, callback);

    EXPECT_EQ(processed, 0);
    EXPECT_TRUE(bookedPassengers.empty());
}

TEST_F(SeatAllocatorTest, ProcessWaitingList_CallbackThrows) {
    SeatAllocator allocator(2);
    allocator.allocateSeat(101);
    allocator.allocateSeat(102);
    allocator.allocateSeat(103);

    auto callback = [](int passengerId) {
        throw std::runtime_error("Booking failed");
    };

    allocator.addSeats(1);
    int processed = allocator.processWaitingList(1, callback);

    EXPECT_EQ(processed, 0);
    EXPECT_EQ(allocator.getWaitingListSize(), 1);
}

==================================================
FILE PATH: .\tests\test_startUpManager.cpp
==================================================

#include <gtest/gtest.h>
#include "StartupManager.h"
#include "RMSFacade.h"

class StartupManagerTest : public ::testing::Test {
protected:
    void SetUp() override {}
    void TearDown() override {}
};

// ===================== Basic Tests =====================

TEST_F(StartupManagerTest, BuildFacade_ReturnsValidPointer) {
    StartupManager manager;
    RMSFacade* facade = manager.buildFacade();

    ASSERT_NE(facade, nullptr);
}

TEST_F(StartupManagerTest, BuildFacade_InitializesComponents) {
    StartupManager manager;
    RMSFacade* facade = manager.buildFacade();

    ASSERT_NE(facade, nullptr);

    // Test that facade can perform operations
    EXPECT_NO_THROW({
                        auto trains = facade->listTrains();
                        auto passengers = facade->listPassengers();
                        auto tickets = facade->listTickets();
                    });
}

TEST_F(StartupManagerTest, BuildFacade_LoadsMockData) {
    StartupManager manager;
    RMSFacade* facade = manager.buildFacade();

    ASSERT_NE(facade, nullptr);

    auto trains = facade->listTrains();
    auto passengers = facade->listPassengers();
    auto tickets = facade->listTickets();

    // Mock data loads 5 trains, 10 passengers, and 10+ tickets
    EXPECT_EQ(trains.size(), 5);
    EXPECT_EQ(passengers.size(), 10);
    EXPECT_GE(tickets.size(), 10);
}

// ===================== Mock Data Verification =====================

TEST_F(StartupManagerTest, MockData_TrainsExist) {
    StartupManager manager;
    RMSFacade* facade = manager.buildFacade();

    auto trains = facade->listTrains();

    vector<std::string> expectedTrains = {
            "Alex NightLine",
            "Luxor Premium",
            "Cairo Express",
            "Aswan Sleeper",
            "Mediterranean Star"
    };

    EXPECT_EQ(trains.size(), expectedTrains.size());

    for (const auto& expectedName : expectedTrains) {
        bool found = false;
        for (const auto& train : trains) {
            if (train.getTrainName() == expectedName) {
                found = true;
                break;
            }
        }
        EXPECT_TRUE(found) << "Train not found: " << expectedName;
    }
}

TEST_F(StartupManagerTest, MockData_PassengersExist) {
    StartupManager manager;
    RMSFacade* facade = manager.buildFacade();

    auto passengers = facade->listPassengers();

    vector<std::string> expectedPassengers = {
            "Omar", "Sara", "Mohamed", "Nour", "Ali",
            "Mona", "Youssef", "Laila", "Karim", "Dina"
    };

    EXPECT_EQ(passengers.size(), expectedPassengers.size());

    for (const auto& expectedName : expectedPassengers) {
        bool found = false;
        for (const auto& passenger : passengers) {
            if (passenger.getName() == expectedName) {
                found = true;
                break;
            }
        }
        EXPECT_TRUE(found) << "Passenger not found: " << expectedName;
    }
}

TEST_F(StartupManagerTest, MockData_TicketsExist) {
    StartupManager manager;
    RMSFacade* facade = manager.buildFacade();

    auto tickets = facade->listTickets();

    // Based on loadMockData, should have at least 11 tickets
    // (some passengers like Omar book multiple tickets)
    EXPECT_GE(tickets.size(), 10);

    // Verify all tickets are booked status
    for (const auto& ticket : tickets) {
        EXPECT_EQ(ticket.getStatus(), booked);
    }
}

TEST_F(StartupManagerTest, MockData_TrainsHaveCorrectCapacity) {
    StartupManager manager;
    RMSFacade* facade = manager.buildFacade();

    auto trains = facade->listTrains();

    std::map<std::string, int> expectedCapacities = {
            {"Alex NightLine", 30},
            {"Luxor Premium", 40},
            {"Cairo Express", 25},
            {"Aswan Sleeper", 20},
            {"Mediterranean Star", 35}
    };

    for (const auto& train : trains) {
        auto it = expectedCapacities.find(train.getTrainName());
        if (it != expectedCapacities.end()) {
            EXPECT_EQ(train.getTotalSeats(), it->second)
                                << "Train " << train.getTrainName()
                                << " has incorrect capacity";
        }
    }
}

// ===================== Facade Functionality Tests =====================

TEST_F(StartupManagerTest, Facade_CanAddNewTrain) {
    StartupManager manager;
    RMSFacade* facade = manager.buildFacade();

    Train newTrain = facade->addTrain("New Train", 50);

    EXPECT_GT(newTrain.getTrainId(), 0);
    EXPECT_EQ(newTrain.getTrainName(), "New Train");
    EXPECT_EQ(newTrain.getTotalSeats(), 50);

    auto trains = facade->listTrains();
    EXPECT_EQ(trains.size(), 6); // 5 mock + 1 new
}

TEST_F(StartupManagerTest, Facade_CanAddNewPassenger) {
    StartupManager manager;
    RMSFacade* facade = manager.buildFacade();

    Passenger newPassenger = facade->addPassenger("New Passenger");

    EXPECT_GT(newPassenger.getId(), 0);
    EXPECT_EQ(newPassenger.getName(), "New Passenger");

    auto passengers = facade->listPassengers();
    EXPECT_EQ(passengers.size(), 11); // 10 mock + 1 new
}

TEST_F(StartupManagerTest, Facade_CanBookNewTicket) {
    StartupManager manager;
    RMSFacade* facade = manager.buildFacade();

    auto trains = facade->listTrains();
    ASSERT_FALSE(trains.empty());

    auto ticket = facade->bookTicket(trains[0].getTrainId(), "Test Passenger");

    ASSERT_TRUE(ticket.has_value());
    EXPECT_EQ(ticket->getTrainId(), trains[0].getTrainId());
}

TEST_F(StartupManagerTest, Facade_CanCancelTicket) {
    StartupManager manager;
    RMSFacade* facade = manager.buildFacade();

    auto tickets = facade->listTickets();
    ASSERT_FALSE(tickets.empty());

    EXPECT_NO_THROW(facade->cancelTicket(tickets[0].getId()));
}

TEST_F(StartupManagerTest, Facade_CanUpdateTrain) {
    StartupManager manager;
    RMSFacade* facade = manager.buildFacade();

    auto trains = facade->listTrains();
    ASSERT_FALSE(trains.empty());

    Train updated = facade->updateTrain(
            trains[0].getTrainId(),
            "Updated Name",
            50
    );

    EXPECT_EQ(updated.getTrainName(), "Updated Name");
    EXPECT_EQ(updated.getTotalSeats(), 50);
}

TEST_F(StartupManagerTest, Facade_CanUpdatePassenger) {
    StartupManager manager;
    RMSFacade* facade = manager.buildFacade();

    auto passengers = facade->listPassengers();
    ASSERT_FALSE(passengers.empty());

    Passenger updated = facade->updatePassenger(
            passengers[0].getId(),
            "Updated Name"
    );

    EXPECT_EQ(updated.getName(), "Updated Name");
}

TEST_F(StartupManagerTest, Facade_CanDeleteTrain) {
    StartupManager manager;
    RMSFacade* facade = manager.buildFacade();

    auto trains = facade->listTrains();
    ASSERT_FALSE(trains.empty());
    int initialCount = trains.size();

    EXPECT_NO_THROW(facade->deleteTrain(trains[0].getTrainId()));

    auto updatedTrains = facade->listTrains();
    EXPECT_EQ(updatedTrains.size(), initialCount - 1);
}

TEST_F(StartupManagerTest, Facade_CanDeletePassenger) {
    StartupManager manager;
    RMSFacade* facade = manager.buildFacade();

    auto passengers = facade->listPassengers();
    ASSERT_FALSE(passengers.empty());
    int initialCount = passengers.size();

    // Find a passenger without tickets to delete
    Passenger toDelete = facade->addPassenger("Temp Passenger");

    EXPECT_NO_THROW(facade->deletePassenger(toDelete.getId()));

    auto updatedPassengers = facade->listPassengers();
    EXPECT_EQ(updatedPassengers.size(), initialCount);
}

// ===================== Integration Tests =====================

TEST_F(StartupManagerTest, MultipleOperationsOnFacade) {
    StartupManager manager;
    RMSFacade* facade = manager.buildFacade();

    // Add new entities
    Train newTrain = facade->addTrain("Integration Train", 20);
    Passenger newPassenger = facade->addPassenger("Integration Passenger");

    // Book ticket
    auto ticket = facade->bookTicket(
            newTrain.getTrainId(),
            "Integration Passenger"
    );

    ASSERT_TRUE(ticket.has_value());

    // Verify all lists
    auto trains = facade->listTrains();
    auto passengers = facade->listPassengers();
    auto tickets = facade->listTickets();

    EXPECT_GE(trains.size(), 6);
    EXPECT_GE(passengers.size(), 11);
    EXPECT_GE(tickets.size(), 11);
}

TEST_F(StartupManagerTest, FacadeStateConsistency) {
    StartupManager manager;
    RMSFacade* facade = manager.buildFacade();

    // Get initial state
    auto initialTrains = facade->listTrains();
    auto initialPassengers = facade->listPassengers();
    auto initialTickets = facade->listTickets();

    // Perform operations
    Train train = facade->addTrain("Test Train", 10);
    facade->addPassenger("Test Passenger");
    facade->bookTicket(train.getTrainId(), "Test Passenger");

    // Verify state changed appropriately
    auto finalTrains = facade->listTrains();
    auto finalPassengers = facade->listPassengers();
    auto finalTickets = facade->listTickets();

    EXPECT_EQ(finalTrains.size(), initialTrains.size() + 1);
    EXPECT_EQ(finalPassengers.size(), initialPassengers.size() + 1);
    EXPECT_EQ(finalTickets.size(), initialTickets.size() + 1);
}

// ===================== Memory Management Tests =====================

TEST_F(StartupManagerTest, MultipleStartupManagers) {
    {
        StartupManager manager1;
        RMSFacade* facade1 = manager1.buildFacade();
        ASSERT_NE(facade1, nullptr);

        auto trains1 = facade1->listTrains();
        EXPECT_EQ(trains1.size(), 5);
    }

    {
        StartupManager manager2;
        RMSFacade* facade2 = manager2.buildFacade();
        ASSERT_NE(facade2, nullptr);

        auto trains2 = facade2->listTrains();
        EXPECT_EQ(trains2.size(), 5);
    }
}

TEST_F(StartupManagerTest, FacadeLifetime) {
    RMSFacade* facade;
    {
        StartupManager manager;
        facade = manager.buildFacade();
        ASSERT_NE(facade, nullptr);

        // Facade should be valid within StartupManager scope
        auto trains = facade->listTrains();
        EXPECT_EQ(trains.size(), 5);
    }
    // After StartupManager goes out of scope, facade pointer is invalid
    // Don't access facade here - it would be undefined behavior
}

// ===================== Edge Cases =====================

TEST_F(StartupManagerTest, BookTicketToMockTrain) {
    StartupManager manager;
    RMSFacade* facade = manager.buildFacade();

    auto trains = facade->listTrains();
    ASSERT_FALSE(trains.empty());

    auto ticket = facade->bookTicket(trains[0].getTrainId(), "New Passenger");

    ASSERT_TRUE(ticket.has_value());
    EXPECT_EQ(ticket->getTrainId(), trains[0].getTrainId());
}

TEST_F(StartupManagerTest, AllMockTrainsHaveAvailability) {
    StartupManager manager;
    RMSFacade* facade = manager.buildFacade();

    auto trains = facade->listTrains();

    for (const auto& train : trains) {
        bool availability = facade->getTrainAvailability(train.getTrainId());
        EXPECT_TRUE(availability)
                            << "Train " << train.getTrainName()
                            << " should have availability";
    }
}

TEST_F(StartupManagerTest, MockPassengersHaveTickets) {
    StartupManager manager;
    RMSFacade* facade = manager.buildFacade();

    auto passengers = facade->listPassengers();
    auto tickets = facade->listTickets();

    // Verify that some passengers have tickets
    std::set<int> passengerIdsWithTickets;
    for (const auto& ticket : tickets) {
        passengerIdsWithTickets.insert(ticket.getPassenger().getId());
    }

    EXPECT_FALSE(passengerIdsWithTickets.empty());
}

==================================================
FILE PATH: .\tests\test_ticket.cpp
==================================================

#include <gtest/gtest.h>
#include "models/Ticket.h"
#include "models/Passenger.h"

class TicketTest : public ::testing::Test {
protected:
    void SetUp() override {}
    void TearDown() override {}
};

TEST_F(TicketTest, ValidConstruction) {
    Passenger p(101, "John Doe");
    Ticket ticket(1, 5, 10, p);
    EXPECT_EQ(ticket.getId(), 1);
    EXPECT_EQ(ticket.getSeat(), 5);
    EXPECT_EQ(ticket.getTrainId(), 10);
    EXPECT_EQ(ticket.getStatus(), booked);
    EXPECT_EQ(ticket.getPassenger().getId(), 101);
    EXPECT_EQ(ticket.getPassenger().getName(), "John Doe");
}

TEST_F(TicketTest, ConstructionWithDifferentPassenger) {
    Passenger p(202, "Jane Smith");
    Ticket ticket(2, 10, 5, p);
    EXPECT_EQ(ticket.getId(), 2);
    EXPECT_EQ(ticket.getSeat(), 10);
    EXPECT_EQ(ticket.getTrainId(), 5);
    EXPECT_EQ(ticket.getPassenger().getId(), 202);
}

TEST_F(TicketTest, DefaultStatusIsBooked) {
    Passenger p(101, "John Doe");
    Ticket ticket(1, 5, 10, p);
    EXPECT_EQ(ticket.getStatus(), booked);
}

TEST_F(TicketTest, InvalidTicketIdNegative) {
    Passenger p(101, "John Doe");
    EXPECT_THROW(Ticket(-1, 5, 10, p), std::invalid_argument);
}

TEST_F(TicketTest, InvalidTicketIdZero) {
    Passenger p(101, "John Doe");
    Ticket t(0, 5, 10, p);
    EXPECT_THROW(t.setId(0), std::invalid_argument);
}

TEST_F(TicketTest, InvalidTrainIdNegative) {
    Passenger p(101, "John Doe");
    EXPECT_THROW(Ticket(1, 5, -1, p), std::invalid_argument);
}

TEST_F(TicketTest, InvalidTrainIdZero) {
    Passenger p(101, "John Doe");
    EXPECT_THROW(Ticket(1, 5, 0, p), std::invalid_argument);
}

TEST_F(TicketTest, InvalidSeatZero) {
    Passenger p(101, "John Doe");
    EXPECT_THROW(Ticket(1, 0, 10, p), std::invalid_argument);
}

TEST_F(TicketTest, InvalidSeatNegative) {
    Passenger p(101, "John Doe");
    EXPECT_THROW(Ticket(1, -5, 10, p), std::invalid_argument);
}

TEST_F(TicketTest, SetStatusToBooked) {
    Passenger p(101, "John Doe");
    Ticket ticket(1, 5, 10, p);
    ticket.setStatus(booked);
    EXPECT_EQ(ticket.getStatus(), booked);
}

TEST_F(TicketTest, SetStatusToCancelled) {
    Passenger p(101, "John Doe");
    Ticket ticket(1, 5, 10, p);
    ticket.setStatus(cancelled);
    EXPECT_EQ(ticket.getStatus(), cancelled);
}

TEST_F(TicketTest, ToggleStatusMultipleTimes) {
    Passenger p(101, "John Doe");
    Ticket ticket(1, 5, 10, p);
    ticket.setStatus(cancelled);
    EXPECT_EQ(ticket.getStatus(), cancelled);
    ticket.setStatus(booked);
    EXPECT_EQ(ticket.getStatus(), booked);
    ticket.setStatus(cancelled);
    EXPECT_EQ(ticket.getStatus(), cancelled);
}

TEST_F(TicketTest, SetIdChangesTicketId) {
    Passenger p(101, "John Doe");
    Ticket ticket(1, 5, 10, p);
    ticket.setId(100);
    EXPECT_EQ(ticket.getId(), 100);
}

TEST_F(TicketTest, SetIdDoesNotAffectOtherFields) {
    Passenger p(101, "John Doe");
    Ticket ticket(1, 5, 10, p);
    ticket.setId(200);
    EXPECT_EQ(ticket.getId(), 200);
    EXPECT_EQ(ticket.getSeat(), 5);
    EXPECT_EQ(ticket.getTrainId(), 10);
    EXPECT_EQ(ticket.getPassenger().getId(), 101);
}

TEST_F(TicketTest, BookedToCancelledWorkflow) {
    Passenger p(101, "John Doe");
    Ticket ticket(1, 5, 10, p);
    EXPECT_EQ(ticket.getStatus(), booked);
    ticket.setStatus(cancelled);
    EXPECT_EQ(ticket.getStatus(), cancelled);
}

TEST_F(TicketTest, PassengerDataIndependent) {
    Passenger p(101, "John Doe");
    Ticket ticket(1, 5, 10, p);
    p.setName("Modified Name");
    EXPECT_EQ(ticket.getPassenger().getName(), "John Doe");
}

TEST_F(TicketTest, MultipleTicketsSamePassenger) {
    Passenger p(101, "John Doe");
    Ticket ticket1(1, 5, 10, p);
    Ticket ticket2(2, 6, 10, p);
    EXPECT_EQ(ticket1.getPassenger().getId(), 101);
    EXPECT_EQ(ticket2.getPassenger().getId(), 101);
    EXPECT_NE(ticket1.getId(), ticket2.getId());
    EXPECT_NE(ticket1.getSeat(), ticket2.getSeat());
}

TEST_F(TicketTest, LargeTicketId) {
    Passenger p(101, "John Doe");
    Ticket ticket(999999, 5, 10, p);
    EXPECT_EQ(ticket.getId(), 999999);
}

TEST_F(TicketTest, LargeSeatNumber) {
    Passenger p(101, "John Doe");
    Ticket ticket(1, 10000, 10, p);
    EXPECT_EQ(ticket.getSeat(), 10000);
}

TEST_F(TicketTest, AllMaximumValues) {
    Passenger p(999999, "John Doe");
    Ticket ticket(999999, 999999, 999999, p);
    EXPECT_EQ(ticket.getId(), 999999);
    EXPECT_EQ(ticket.getSeat(), 999999);
    EXPECT_EQ(ticket.getTrainId(), 999999);
    EXPECT_EQ(ticket.getPassenger().getId(), 999999);
}

==================================================
FILE PATH: .\tests\test_ticketService.cpp
==================================================

#include <gtest/gtest.h>
#include "Services/TicketService.h"
#include "Services/TrainService.h"
#include "Services/PassengerService.h"
#include "Repo/InMemoryTicketRepository.h"
#include "Repo/InMemoryTrainRepository.h"
#include "Repo/InMemoryPassengerRepository.h"

class TicketServiceTest : public ::testing::Test {
protected:
    std::unique_ptr<InMemoryTicketRepository> ticketRepo;
    std::unique_ptr<InMemoryTrainRepository> trainRepo;
    std::unique_ptr<InMemoryPassengerRepository> passengerRepo;

    std::unique_ptr<TrainService> trainService;
    std::unique_ptr<PassengerService> passengerService;
    std::unique_ptr<TicketService> ticketService;

    void SetUp() override {
        ticketRepo = std::make_unique<InMemoryTicketRepository>();
        trainRepo = std::make_unique<InMemoryTrainRepository>();
        passengerRepo = std::make_unique<InMemoryPassengerRepository>();

        trainService = std::make_unique<TrainService>(trainRepo.get());
        passengerService = std::make_unique<PassengerService>(passengerRepo.get());
        ticketService = std::make_unique<TicketService>(
                ticketRepo.get(),
                trainService.get(),
                passengerService.get()
        );
    }

    void TearDown() override {
        ticketRepo->clear();
        trainRepo->clear();
        passengerRepo->clear();
    }
};

// ===================== Book Ticket Tests =====================

TEST_F(TicketServiceTest, BookTicket_Success) {
    Train train = trainService->createTrain("Express", 10);
    Passenger passenger = passengerService->createPassenger("John");

    auto ticket = ticketService->bookTicket(train.getTrainId(), passenger.getId());

    ASSERT_TRUE(ticket.has_value());
    EXPECT_GT(ticket->getId(), 0);
    EXPECT_EQ(ticket->getTrainId(), train.getTrainId());
    EXPECT_EQ(ticket->getPassenger().getId(), passenger.getId());
    EXPECT_EQ(ticket->getStatus(), booked);
    EXPECT_GT(ticket->getSeat(), 0);
}

TEST_F(TicketServiceTest, BookTicket_TrainNotFound) {
    Passenger passenger = passengerService->createPassenger("John");
    EXPECT_THROW(ticketService->bookTicket(999, passenger.getId()), std::out_of_range);
}

TEST_F(TicketServiceTest, BookTicket_PassengerNotFound) {
    Train train = trainService->createTrain("Express", 10);
    EXPECT_THROW(ticketService->bookTicket(train.getTrainId(), 999), std::out_of_range);
}

TEST_F(TicketServiceTest, BookTicket_DuplicateBooking) {
    Train train = trainService->createTrain("Express", 10);
    Passenger passenger = passengerService->createPassenger("John");

    ticketService->bookTicket(train.getTrainId(), passenger.getId());
    EXPECT_THROW(ticketService->bookTicket(train.getTrainId(), passenger.getId()), std::runtime_error);
}

TEST_F(TicketServiceTest, BookTicket_FullTrainReturnsNullopt) {
    Train train = trainService->createTrain("Express", 2);
    Passenger p1 = passengerService->createPassenger("John");
    Passenger p2 = passengerService->createPassenger("Jane");
    Passenger p3 = passengerService->createPassenger("Bob");

    ticketService->bookTicket(train.getTrainId(), p1.getId());
    ticketService->bookTicket(train.getTrainId(), p2.getId());

    auto ticket = ticketService->bookTicket(train.getTrainId(), p3.getId());
    EXPECT_FALSE(ticket.has_value());
}

// ===================== Cancel Ticket Tests =====================

TEST_F(TicketServiceTest, CancelTicket_Success) {
    Train train = trainService->createTrain("Express", 10);
    Passenger passenger = passengerService->createPassenger("John");

    auto ticket = ticketService->bookTicket(train.getTrainId(), passenger.getId());
    ASSERT_TRUE(ticket.has_value());

    EXPECT_NO_THROW(ticketService->cancelTicket(ticket->getId()));

    auto retrieved = ticketService->getTicket(ticket->getId());
    EXPECT_EQ(retrieved.getStatus(), cancelled);
}

TEST_F(TicketServiceTest, CancelTicket_AlreadyCancelledThrows) {
    Train train = trainService->createTrain("Express", 10);
    Passenger passenger = passengerService->createPassenger("John");

    auto ticket = ticketService->bookTicket(train.getTrainId(), passenger.getId());
    ticketService->cancelTicket(ticket->getId());

    EXPECT_THROW(ticketService->cancelTicket(ticket->getId()), std::runtime_error);
}

// ===================== Get Ticket Tests =====================

TEST_F(TicketServiceTest, GetTicket_Success) {
    Train train = trainService->createTrain("Express", 10);
    Passenger passenger = passengerService->createPassenger("John");

    auto booked = ticketService->bookTicket(train.getTrainId(), passenger.getId());
    auto retrieved = ticketService->getTicket(booked->getId());

    EXPECT_EQ(retrieved.getId(), booked->getId());
}

TEST_F(TicketServiceTest, GetTicket_NotFoundThrows) {
    EXPECT_THROW(ticketService->getTicket(999), std::out_of_range);
}

// ===================== Update Ticket Tests =====================

TEST_F(TicketServiceTest, UpdateTicket_Success) {
    Train train = trainService->createTrain("Express", 10);
    Passenger passenger = passengerService->createPassenger("John");

    auto ticket = ticketService->bookTicket(train.getTrainId(), passenger.getId());
    Ticket modified = ticket.value();
    modified.setStatus(cancelled);

    Ticket updated = ticketService->updateTicket(modified);
    EXPECT_EQ(updated.getStatus(), cancelled);
}

// ===================== Waiting List Integration =====================

TEST_F(TicketServiceTest, CancelTicket_FreesSeatAndRebooksWaitingPassenger) {
    Train train = trainService->createTrain("Express", 1);
    Passenger p1 = passengerService->createPassenger("John");
    Passenger p2 = passengerService->createPassenger("Jane");

    auto t1 = ticketService->bookTicket(train.getTrainId(), p1.getId());
    auto t2 = ticketService->bookTicket(train.getTrainId(), p2.getId());

    EXPECT_FALSE(t2.has_value()); // fully booked

    ticketService->cancelTicket(t1->getId()); // should auto-assign seat to p2

    auto allTickets = ticketService->getAllTickets();
    int bookedCount = 0;
    for (auto& t : allTickets) {
        if (t.getStatus() == booked) bookedCount++;
    }
    EXPECT_EQ(bookedCount, 1);
}


==================================================
FILE PATH: .\tests\test_ticktRepo.cpp
==================================================

//
// Created by Omar on 11/24/2025.
//
#include <gtest/gtest.h>
#include "Repo/InMemoryTicketRepository.h"
#include "models/Ticket.h"
#include "models/Passenger.h"

class TicketRepositoryTest : public ::testing::Test {
protected:
    InMemoryTicketRepository repo;
    Passenger testPassenger;

    TicketRepositoryTest() : testPassenger(1, "John Doe") {}

    void SetUp() override {
        repo.clear();
    }

    void TearDown() override {
        repo.clear();
    }
};

TEST_F(TicketRepositoryTest, SaveTicket_GeneratesId) {
    Ticket t(0, 1, 101, testPassenger);
    repo.save(t);

    EXPECT_GT(t.getId(), 0);
    EXPECT_EQ(t.getSeat(), 1);
}

TEST_F(TicketRepositoryTest, GetTicketById_Success) {
    Ticket t(0, 5, 200, testPassenger);
    repo.save(t);

    auto retrieved = repo.getTicketById(t.getId());

    // Based on your repo code, getTicketById returns optional or throws
    // Your implementation throws runtime_error if not found, but returns optional if found
    ASSERT_TRUE(retrieved.has_value());
    EXPECT_EQ(retrieved->getId(), t.getId());
    EXPECT_EQ(retrieved->getPassenger().getName(), "John Doe");
}

TEST_F(TicketRepositoryTest, GetTicketById_ThrowsWhenNotFound) {
    // Your implementation explicitly throws runtime_error for ID lookup failures
    EXPECT_THROW(repo.getTicketById(999), std::runtime_error);
}

TEST_F(TicketRepositoryTest, GetTicketByTrainAndPassenger_Success) {
    int trainId = 100;
    Passenger p(50, "Jane");
    Ticket t(0, 10, trainId, p);
    repo.save(t);

    auto result = repo.getTicketByTrainAndPassenger(trainId, p.getId());

    ASSERT_TRUE(result.has_value());
    EXPECT_EQ(result->getId(), t.getId());
}

TEST_F(TicketRepositoryTest, GetTicketByTrainAndPassenger_ReturnsNulloptWhenNotFound) {
    // Your implementation returns std::nullopt here (doesn't throw)
    auto result = repo.getTicketByTrainAndPassenger(100, 999);
    EXPECT_FALSE(result.has_value());
}

TEST_F(TicketRepositoryTest, DeleteTicket_Success) {
    Ticket t(0, 1, 100, testPassenger);
    repo.save(t);
    int id = t.getId();

    bool deleted = repo.deleteTicket(id);
    EXPECT_TRUE(deleted);

    EXPECT_THROW(repo.getTicketById(id), std::runtime_error);
}

TEST_F(TicketRepositoryTest, GetAllTickets) {
    Ticket t1(0, 1, 100, testPassenger);
    Ticket t2(0, 2, 100, testPassenger);
    repo.save(t1);
    repo.save(t2);

    auto all = repo.getAllTickets();
    EXPECT_EQ(all.size(), 2);
}

==================================================
FILE PATH: .\tests\test_train.cpp
==================================================

// ============================================================================
// TrainTest.cpp - Train Model Tests
// ============================================================================

#include <gtest/gtest.h>
#include "models/Train.h"
#include "models/SeatAllocator.h"

class TrainTest : public ::testing::Test {
protected:
    void SetUp() override {}
    void TearDown() override {}
};

// ============================================================================
// CONSTRUCTION TESTS
// ============================================================================

TEST_F(TrainTest, ValidConstruction) {
    Train train(1, "Express Train", 20);
    EXPECT_EQ(train.getTrainId(), 1);
    EXPECT_EQ(train.getTrainName(), "Express Train");
    EXPECT_EQ(train.getTotalSeats(), 20);
    EXPECT_TRUE(train.hasAvailableSeats());
}

TEST_F(TrainTest, DefaultSeatCount) {
    Train train(1, "Local Train");
    EXPECT_EQ(train.getTotalSeats(), 10);
}

TEST_F(TrainTest, ConstructionWithMinimumSeats) {
    Train train(1, "Mini Train", 1);
    EXPECT_EQ(train.getTotalSeats(), 1);
}

TEST_F(TrainTest, ConstructionWithLargeCapacity) {
    Train train(1, "Mega Train", 1000);
    EXPECT_EQ(train.getTotalSeats(), 1000);
}

TEST_F(TrainTest, SeatAllocatorCreatedAutomatically) {
    Train train(1, "Express Train", 20);
    SeatAllocator* allocator = train.getSeatAllocator();
    EXPECT_NE(allocator, nullptr);
    EXPECT_EQ(allocator->getTotalSeats(), 20);
}

// ============================================================================
// INVALID CONSTRUCTION TESTS
// ============================================================================

TEST_F(TrainTest, InvalidTrainIdNegative) {
    EXPECT_THROW(Train(-1, "Express Train", 20), std::invalid_argument);
}

TEST_F(TrainTest, InvalidTrainIdZero) {
    Train t(100, "Express Train", 20);
    EXPECT_THROW(t.setTrainId(0), std::runtime_error);
}

TEST_F(TrainTest, EmptyNameThrows) {
    EXPECT_THROW(Train(1, "", 20), std::invalid_argument);
}

TEST_F(TrainTest, NegativeSeatsThrows) {
    EXPECT_THROW(Train(1, "Express Train", -5), std::invalid_argument);
}

TEST_F(TrainTest, AllInvalidParametersThrows) {
    EXPECT_THROW(Train(-1, "", -5), std::invalid_argument);
}

// ============================================================================
// GETTER TESTS
// ============================================================================

TEST_F(TrainTest, GetTrainIdReturnsCorrectValue) {
    Train train(42, "Express Train", 20);
    EXPECT_EQ(train.getTrainId(), 42);
}

TEST_F(TrainTest, GetTrainNameReturnsCorrectValue) {
    Train train(1, "Super Express", 20);
    EXPECT_EQ(train.getTrainName(), "Super Express");
}

TEST_F(TrainTest, GetTotalSeatsReturnsCorrectValue) {
    Train train(1, "Express Train", 50);
    EXPECT_EQ(train.getTotalSeats(), 50);
}

TEST_F(TrainTest, GetSeatAllocatorReturnsValidPointer) {
    Train train(1, "Express Train", 20);
    SeatAllocator* allocator = train.getSeatAllocator();
    EXPECT_NE(allocator, nullptr);
}

// ============================================================================
// SETTER TESTS
// ============================================================================

TEST_F(TrainTest, SetValidTrainName) {
    Train train(1, "Express Train", 20);
    train.setTrainName("Super Express");
    EXPECT_EQ(train.getTrainName(), "Super Express");
}

TEST_F(TrainTest, SetEmptyNameThrows) {
    Train train(1, "Express Train", 20);
    EXPECT_THROW(train.setTrainName(""), std::invalid_argument);
}

TEST_F(TrainTest, SetTrainNameMultipleTimes) {
    Train train(1, "Express Train", 20);
    train.setTrainName("Fast Train");
    train.setTrainName("Ultra Fast Train");
    EXPECT_EQ(train.getTrainName(), "Ultra Fast Train");
}


// ============================================================================
// ADD SEATS TESTS
// ============================================================================

TEST_F(TrainTest, AddSeatsIncreasesTotalSeats) {
    Train train(1, "Express Train", 20);
    train.addSeats(10);
    EXPECT_EQ(train.getTotalSeats(), 30);
}

TEST_F(TrainTest, AddSeatsMultipleTimes) {
    Train train(1, "Express Train", 20);
    train.addSeats(5);
    train.addSeats(5);
    train.addSeats(10);
    EXPECT_EQ(train.getTotalSeats(), 40);
}

TEST_F(TrainTest, AddSeatsUpdatesAllocator) {
    Train train(1, "Express Train", 20);
    train.addSeats(10);

    SeatAllocator* allocator = train.getSeatAllocator();
    EXPECT_EQ(allocator->getTotalSeats(), 30);
}

TEST_F(TrainTest, AddInvalidSeatsZeroThrows) {
    Train train(1, "Express Train", 20);
    EXPECT_THROW(train.addSeats(0), std::invalid_argument);
}

TEST_F(TrainTest, AddInvalidSeatsNegativeThrows) {
    Train train(1, "Express Train", 20);
    EXPECT_THROW(train.addSeats(-5), std::invalid_argument);
}

TEST_F(TrainTest, AddSeatsAfterAllocations) {
    Train train(1, "Express Train", 5);
    train.getSeatAllocator()->allocateSeat(101);
    train.getSeatAllocator()->allocateSeat(102);

    train.addSeats(5);
    EXPECT_EQ(train.getTotalSeats(), 10);
    EXPECT_TRUE(train.hasAvailableSeats());
}

// ============================================================================
// SET SEATS TESTS
// ============================================================================

TEST_F(TrainTest, SetSeatsIncreasesCapacity) {
    Train train(1, "Express Train", 20);
    train.setSeats(30);
    EXPECT_EQ(train.getTotalSeats(), 30);
}

TEST_F(TrainTest, SetSeatsDecreasesCapacity) {
    Train train(1, "Express Train", 20);
    train.setSeats(15);
    EXPECT_EQ(train.getTotalSeats(), 15);
}

TEST_F(TrainTest, SetSeatsToSameValue) {
    Train train(1, "Express Train", 20);
    train.setSeats(20);
    EXPECT_EQ(train.getTotalSeats(), 20);
}

TEST_F(TrainTest, SetInvalidSeatsZeroThrows) {
    Train train(1, "Express Train", 20);
    EXPECT_THROW(train.setSeats(0), std::invalid_argument);
}

TEST_F(TrainTest, SetInvalidSeatsNegativeThrows) {
    Train train(1, "Express Train", 20);
    EXPECT_THROW(train.setSeats(-10), std::invalid_argument);
}

TEST_F(TrainTest, SetSeatsUpdatesAllocator) {
    Train train(1, "Express Train", 20);
    train.setSeats(25);

    SeatAllocator* allocator = train.getSeatAllocator();
    EXPECT_EQ(allocator->getTotalSeats(), 25);
}

TEST_F(TrainTest, SetSeatsBelowAllocatedThrows) {
    Train train(1, "Express Train", 10);
    train.getSeatAllocator()->allocateSeat(101);
    train.getSeatAllocator()->allocateSeat(102);
    train.getSeatAllocator()->allocateSeat(103);

    EXPECT_THROW(train.setSeats(2), std::out_of_range);
}

// ============================================================================
// AVAILABLE SEATS TESTS
// ============================================================================

TEST_F(TrainTest, HasAvailableSeatsInitially) {
    Train train(1, "Express Train", 20);
    EXPECT_TRUE(train.hasAvailableSeats());
}

TEST_F(TrainTest, HasAvailableSeatsAfterPartialAllocation) {
    Train train(1, "Express Train", 5);
    train.getSeatAllocator()->allocateSeat(101);
    train.getSeatAllocator()->allocateSeat(102);
    EXPECT_TRUE(train.hasAvailableSeats());
}

TEST_F(TrainTest, NoAvailableSeatsWhenFull) {
    Train train(1, "Express Train", 2);
    train.getSeatAllocator()->allocateSeat(101);
    train.getSeatAllocator()->allocateSeat(102);
    EXPECT_FALSE(train.hasAvailableSeats());
}

TEST_F(TrainTest, HasAvailableSeatsAfterFreeing) {
    Train train(1, "Express Train", 2);
    train.getSeatAllocator()->allocateSeat(101);
    train.getSeatAllocator()->allocateSeat(102);
    train.getSeatAllocator()->freeSeat(1);
    EXPECT_TRUE(train.hasAvailableSeats());
}

// ============================================================================
// COPY CONSTRUCTOR TESTS
// ============================================================================

TEST_F(TrainTest, CopyConstructorCopiesAllFields) {
    Train train(1, "Express Train", 20);
    train.getSeatAllocator()->allocateSeat(101);
    train.getSeatAllocator()->allocateSeat(102);

    Train copy(train);
    EXPECT_EQ(copy.getTrainId(), train.getTrainId());
    EXPECT_EQ(copy.getTrainName(), train.getTrainName());
    EXPECT_EQ(copy.getTotalSeats(), train.getTotalSeats());
}

TEST_F(TrainTest, CopyConstructorCreatesIndependentCopy) {
    Train train(1, "Express Train", 20);
    train.getSeatAllocator()->allocateSeat(101);

    Train copy(train);
    copy.getSeatAllocator()->allocateSeat(102);

    EXPECT_NE(train.getSeatAllocator(), copy.getSeatAllocator());
}

TEST_F(TrainTest, CopyConstructorCopiesSeatAllocator) {
    Train train(1, "Express Train", 5);
    train.getSeatAllocator()->allocateSeat(101);
    train.getSeatAllocator()->allocateSeat(102);

    Train copy(train);
    SeatAllocator* origAllocator = train.getSeatAllocator();
    SeatAllocator* copyAllocator = copy.getSeatAllocator();

    EXPECT_EQ(origAllocator->getAllocatedSeatCount(),
              copyAllocator->getAllocatedSeatCount());
}

// ============================================================================
// ASSIGNMENT OPERATOR TESTS
// ============================================================================

TEST_F(TrainTest, AssignmentOperatorCopiesAllFields) {
    Train train(1, "Express Train", 20);
    train.getSeatAllocator()->allocateSeat(101);

    Train other(2, "Local Train", 10);
    other = train;

    EXPECT_EQ(other.getTrainId(), 1);
    EXPECT_EQ(other.getTrainName(), "Express Train");
    EXPECT_EQ(other.getTotalSeats(), 20);
}

TEST_F(TrainTest, SelfAssignmentHandled) {
    Train train(1, "Express Train", 20);
    train.getSeatAllocator()->allocateSeat(101);

    train = train;

    EXPECT_EQ(train.getTrainId(), 1);
    EXPECT_EQ(train.getTrainName(), "Express Train");
    EXPECT_EQ(train.getTotalSeats(), 20);
}

TEST_F(TrainTest, AssignmentOperatorCreatesIndependentCopy) {
    Train train(1, "Express Train", 20);
    train.getSeatAllocator()->allocateSeat(101);

    Train other(2, "Local Train", 10);
    other = train;

    other.getSeatAllocator()->allocateSeat(102);

    EXPECT_EQ(train.getSeatAllocator()->getAllocatedSeatCount(), 1);
    EXPECT_EQ(other.getSeatAllocator()->getAllocatedSeatCount(), 2);
}

// ============================================================================
// CLONE METHOD TESTS
// ============================================================================

TEST_F(TrainTest, CloneCreatesExactCopy) {
    Train train(1, "Express Train", 20);
    train.getSeatAllocator()->allocateSeat(101);
    train.getSeatAllocator()->allocateSeat(102);

    auto cloned = train.clone();
    EXPECT_EQ(cloned->getTrainId(), train.getTrainId());
    EXPECT_EQ(cloned->getTrainName(), train.getTrainName());
    EXPECT_EQ(cloned->getTotalSeats(), train.getTotalSeats());
}

TEST_F(TrainTest, CloneCreatesIndependentObject) {
    Train train(1, "Express Train", 20);
    train.getSeatAllocator()->allocateSeat(101);

    auto cloned = train.clone();
    cloned->getSeatAllocator()->allocateSeat(102);

    EXPECT_EQ(train.getSeatAllocator()->getAllocatedSeatCount(), 1);
    EXPECT_EQ(cloned->getSeatAllocator()->getAllocatedSeatCount(), 2);
}

TEST_F(TrainTest, ClonePreservesSeatAllocatorState) {
    Train train(1, "Express Train", 5);
    train.getSeatAllocator()->allocateSeat(101);
    train.getSeatAllocator()->allocateSeat(102);
    train.getSeatAllocator()->allocateSeat(103);

    auto cloned = train.clone();

    EXPECT_EQ(cloned->getSeatAllocator()->getAllocatedSeatCount(), 3);
    EXPECT_EQ(cloned->getSeatAllocator()->getAvailableSeatCount(), 2);
}

// ============================================================================
// INTEGRATION WITH SEAT ALLOCATOR TESTS
// ============================================================================

TEST_F(TrainTest, AllocateSeatThroughTrain) {
    Train train(1, "Express Train", 5);
    SeatAllocator* allocator = train.getSeatAllocator();

    int seat = allocator->allocateSeat(101);
    EXPECT_EQ(seat, 1);
    EXPECT_TRUE(train.hasAvailableSeats());
}

TEST_F(TrainTest, FillTrainCompletely) {
    Train train(1, "Express Train", 3);
    SeatAllocator* allocator = train.getSeatAllocator();

    allocator->allocateSeat(101);
    allocator->allocateSeat(102);
    allocator->allocateSeat(103);

    EXPECT_FALSE(train.hasAvailableSeats());
}

TEST_F(TrainTest, AddSeatsAfterFull) {
    Train train(1, "Express Train", 2);
    SeatAllocator* allocator = train.getSeatAllocator();

    allocator->allocateSeat(101);
    allocator->allocateSeat(102);
    EXPECT_FALSE(train.hasAvailableSeats());

    train.addSeats(3);
    EXPECT_TRUE(train.hasAvailableSeats());
}

TEST_F(TrainTest, FreeSeatRestoresAvailability) {
    Train train(1, "Express Train", 2);
    SeatAllocator* allocator = train.getSeatAllocator();

    allocator->allocateSeat(101);
    allocator->allocateSeat(102);
    allocator->freeSeat(1);

    EXPECT_TRUE(train.hasAvailableSeats());
}

// ============================================================================
// EDGE CASE TESTS
// ============================================================================

TEST_F(TrainTest, SingleSeatTrain) {
    Train train(1, "Mini Train", 1);
    train.getSeatAllocator()->allocateSeat(101);
    EXPECT_FALSE(train.hasAvailableSeats());
}

TEST_F(TrainTest, LargeCapacityTrain) {
    Train train(1, "Mega Train", 10000);
    EXPECT_EQ(train.getTotalSeats(), 10000);
    EXPECT_TRUE(train.hasAvailableSeats());
}

TEST_F(TrainTest, TrainNameWithNumbers) {
    Train train(1, "Train123", 20);
    EXPECT_EQ(train.getTrainName(), "Train123");
}

TEST_F(TrainTest, TrainNameWithSpaces) {
    Train train(1, "High Speed Rail", 20);
    EXPECT_EQ(train.getTrainName(), "High Speed Rail");
}

TEST_F(TrainTest, MaximumTrainId) {
    Train train(999999, "Express Train", 20);
    EXPECT_EQ(train.getTrainId(), 999999);
}

// ============================================================================
// STRESS TESTS
// ============================================================================

TEST_F(TrainTest, AllocateAndFreeManySeats) {
    Train train(1, "Express Train", 100);
    SeatAllocator* allocator = train.getSeatAllocator();

    // Allocate 50 seats
    for (int i = 1; i <= 50; i++) {
        allocator->allocateSeat(100 + i);
    }

    // Free first 25 seats
    for (int i = 1; i <= 25; i++) {
        allocator->freeSeat(i);
    }

    EXPECT_TRUE(train.hasAvailableSeats());
    EXPECT_EQ(allocator->getAllocatedSeatCount(), 25);
}

TEST_F(TrainTest, MultipleOperationsSequence) {
    Train train(1, "Express Train", 10);

    train.addSeats(5);
    EXPECT_EQ(train.getTotalSeats(), 15);

    train.setSeats(20);
    EXPECT_EQ(train.getTotalSeats(), 20);

    train.getSeatAllocator()->allocateSeat(101);
    EXPECT_TRUE(train.hasAvailableSeats());

    train.setTrainName("Updated Express");
    EXPECT_EQ(train.getTrainName(), "Updated Express");
}



==================================================
FILE PATH: .\tests\test_trainRepo.cpp
==================================================

#include <gtest/gtest.h>
#include "Repo/InMemoryTrainRepository.h"
#include <memory>
#include <algorithm>
#include <stdexcept>
#include <optional>

class InMemoryTrainRepositoryTest : public ::testing::Test {
protected:
    InMemoryTrainRepository repo;

    void SetUp() override {
        repo.clear();
    }

    void TearDown() override {
        repo.clear();
    }
};

// ===================== Basic Save Tests =====================

TEST_F(InMemoryTrainRepositoryTest, SaveAndGetTrainById) {
    Train t1(0, "Express", 20);
    repo.save(t1);

    EXPECT_EQ(t1.getTrainName(), "Express");
    EXPECT_EQ(t1.getTotalSeats(), 20);
    EXPECT_GT(t1.getTrainId(), 0);

    auto fetched = repo.getTrainById(t1.getTrainId());
    ASSERT_TRUE(fetched.has_value());
    EXPECT_EQ(fetched->getTrainName(), "Express");
    EXPECT_EQ(fetched->getTrainId(), t1.getTrainId());
}

TEST_F(InMemoryTrainRepositoryTest, SaveModifiesOriginalTrainId) {
    Train t(0, "Test", 10);
    EXPECT_EQ(t.getTrainId(), 0);

    repo.save(t);

    // After save, the original train should have its ID updated
    EXPECT_GT(t.getTrainId(), 0);
}

// ===================== Auto-Increment ID Tests =====================

TEST_F(InMemoryTrainRepositoryTest, AutoIncrementId) {
    Train t1(0, "Express", 20);
    repo.save(t1);

    Train t2(0, "Regional", 15);
    repo.save(t2);

    EXPECT_EQ(t1.getTrainId(), 1);
    EXPECT_EQ(t2.getTrainId(), 2);
}

TEST_F(InMemoryTrainRepositoryTest, AutoIncrementSequential) {
    vector<int> ids;

    for (int i = 0; i < 10; ++i) {
        Train t(0, "Train" + std::to_string(i), 10);
        repo.save(t);
        ids.push_back(t.getTrainId());
    }

    // Verify sequential IDs: 1, 2, 3, ..., 10
    for (size_t i = 0; i < ids.size(); ++i) {
        EXPECT_EQ(ids[i], i + 1);
    }
}

TEST_F(InMemoryTrainRepositoryTest, AutoIncrementAfterDelete) {
    Train t1(0, "Train1", 10);
    repo.save(t1);
    EXPECT_EQ(t1.getTrainId(), 1);

    Train t2(0, "Train2", 10);
    repo.save(t2);
    EXPECT_EQ(t2.getTrainId(), 2);

    // Delete first train
    repo.deleteTrain(t1.getTrainId());

    // Next train should get ID 3, not reuse ID 1
    Train t3(0, "Train3", 10);
    repo.save(t3);
    EXPECT_EQ(t3.getTrainId(), 3);
}

// ===================== Explicit ID Tests =====================

TEST_F(InMemoryTrainRepositoryTest, SaveWithExplicitId) {
    Train t(42, "Explicit", 10);
    repo.save(t);

    EXPECT_EQ(t.getTrainId(), 42);
}

TEST_F(InMemoryTrainRepositoryTest, ExplicitIdDoesNotChangeNextId_IfLower) {
    Train t1(0, "Auto1", 10);
    repo.save(t1); // Gets ID 1, next_id becomes 2

    Train t2(0, "Auto2", 10);
    repo.save(t2); // Gets ID 2, next_id becomes 3

    Train t3(1, "Explicit", 10);
    repo.save(t3); // Should update train with ID 1

    Train t4(0, "Auto3", 10);
    repo.save(t4);
    EXPECT_EQ(t4.getTrainId(), 3);
}

TEST_F(InMemoryTrainRepositoryTest, ExplicitIdUpdatesNextId_IfHigher) {
    Train t1(0, "Auto", 10);
    repo.save(t1);
    EXPECT_EQ(t1.getTrainId(), 1);

    Train t2(100, "High", 10);
    repo.save(t2);
    EXPECT_EQ(t2.getTrainId(), 100);

    Train t3(0, "Auto2", 10);
    repo.save(t3);
    EXPECT_EQ(t3.getTrainId(), 101);
}

TEST_F(InMemoryTrainRepositoryTest, ExplicitIdEqualToNextId) {
    Train t1(0, "Auto", 10);
    repo.save(t1); // ID 1, next_id = 2

    Train t2(2, "Explicit", 10);
    repo.save(t2);
    EXPECT_EQ(t2.getTrainId(), 2);

    Train t3(0, "Auto2", 10);
    repo.save(t3);
    EXPECT_EQ(t3.getTrainId(), 3);
}

TEST_F(InMemoryTrainRepositoryTest, MultipleExplicitHighIds) {
    Train t1(50, "Train50", 10);
    repo.save(t1);

    Train t2(100, "Train100", 10);
    repo.save(t2);

    Train t3(75, "Train75", 10);
    repo.save(t3);

    Train t4(0, "Auto", 10);
    repo.save(t4);
    EXPECT_EQ(t4.getTrainId(), 101);
}



TEST_F(InMemoryTrainRepositoryTest, VeryLargeExplicitId) {
    Train t(999999, "Large", 10);
    repo.save(t);

    EXPECT_EQ(t.getTrainId(), 999999);

    Train t2(0, "Auto", 10);
    repo.save(t2);
    EXPECT_EQ(t2.getTrainId(), 1000000);
}

// ===================== Update Tests =====================

TEST_F(InMemoryTrainRepositoryTest, UpdateExistingTrain) {
    Train t1(0, "Express", 20);
    repo.save(t1);
    int originalId = t1.getTrainId();

    Train updatedTrain(originalId, "Super Express", 30);
    repo.save(updatedTrain);

    EXPECT_EQ(updatedTrain.getTrainId(), originalId);
    EXPECT_EQ(updatedTrain.getTrainName(), "Super Express");
    EXPECT_EQ(updatedTrain.getTotalSeats(), 30);

    auto all = repo.getAllTrains();
    EXPECT_EQ(all.size(), 1);
}

TEST_F(InMemoryTrainRepositoryTest, UpdatePreservesId) {
    Train t1(0, "Original", 10);
    repo.save(t1);
    int originalId = t1.getTrainId();

    Train updated(originalId, "Updated", 20);
    repo.save(updated);

    EXPECT_EQ(updated.getTrainId(), originalId);
    EXPECT_EQ(updated.getTrainName(), "Updated");
    EXPECT_EQ(updated.getTotalSeats(), 20);
}

TEST_F(InMemoryTrainRepositoryTest, UpdateDoesNotChangeNextId) {
    Train t1(0, "Train1", 10);
    repo.save(t1); // ID 1

    Train t2(0, "Train2", 10);
    repo.save(t2); // ID 2

    Train updated(t1.getTrainId(), "Updated", 20);
    repo.save(updated);

    Train t3(0, "Train3", 10);
    repo.save(t3);
    EXPECT_EQ(t3.getTrainId(), 3);
}

TEST_F(InMemoryTrainRepositoryTest, UpdateWithSeatAllocatorState) {
    Train t(0, "Test", 5);
    auto allocator = t.getSeatAllocator();
    allocator->allocateSeat(101);
    allocator->allocateSeat(102);

    repo.save(t);
    int trainId = t.getTrainId();

    EXPECT_EQ(t.getSeatAllocator()->getAvailableSeatCount(), 3);

    auto fetchedOpt = repo.getTrainById(trainId);
    ASSERT_TRUE(fetchedOpt.has_value());
    Train fetched = fetchedOpt.value();
    fetched.getSeatAllocator()->allocateSeat(103);

    repo.save(fetched);

    auto updatedOpt = repo.getTrainById(trainId);
    ASSERT_TRUE(updatedOpt.has_value());
    EXPECT_EQ(updatedOpt->getSeatAllocator()->getAvailableSeatCount(), 2);
}

TEST_F(InMemoryTrainRepositoryTest, UpdateMultipleTimes) {
    Train t(0, "Original", 10);
    repo.save(t);
    int id = t.getTrainId();

    for (int i = 1; i <= 5; ++i) {
        Train update(id, "Version" + std::to_string(i), 10 + i);
        repo.save(update);
    }

    auto finalOpt = repo.getTrainById(id);
    ASSERT_TRUE(finalOpt.has_value());
    EXPECT_EQ(finalOpt->getTrainName(), "Version5");
    EXPECT_EQ(finalOpt->getTotalSeats(), 15);

    auto all = repo.getAllTrains();
    EXPECT_EQ(all.size(), 1);
}

// ===================== Delete Tests =====================

TEST_F(InMemoryTrainRepositoryTest, DeleteTrain) {
    Train t(0, "Express", 20);
    repo.save(t);
    int id = t.getTrainId();

    bool deleted = repo.deleteTrain(id);
    EXPECT_TRUE(deleted);

    EXPECT_FALSE(repo.getTrainById(id).has_value());
}

TEST_F(InMemoryTrainRepositoryTest, DeleteNonExistentTrain) {
    bool result = repo.deleteTrain(999);
    EXPECT_FALSE(result);
}

TEST_F(InMemoryTrainRepositoryTest, DeleteAllTrains) {
    Train t1(0, "Train1", 10);
    Train t2(0, "Train2", 10);
    Train t3(0, "Train3", 10);

    repo.save(t1);
    repo.save(t2);
    repo.save(t3);

    EXPECT_TRUE(repo.deleteTrain(t1.getTrainId()));
    EXPECT_TRUE(repo.deleteTrain(t2.getTrainId()));
    EXPECT_TRUE(repo.deleteTrain(t3.getTrainId()));

    auto all = repo.getAllTrains();
    EXPECT_TRUE(all.empty());
}

TEST_F(InMemoryTrainRepositoryTest, DeleteSameTrainTwice) {
    Train t(0, "Test", 10);
    repo.save(t);
    int id = t.getTrainId();

    EXPECT_TRUE(repo.deleteTrain(id));
    EXPECT_FALSE(repo.deleteTrain(id));
}

TEST_F(InMemoryTrainRepositoryTest, DeleteWithExplicitId) {
    Train t(42, "Explicit", 10);
    repo.save(t);

    EXPECT_TRUE(repo.deleteTrain(42));
    EXPECT_FALSE(repo.getTrainById(42).has_value());
}

// ===================== GetTrainById Tests =====================

TEST_F(InMemoryTrainRepositoryTest, GetNonExistentTrain) {
    EXPECT_FALSE(repo.getTrainById(999).has_value());
}

TEST_F(InMemoryTrainRepositoryTest, GetTrainByIdReturnsCorrectTrain) {
    Train t1(0, "Train1", 10);
    Train t2(0, "Train2", 20);
    Train t3(0, "Train3", 30);

    repo.save(t1);
    repo.save(t2);
    repo.save(t3);

    auto fetched2 = repo.getTrainById(t2.getTrainId());
    ASSERT_TRUE(fetched2.has_value());
    EXPECT_EQ(fetched2->getTrainName(), "Train2");
    EXPECT_EQ(fetched2->getTotalSeats(), 20);
}

TEST_F(InMemoryTrainRepositoryTest, GetTrainByIdReturnsCopy) {
    Train t(0, "Original", 10);
    repo.save(t);
    int id = t.getTrainId();

    auto fetchedOpt = repo.getTrainById(id);
    ASSERT_TRUE(fetchedOpt.has_value());
    Train fetched = fetchedOpt.value();
    fetched.setTrainName("Modified");

    auto original = repo.getTrainById(id);
    ASSERT_TRUE(original.has_value());
    EXPECT_EQ(original->getTrainName(), "Original");
}


TEST_F(InMemoryTrainRepositoryTest, GetTrainByZeroId) {
    EXPECT_FALSE(repo.getTrainById(0).has_value());
}

// ===================== GetAllTrains Tests =====================

TEST_F(InMemoryTrainRepositoryTest, GetAllTrains) {
    Train t1(0, "Express", 20);
    Train t2(0, "Regional", 15);

    repo.save(t1);
    repo.save(t2);

    auto all = repo.getAllTrains();
    EXPECT_EQ(all.size(), 2);

    vector<std::string> names;
    for (const auto& train : all) {
        names.push_back(train.getTrainName());
    }

    EXPECT_NE(std::find(names.begin(), names.end(), "Express"), names.end());
    EXPECT_NE(std::find(names.begin(), names.end(), "Regional"), names.end());
}

TEST_F(InMemoryTrainRepositoryTest, GetAllTrainsEmpty) {
    auto all = repo.getAllTrains();
    EXPECT_TRUE(all.empty());
}

TEST_F(InMemoryTrainRepositoryTest, GetAllTrainsAfterDelete) {
    Train t1(0, "Train1", 10);
    Train t2(0, "Train2", 15);
    Train t3(0, "Train3", 20);

    repo.save(t1);
    repo.save(t2);
    repo.save(t3);

    repo.deleteTrain(t1.getTrainId());

    auto all = repo.getAllTrains();
    EXPECT_EQ(all.size(), 2);
}

// ===================== Clear Tests =====================

TEST_F(InMemoryTrainRepositoryTest, ClearRepository) {
    Train t1(0, "Express", 20);
    Train t2(0, "Regional", 15);

    repo.save(t1);
    repo.save(t2);

    repo.clear();
    auto all = repo.getAllTrains();
    EXPECT_TRUE(all.empty());
}

TEST_F(InMemoryTrainRepositoryTest, ClearEmptyRepository) {
    repo.clear();
    auto all = repo.getAllTrains();
    EXPECT_TRUE(all.empty());
}

TEST_F(InMemoryTrainRepositoryTest, ClearResetsNextId) {
    Train t1(0, "Train1", 10);
    repo.save(t1);
    EXPECT_EQ(t1.getTrainId(), 1);

    repo.clear();

    Train t2(0, "Train2", 15);
    repo.save(t2);
    EXPECT_EQ(t2.getTrainId(), 1);

    auto all = repo.getAllTrains();
    EXPECT_EQ(all.size(), 1);
}

// ===================== Seat Allocator Tests =====================

TEST_F(InMemoryTrainRepositoryTest, SeatAllocatorWorks) {
    Train t(0, "Express", 5);
    repo.save(t);

    EXPECT_TRUE(t.hasAvailableSeats());
    EXPECT_EQ(t.getSeatAllocator()->getAvailableSeatCount(), 5);

    auto allocator = t.getSeatAllocator();
    for (int i = 1; i <= 5; ++i) {
        int seatNumber = allocator->allocateSeat(100 + i);
        EXPECT_GT(seatNumber, 0);
    }

    EXPECT_FALSE(t.hasAvailableSeats());
    EXPECT_EQ(allocator->getAvailableSeatCount(), 0);
}

TEST_F(InMemoryTrainRepositoryTest, SeatAllocationAndFreeing) {
    Train t(0, "Test Train", 3);
    repo.save(t);
    int trainId = t.getTrainId();

    auto seatAllocator = t.getSeatAllocator();
    int seat1 = seatAllocator->allocateSeat(101);
    int seat2 = seatAllocator->allocateSeat(102);

    EXPECT_EQ(seatAllocator->getAvailableSeatCount(), 1);

    repo.save(t);

    auto fetched = repo.getTrainById(trainId);
    ASSERT_TRUE(fetched.has_value());
    EXPECT_EQ(fetched->getSeatAllocator()->getAvailableSeatCount(), 1);
}

TEST_F(InMemoryTrainRepositoryTest, PreservesSeatAllocatorState) {
    Train t(0, "State Test", 3);
    auto allocator = t.getSeatAllocator();
    allocator->allocateSeat(101);
    allocator->allocateSeat(102);

    repo.save(t);

    EXPECT_EQ(t.getSeatAllocator()->getAvailableSeatCount(), 1);

    auto fetched = repo.getTrainById(t.getTrainId());
    ASSERT_TRUE(fetched.has_value());
    EXPECT_EQ(fetched->getSeatAllocator()->getAvailableSeatCount(), 1);
}

// ===================== Edge Cases and Boundary Tests =====================

TEST_F(InMemoryTrainRepositoryTest, DuplicateTrainNames) {
    Train t1(0, "Express", 10);
    Train t2(0, "Express", 15);

    repo.save(t1);
    repo.save(t2);

    EXPECT_NE(t1.getTrainId(), t2.getTrainId());

    auto all = repo.getAllTrains();
    EXPECT_EQ(all.size(), 2);
}

TEST_F(InMemoryTrainRepositoryTest, SaveEmptyNameTrainThrows) {
    // Cannot create a train with empty name
    EXPECT_THROW(Train t(5, "", 10), std::invalid_argument);
}

TEST_F(InMemoryTrainRepositoryTest, SaveValidTrain) {
    Train t(1, "Valid Train", 10);
    repo.save(t);

    auto fetched = repo.getTrainById(t.getTrainId());
    ASSERT_TRUE(fetched.has_value());
    EXPECT_EQ(fetched->getTrainName(), "Valid Train");
}
TEST_F(InMemoryTrainRepositoryTest, NegativeExplicitIdThrows) {
    // Cannot create a train with negative ID; should throw
    EXPECT_THROW(Train t(-5, "Negative", 10), std::invalid_argument);

    // Next auto-increment train works fine
    Train t2(0, "Auto", 10);
    repo.save(t2);
    EXPECT_EQ(t2.getTrainId(), 1);

    auto fetched = repo.getTrainById(t2.getTrainId());
    ASSERT_TRUE(fetched.has_value());
    EXPECT_EQ(fetched->getTrainName(), "Auto");
}





TEST_F(InMemoryTrainRepositoryTest, MultipleOperations) {
    Train t1(0, "Train A", 10);
    Train t2(0, "Train B", 15);
    Train t3(0, "Train C", 20);

    repo.save(t1);
    repo.save(t2);
    repo.save(t3);

    auto all = repo.getAllTrains();
    EXPECT_EQ(all.size(), 3);

    bool deleted = repo.deleteTrain(t2.getTrainId());
    EXPECT_TRUE(deleted);

    all = repo.getAllTrains();
    EXPECT_EQ(all.size(), 2);

    vector<std::string> names;
    for (const auto& train : all) {
        names.push_back(train.getTrainName());
    }
    EXPECT_NE(std::find(names.begin(), names.end(), "Train A"), names.end());
    EXPECT_NE(std::find(names.begin(), names.end(), "Train C"), names.end());
    EXPECT_EQ(std::find(names.begin(), names.end(), "Train B"), names.end());
}

TEST_F(InMemoryTrainRepositoryTest, SaveManyTrains) {
    const int COUNT = 100;
    vector<int> ids;

    for (int i = 0; i < COUNT; ++i) {
        Train t(0, "Train" + std::to_string(i), i + 1);
        repo.save(t);
        ids.push_back(t.getTrainId());
    }

    auto all = repo.getAllTrains();
    EXPECT_EQ(all.size(), COUNT);

    for (int i = 0; i < COUNT; ++i) {
        EXPECT_EQ(ids[i], i + 1);
    }
}

TEST_F(InMemoryTrainRepositoryTest, MixedExplicitAndAutoIds) {
    Train t1(0, "Auto1", 10);
    repo.save(t1); // ID 1
    EXPECT_EQ(t1.getTrainId(), 1);

    Train t2(50, "Explicit50", 10);
    repo.save(t2); // ID 50

    Train t3(0, "Auto2", 10);
    repo.save(t3); // ID 51
    EXPECT_EQ(t3.getTrainId(), 51);

    Train t4(25, "Explicit25", 10);
    repo.save(t4); // ID 25

    Train t5(0, "Auto3", 10);
    repo.save(t5); // ID 52
    EXPECT_EQ(t5.getTrainId(), 52);

    auto all = repo.getAllTrains();
    EXPECT_EQ(all.size(), 5);
}
TEST_F(InMemoryTrainRepositoryTest, SaveWithZeroSeats) {
    Train t(0, "ZeroSeats", 0);
    repo.save(t);

    EXPECT_EQ(t.getTotalSeats(), 0);                     // Reflects the actual Train value
    EXPECT_EQ(t.getSeatAllocator()->getAvailableSeatCount(), 10); // SeatAllocator defaults to 10
}


TEST_F(InMemoryTrainRepositoryTest, SaveWithNegativeIdThrows) {
    // Trying to create a train with a negative ID should throw
    EXPECT_THROW({
                     Train t(-10, "Negative", 10);
                     repo.save(t);
                 }, std::invalid_argument);
}

TEST_F(InMemoryTrainRepositoryTest, GetTrainWithNegativeId) {
    // Trying to fetch a train with a negative ID
    EXPECT_FALSE(repo.getTrainById(-10).has_value());
}

TEST_F(InMemoryTrainRepositoryTest, SaveEmptyNameTrain) {
    // Cannot create a train with empty name; should throw
    EXPECT_THROW(Train emptyNameTrain(5, "", 10), std::invalid_argument);

    // For a valid train
    Train t(1, "Valid Train", 10);
    repo.save(t);

    auto fetched = repo.getTrainById(t.getTrainId());
    ASSERT_TRUE(fetched.has_value());
    EXPECT_EQ(fetched->getTrainName(), "Valid Train");
}

==================================================
FILE PATH: .\tests\test_trainSevice.cpp
==================================================

#include <gtest/gtest.h>
#include "Services/TrainService.h"
#include "Repo/InMemoryTrainRepository.h"

class TrainServiceTest : public ::testing::Test {
protected:
    std::unique_ptr<InMemoryTrainRepository> repo;
    std::unique_ptr<TrainService> service;

    void SetUp() override {
        repo = std::make_unique<InMemoryTrainRepository>();
        service = std::make_unique<TrainService>(repo.get());
    }
};

TEST_F(TrainServiceTest, CreateTrain_Success) {
    Train train = service->createTrain("Test Train", 30);
    EXPECT_GT(train.getTrainId(), 0);
    EXPECT_EQ(train.getTrainName(), "Test Train");
    EXPECT_EQ(train.getTotalSeats(), 30);
}

TEST_F(TrainServiceTest, GetTrain_Exists) {
    Train created = service->createTrain("Test Train", 30);

    Train retrieved = service->getTrain(created.getTrainId());

    EXPECT_EQ(retrieved.getTrainName(), "Test Train");
    EXPECT_EQ(retrieved.getTrainId(), created.getTrainId());
}

TEST_F(TrainServiceTest, GetTrain_NotExists) {
    EXPECT_THROW(service->getTrain(999), std::out_of_range);
}

TEST_F(TrainServiceTest, GetAllTrains_Empty) {
    auto trains = service->getAllTrains();
    EXPECT_TRUE(trains.empty());
}

TEST_F(TrainServiceTest, GetAllTrains_Multiple) {
    service->createTrain("Train 1", 20);
    service->createTrain("Train 2", 30);
    service->createTrain("Train 3", 40);

    auto trains = service->getAllTrains();
    EXPECT_EQ(trains.size(), 3);
}

TEST_F(TrainServiceTest, UpdateTrain_Success) {
    Train created = service->createTrain("Old Name", 20);
    Train updated = service->updateTrain(created.getTrainId(), "New Name", 30);

    EXPECT_EQ(updated.getTrainName(), "New Name");
    EXPECT_EQ(updated.getTotalSeats(), 30);
}

TEST_F(TrainServiceTest, UpdateTrain_NotExists) {
    EXPECT_THROW(service->updateTrain(999, "Test", 30), std::out_of_range);
}

TEST_F(TrainServiceTest, DeleteTrain_Success) {
    Train created = service->createTrain("Test", 20);

    EXPECT_NO_THROW(service->deleteTrain(created.getTrainId()));

    EXPECT_THROW(service->getTrain(created.getTrainId()), std::out_of_range);
}

TEST_F(TrainServiceTest, DeleteTrain_NotExists) {
    EXPECT_THROW(service->deleteTrain(999), std::out_of_range);
}

TEST_F(TrainServiceTest, AddSeats_ById_Success) {
    Train created = service->createTrain("Test", 20);
    Train updated = service->addSeats(created.getTrainId(), 10);
    EXPECT_EQ(updated.getTotalSeats(), 30);
}

TEST_F(TrainServiceTest, AddSeats_ByName_Success) {
    service->createTrain("Test Train", 20);
    Train updated = service->addSeats("Test Train", 10);
    EXPECT_EQ(updated.getTotalSeats(), 30);
}

TEST_F(TrainServiceTest, AddSeats_ByName_NotExists) {
    EXPECT_THROW(service->addSeats("NonExistent", 10), std::runtime_error);
}

TEST_F(TrainServiceTest, IsAvailableSeat_True) {
    Train created = service->createTrain("Test", 20);
    EXPECT_TRUE(service->isAvailbleSeat(created.getTrainId()));
}

TEST_F(TrainServiceTest, IsAvailableSeat_NotExists) {
    EXPECT_THROW(service->isAvailbleSeat(999), std::out_of_range);
}

