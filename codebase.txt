
==================================================
FILE PATH: .\include\CLIController.h
==================================================

//
// Created by Omar on 11/19/2025.
//

#ifndef RMS_CLICONTROLLER_H
#define RMS_CLICONTROLLER_H

#include "RMSFacade.h"
#include <string>
#include <iostream>
using namespace std;

class CLIController {
private:
    RMSFacade* facade;

public:
    CLIController(RMSFacade* facade);
    //helpers to manipulate text
    static vector<string> tokenize(const string &args) ;
    static string readLine();
    static  void waitUser();
    // run
     void run();
     static void clear();
     // help
     static void show_help();

    // train commands
    void list_trains();
    void add_train(const vector<string>& args);
    void get_train_availability(const vector<string>& args);
    void update_train(const vector<string>& args);
    void add_seats(const vector<string>& args);
    void delete_train(const vector<string>& args);
    void get_train_status(const vector<string>& args);

    // passenger commands

    void add_passenger(const vector<string>& args);
    void update_passenger(const vector<string>& args);
    void delete_passenger(const vector<string>& args);
    void list_passengers();

    // ticket commands
    void list_tickets();

    void cancel_ticket(const vector<string>& args);
    void book_ticket(const vector<string>& args);


};
#endif //RMS_CLICONTROLLER_H


==================================================
FILE PATH: .\include\RMSApp.h
==================================================

//
// Created by Omar on 11/18/2025.
//

#ifndef RMS_RMSAPP_H
#define RMS_RMSAPP_H

#include "StartupManager.h"
#include "CLIController.h"

class RMSApp {
    unique_ptr<StartupManager> startupManager;
    unique_ptr<CLIController> cli;
public:
    RMSApp();
    ~RMSApp()= default;
    void run();
};
#endif //RMS_RMSAPP_H


==================================================
FILE PATH: .\include\RMSCommand.h
==================================================

// Created by Omar on 12/1/2025.

#ifndef RMS_RMSCOMMAND_H
#define RMS_RMSCOMMAND_H

#include <string>
#include <unordered_map>

using   std::unordered_map;
using   std::string;
    class RMSCommand {
    public:
        // enums to select the needed command
        enum class MainCmd { TRAIN, PASSENGER, TICKET, SYSTEM, UNKNOWN };
        enum class TrainCmd { LIST, ADD, DELETE, UPDATE, SEATS_ADD,STATUS, AVAILABILITY, UNKNOWN };
        enum class PassengerCmd { LIST, ADD, DELETE, UPDATE, UNKNOWN };
        enum class TicketCmd { LIST, BOOK, CANCEL, UNKNOWN };
        enum class SystemCmd { HELP, EXIT ,CLEAR, UNKNOWN };
        // lookup trees - static to use it without making objects
        static MainCmd getMainCmd(const string& cmd) ;

        static TrainCmd getTrainCmd(const string& sub) ;

        static PassengerCmd getPassengerCmd(const string& sub) ;

        static TicketCmd getTicketCmd(const string& sub) ;

        static SystemCmd getSystemCmd(const string& cmd) ;
    };





#endif //RMS_RMSCOMMAND_H


==================================================
FILE PATH: .\include\RMSFacade.h
==================================================

//
// Created by Omar on 11/19/2025.
//

#ifndef RMS_RMSFACADE_H
#define RMS_RMSFACADE_H

#include <vector>
#include <optional>
#include "Services/TicketService.h"
#include "Services/PassengerService.h"
#include "Services/TrainService.h"

class RMSFacade
{
private:
    TrainService *trainService;
    TicketService *ticketService;
    PassengerService *passengerService;

public:
    RMSFacade(TrainService *ts, TicketService *tks, PassengerService *ps);

    // train features
    std::vector<Train> listTrains();
    Train addTrain(std::string name,  int totalSeats);
    std::optional<Train> getTrain(int trainId);
    bool getTrainAvailability(int trainId);
    Train updateTrain(int trainId, const std::string& name  ,int seats=0);
    Train addSeats(int trainId,int seats=0);
    Train addSeats(const std::string& name,int seats=0);
    void deleteTrain(int trainId);
    void trainStatus(int trainId);

    // passenger features
    std::vector<Passenger> listPassengers();
    std::optional<Passenger> getPassenger(int totalSeats);
    Passenger addPassenger( const std::string& name);
    Passenger updatePassenger(int passengerId, const std::string &name);
    void deletePassenger(int passengerId);


    // ticket features
    std::vector<Ticket> listTickets();
    Ticket bookTicket(int trainId, const std::string& passengerName);
    void cancelTicket(int ticketId);


};
#endif // RMS_RMSFACADE_H


==================================================
FILE PATH: .\include\StartupManager.h
==================================================

//
// Created by Omar on 11/19/2025.
//

#ifndef RMS_STARTUPMANAGER_H
#define RMS_STARTUPMANAGER_H

#include "RMSFacade.h"
#include <memory>

class StartupManager {
private:
    std::unique_ptr<ITrainRepository> trainRepository;
    std::unique_ptr<ITicketRepository> ticketRepository;
    std::unique_ptr<IPassengerRepository> passengerRepository;
    std::unique_ptr<TrainService> trainService;
    std::unique_ptr<PassengerService> passengerService;
    std::unique_ptr<TicketService> ticketService;

    std::unique_ptr<RMSFacade> facade;
public:
    RMSFacade * buildFacade() ;

};
#endif //RMS_STARTUPMANAGER_H


==================================================
FILE PATH: .\include\models\Passenger.h
==================================================

//
// Created by Omar on 11/19/2025.
//

#ifndef RMS_PASSENGER_H
#define RMS_PASSENGER_H
#include <string>
class Passenger{
    std::string name;
    int id;
public:
    Passenger(const int id, const std::string& name);
    int getId() const;
    std::string getName() const;
    void setName(const std::string& name);

    void setId(const int & passengerId) ;

    void print(const std::string& msg) const ;

};
#endif //RMS_PASSENGER_H


==================================================
FILE PATH: .\include\models\SeatAllocator.h
==================================================

//
// Created by Omar on 11/19/2025.
//


#ifndef RMS_SEATALLOCATOR_H
#define RMS_SEATALLOCATOR_H

#include <unordered_map>
#include <vector>
#include <queue>
#include <set>
#include "../structures/stack.h"
#include <string>
#include<memory>
#include <functional>

class SeatAllocator{
    std::set<int> availableSeats;
    std::queue<int> waitingList;
    std::set<int> waitingSet;              // prevent duplicate waiting entries
    std::unordered_map<int, int> allocatedSeats;
    stack<int> cancelledSeats;
    int totalSeats ;
public:

    SeatAllocator( int totalSeats = 10);
    // for copying
    std::unique_ptr<SeatAllocator> clone() const;
    SeatAllocator(const SeatAllocator& other);
    SeatAllocator& operator=(const SeatAllocator& other);

    void addSeats(int seats);
    void changeTotalSeats(int newTotalSeats);

    int freeSeat( int seatNumber);
    int allocateSeat( int passengerId);
    int processWaitingList(int seatsToAdd, std::function<void(int)> bookCallback) ;


    int getAvailableSeatCount() const;
    int getAllocatedSeatCount() const;
    int getTotalSeats() const;
    int getWaitingListSize()const;

    std::queue<int> getWaitingList()const;

    bool hasAvailableSeats() const;

    void printStatus() const;

};
#endif //RMS_SEATALLOCATOR_H


==================================================
FILE PATH: .\include\models\Ticket.h
==================================================

//
// Created by Omar on 11/19/2025.
//

#ifndef RMS_TICKET_H
#define RMS_TICKET_H

#include "Passenger.h"

enum Status
{
    booked,
    cancelled
};
class Ticket
{
    int id;
    int ticketSeat;
    int trainId;
    Passenger passenger;
    Status status;

public:
public:
    Ticket(const int id,const int seat, const int trainId,Passenger  p);
    int getId() const;
    int getSeat() const;
    Status getStatus() const;
    void setStatus(const Status& s);
    int getTrainId() const;
    Passenger getPassenger() const;
    void setId(const int newId);
    void print(const std::string& msg) const ;

};
#endif // RMS_TICKET_H


==================================================
FILE PATH: .\include\models\Train.h
==================================================

#ifndef RMS_TRAIN_H
#define RMS_TRAIN_H

#include "SeatAllocator.h"
#include <string>

class Train {
private:
    int id;
    std::string name;
    int totalSeats;
    std::unique_ptr<SeatAllocator> seatAllocator;

public:
    // Constructor
    Train(const int id, const std::string& name, const int totalSeats = 10);
    ~Train() = default;


    //  copy operations for unique ptr
    std::unique_ptr<Train> clone() const ;
    Train(const Train& other);
    Train& operator=(const Train& other);

    // move operations
    Train(Train&&) = default;
    Train& operator=(Train&&) = default;

    int getTrainId() const;
    std::string getTrainName() const;
    SeatAllocator* getSeatAllocator() const;

    void setTrainName(const std::string& name);
    void setTrainId(int trainId);
    void setSeats(int seats);
    void addSeats(int seats);

    bool hasAvailableSeats() const;

    int getTotalSeats() const;
    void trainStatus() const ;
    void print(const std::string& msg) const ;

};

#endif //RMS_TRAIN_H

==================================================
FILE PATH: .\include\Repo\InMemoryPassengerRepository.h
==================================================

//
// Created by Omar on 11/19/2025.
//

#ifndef RMS_INMEMORYPASSENGERREPOSITORY_H
#define RMS_INMEMORYPASSENGERREPOSITORY_H

#include <vector>
#include <map>
#include <optional>

#include "../models/Passenger.h"
#include "IPassengerRepository.h"

class InMemoryPassengerRepository : public IPassengerRepository
{
private:
    std::map<int, Passenger> passengers;
    int next_id = 1;
public:
    std::optional<Passenger> getPassenger(const int& passengerId) override;
    bool deletePassenger(const int& passengerId) override;
    void save( Passenger& passenger) override;
    std::vector<Passenger> getAllPassengers() override;
    void clear() override;
};
#endif // RMS_INMEMORYPASSENGERREPOSITORY_H


==================================================
FILE PATH: .\include\Repo\InMemoryTicketRepository.h
==================================================

//
// Created by Omar on 11/19/2025.
//

#ifndef RMS_INMEMORYTICKETREPOSITORY_H
#define RMS_INMEMORYTICKETREPOSITORY_H

#include <map>
#include <vector>
#include <optional>

#include "ITicketRepository.h"
#include "../models/Ticket.h"

class InMemoryTicketRepository : public ITicketRepository
{
private:
    std::map<int, Ticket> tickets;
    int next_id = 1;

public:
    InMemoryTicketRepository() = default;
    ~InMemoryTicketRepository() override = default;
    std::optional<Ticket> getTicketByTrainAndPassenger(int trainId, int passengerId) override;
    bool deleteTicket(int ticketId) override;
    void save(Ticket& ticket) override;
    std::vector<Ticket> getAllTickets() override;
    std::optional<Ticket> getTicketById(int ticketId) override;
    void clear() override;
};
#endif // RMS_INMEMORYTICKETREPOSITORY_H


==================================================
FILE PATH: .\include\Repo\InMemoryTrainRepository.h
==================================================

#ifndef RMS_INMEMORYTRAINREPOSITORY_H
#define RMS_INMEMORYTRAINREPOSITORY_H

#include "../models/Train.h"
#include "ITrainRepository.h"
#include <map>
#include <optional>


class InMemoryTrainRepository : public ITrainRepository {
private:
    std::map<int, Train> trains;
    int next_id = 1;

public:
    InMemoryTrainRepository() = default;
    ~InMemoryTrainRepository() override = default;

    std::vector<Train> getAllTrains() const override;
    bool deleteTrain(int trainId) override;
    void  save( Train& newTrain) override;
    std::optional<Train> getTrainById(const int& trainId) const  override;
    void clear() override;
};

#endif

==================================================
FILE PATH: .\include\Repo\IPassengerRepository.h
==================================================

//
// Created by Omar on 11/19/2025.
//

#ifndef RMS_IPASSENGERREPOSITORY_H
#define RMS_IPASSENGERREPOSITORY_H

#include <vector>
#include "../models/Passenger.h"
#include <optional>

class IPassengerRepository
{
public:
    virtual std::optional<Passenger> getPassenger(const int& passengerId) = 0;
    virtual bool deletePassenger(const int& passengerId) = 0;
    virtual void save( Passenger& passenger) = 0;
    virtual std::vector<Passenger> getAllPassengers() = 0;
    virtual void clear() = 0;

    virtual ~IPassengerRepository() = default;
};
#endif // RMS_IPASSENGERREPOSITORY_H


==================================================
FILE PATH: .\include\Repo\ITicketRepository.h
==================================================

//
// Created by Omar on 11/19/2025.
//

#ifndef RMS_ITICKETREPOSITORY_H
#define RMS_ITICKETREPOSITORY_H

#include <vector>
#include <optional>

#include "../models/Ticket.h"

class ITicketRepository
{
public:
    virtual std::optional<Ticket> getTicketByTrainAndPassenger(int trainId, int passengerId) = 0;
    virtual bool deleteTicket(int ticketId) = 0;
    virtual void save(Ticket& ticket) = 0;
    virtual std::vector<Ticket> getAllTickets() = 0;
    virtual std::optional<Ticket> getTicketById(int) = 0;
    virtual void clear() = 0;

    virtual ~ITicketRepository() = default;
};
#endif // RMS_ITICKETREPOSITORY_H


==================================================
FILE PATH: .\include\Repo\ITrainRepository.h
==================================================

#ifndef RMS_ITRAINREPOSITORY_H
#define RMS_ITRAINREPOSITORY_H

#include "../models/Train.h"
#include <vector>
#include <optional>

class ITrainRepository {
public:
    virtual std::vector<Train> getAllTrains() const = 0;
    virtual bool deleteTrain(int) = 0;
    virtual void save(Train&) = 0;
    virtual std::optional<Train> getTrainById(const int& trainId) const   = 0;
    virtual void clear() = 0;
    virtual ~ITrainRepository() = default;
};

#endif

==================================================
FILE PATH: .\include\Services\PassengerService.h
==================================================

//
// Created by Omar on 11/19/2025.
//

#ifndef RMS_PASSENGERSERVICE_H
#define RMS_PASSENGERSERVICE_H

#include <vector>
#include "../models/Passenger.h"
#include "../Repo/IPassengerRepository.h"

class PassengerService
{
private:
    IPassengerRepository *passengerRepository;

public:
    PassengerService(IPassengerRepository *repo);
    std::optional<Passenger> getPassenger(const int& passengerId);
    std::vector<Passenger> getAllPassengers();
    Passenger createPassenger(const std::string& name);
    Passenger updatePassenger(const int passengerId , const std::string& name);
    bool deletePassenger(const int& passengerId);
    Passenger find_or_create_passenger(const std::string& name);
};
#endif // RMS_PASSENGERSERVICE_H


==================================================
FILE PATH: .\include\Services\TicketService.h
==================================================

//
// Created by Omar on 11/19/2025.
//

#ifndef RMS_TICKETSERVICE_H
#define RMS_TICKETSERVICE_H

#include "../Repo/ITicketRepository.h"
#include "TrainService.h"
#include "PassengerService.h"

class TicketService
{
private:
    ITicketRepository *ticketRepository;
    TrainService *trainService;
    PassengerService *passengerService;


public:
    TicketService(ITicketRepository *repo , TrainService* ts,PassengerService* ps);
    std::optional<Ticket> getTicket(const int& ticketId);
    std::vector<Ticket> getAllTickets();
    Ticket updateTicket(Ticket &t);

    std::optional<Ticket> getTicketByTrainAndPassenger(const int& trainId, const int& passengerId);
    Ticket bookTicket(const int& trainId, const int& passengerId);
    void cancelTicket(const int& ticketId);
};
#endif // RMS_TICKETSERVICE_H


==================================================
FILE PATH: .\include\Services\TrainService.h
==================================================

//
// Created by Omar on 11/19/2025.
//

#ifndef RMS_TRAINSERVICE_H
#define RMS_TRAINSERVICE_H

#include "../Repo/ITrainRepository.h"
#include <optional>

class TrainService{
private:
    ITrainRepository* trainRepository;
public:
    TrainService(ITrainRepository* repo) ;
    ~TrainService();
    //crud
    std::optional<Train> getTrain(const int&);
    std::vector<Train> getAllTrains();
    Train createTrain(const std::string& name,int seats);
    Train updateTrain(const int& id , const std::string& name,int seats = 0);
    bool deleteTrain(int trainId);

    //seats
    Train addSeats(const int trainId , const int seats);
    Train addSeats(const std::string name  , const int seats);
    // status
    void printStatus(int trainId);
    bool isAvailbleSeat(int trainId);
    void save(Train & train);
};
#endif //RMS_TRAINSERVICE_H


==================================================
FILE PATH: .\include\structures\stack.h
==================================================

#ifndef RMS_STACK_H
#define RMS_STACK_H

#include <stdexcept>

template <class Type>
struct Node {
    Type data;
    Node<Type>* link;
    Node(const Type& val =-99999, Node<Type>* link_ptr= nullptr) : data(val), link(link_ptr) {}
};

template <class Type>
class stack {
private:
    Node<Type>* topPtr;
    int counter;

public:
    stack() : topPtr(nullptr), counter(0) {}

    ~stack() {
        while (!empty()) pop();
    }

    void push(const Type& value) {
        topPtr = new Node<Type>(value, topPtr);
        ++counter;
    }
    //copy constructor
    stack(const stack& other);
    // assignment overloading
    stack& operator=(stack other);
    friend void swap(stack<Type>& first, stack<Type>& second)  {
        using std::swap;
        swap(first.topPtr, second.topPtr);
        swap(first.counter, second.counter);
    }
    void pop() {
        if (empty())
            throw std::runtime_error("Stack underflow: pop() on empty stack");

        Node<Type>* temp = topPtr;
        topPtr = topPtr->link;
        delete temp;
        --counter;
    }

    Type& top() {
        if (empty())
            throw std::runtime_error("Stack underflow: top() on empty stack");

        return topPtr->data;
    }
    const Type& top() const {
        if (empty())
            throw std::runtime_error("Stack underflow: top() on empty stack");
        return topPtr->data;
    }
    bool empty() const {
        return topPtr == nullptr;
    }

    int size() const {
        return counter;
    }
};
// --- Implementation of Copy Constructor ---
template <class Type>
stack<Type>::stack(const stack& other) : topPtr(nullptr), counter(0) {
    if (other.empty()) {
        return; //empty stack
    }

    Node<Type>* otherCurrent = other.topPtr;
    Node<Type>* lastNewNode = nullptr;

    Node<Type>* newNode = new Node<Type>();

    newNode->data = otherCurrent->data;
    newNode->link = nullptr;

    this->topPtr = newNode;
    lastNewNode = newNode;

    otherCurrent = otherCurrent->link;
    this->counter = 1;

    // Copy the rest of the nodes
    while (otherCurrent != nullptr) {
        Node<Type>* newNode = new Node<Type>();
        newNode->data = otherCurrent->data;
        newNode->link = nullptr;

        lastNewNode->link = newNode;
        lastNewNode = newNode;

        otherCurrent = otherCurrent->link;
        this->counter++;
    }

}

template <class Type>
stack<Type>& stack<Type>::operator=(stack<Type> other) {
    swap(*this, other);
    return *this;
}

#endif // RMS_STACK_H


==================================================
FILE PATH: .\include\utils\helpers.h
==================================================

//
// Created by Omar on 11/24/2025.
//

#ifndef RMS_HELPERS_H
#define RMS_HELPERS_H
#include <string>
#include <vector>
#include "models/Train.h"
#include "models/Passenger.h"
#include "models/Ticket.h"

// string validation
std::string toLowerCase(std::string word);
std::string trim(const std::string &str);
bool isValidName(const std::string& name);
// string concat
std::string combineString(const std::vector<std::string>& args, int start);
std::string combineString(const std::vector<std::string>& args, int start , int end);
bool compareString(const std::string& str1 , const std::string& str2);
// integer helpers
bool isInteger(const std::string& str);
int parseInt(const std::string& arg , const std::string& argName);

// print msg

void printCurrentDate();

#endif //RMS_HELPERS_H


==================================================
FILE PATH: .\src\CLIController.cpp
==================================================

//
// Created by Omar on 11/25/2025.
//

#include <sstream>
#include <iomanip> // required for setw()
#include <limits> // for numeric_limits
#include <cstdlib> // Required for system()

#include "CLIController.h"
#include "utils/helpers.h" // parseInt , trim
#include "RMSCommand.h"

using std::cout ;
using std::endl;
using std::string;
using std::cin;

//enums [MainCmd instead of RMSCommand::MainCmd
using MainCmd = RMSCommand::MainCmd;
using TrainCmd = RMSCommand::TrainCmd;
using PassengerCmd = RMSCommand::PassengerCmd;
using TicketCmd = RMSCommand::TicketCmd;
using SystemCmd = RMSCommand::SystemCmd;
// getters
// pointer fo functions
auto getMainCmd =  RMSCommand::getMainCmd;
auto getTrainCmd =  RMSCommand::getTrainCmd;
auto getPassengerCmd=  RMSCommand::getPassengerCmd;
auto getTicketCmd = RMSCommand::getTicketCmd;
auto getSystemCmd =RMSCommand::getSystemCmd;


vector<string> CLIController::tokenize(const string &args) { // split the sentence to args
    stringstream ss(args);
    vector<string> tokens ;
    string token;
    while(ss >> token){
        tokens.push_back(token);
    }
    return tokens;
}
void CLIController::waitUser(){
//    cin.ignore(numeric_limits<streamsize>::max(), '\n'); //  clear buffer to ingnore '\n'
    cout << "Press Enter to exit...";
    cin.get(); // wait for Enter
}
string CLIController::readLine() {
    string line;
    getline(cin ,line);
    return line;
}

void CLIController::show_help() {
    cout << "\n=================================================\n";
    cout << "        RMS - Railway Management System          \n";
    cout << "=================================================\n\n";

    cout << "Usage: <command> [arguments]\n\n";

    cout << "---------------------- Commands ----------------------\n\n";

    // ======================== TRAIN ========================
    cout << "train:\n";
    cout << "   train list                                     - Show all trains\n";
    cout << "   train add <name> <seats>                       - Add a new train\n";
    cout << "   train delete <id>                              - Remove a train\n";
    cout << "   train update <id> <seats> <name>               - Update a train\n";
    cout << "   train seats add <id> <count>                   - Increase seat count\n";
    cout << "   train availability <id>                        - Show seat status\n\n";
    cout << "   train status <id>                              - Show full train status\n\n";

    // ====================== PASSENGER ======================
    cout << "passenger:\n";
    cout << "   passenger list                                 - Show all passengers\n";
    cout << "   passenger add <name>                           - Add a passenger\n";
    cout << "   passenger delete <id>                          - Remove a passenger\n";
    cout << "   passenger update <id> <newName>                - Rename passenger\n\n";

    // ======================== TICKET ========================
    cout << "ticket:\n";
    cout << "   ticket list                                    - Show all tickets\n";
    cout << "   ticket book <trainId> <passengerId|name>       - Book a ticket\n";
    cout << "   ticket cancel <ticketId>                       - Cancel a ticket\n\n";

    // ========================= SYSTEM ========================
    cout << "system:\n";
    cout << "   help | h | ?                                   - Show help menu\n";
    cout << "   exit | quit | q                                - Exit program\n";
    cout << "   clear                                          - Clear Screen\n";

    cout << "--------------------------------------------------------\n\n";
}



void CLIController::list_trains() {
    const auto trains = facade->listTrains();
    if(trains.empty())
        cout << "No trains avialble \n";
    cout << "\n======== Trains ==========\n";
    cout << left << setw(6) << "ID"
         << left << setw(20) << "Name"
         << left << setw(20) << "Status"
         << "\n";

    for (auto &train : trains) {

        int seats = train.getSeatAllocator()->getAvailableSeatCount();

        string status = (seats == 0)
                        ? "Full"
                        : to_string(seats) + " seats available";

        cout << left << setw(6)  << train.getTrainId()
             << left << setw(20) << train.getTrainName()
             << left << setw(20) << status
             << "\n";
    }

}

void CLIController::list_passengers() {
    const auto passengers = facade->listPassengers();
    if(passengers.empty())
        cout << "No passengers avialble \n";
    cout << "\n======== Passengers ==========\n\n";
    cout << left << setw(6) << "ID"
         << left << setw(20) << "Name" << "\n";

    for (auto &passenger : passengers) {
        cout << left << setw(6) << passenger.getId()
             << left << setw(20) << passenger.getName()
             << "\n";
    }
}

void CLIController::list_tickets() {
    const auto tickets = facade->listTickets();
    if(tickets.empty())
        cout << "No tickets available \n";
    cout << "\n====================================== Tickets =======================================\n";

    cout << left
         << setw(8)  << "id"
         << setw(12) << "trainId"
         << setw(15) << "ticket_seat"
         << setw(15) << "passengerId"
         << setw(20) << "passenger_name"
         << setw(15) << "status"
         << endl;

    for (auto &ticket : tickets) {
        cout << left
             << setw(8)  << ticket.getId()
             << setw(12) << ticket.getTrainId()
             << setw(15) << ticket.getSeat()
             << setw(15) << ticket.getPassenger().getId()
             << setw(20) << ticket.getPassenger().getName()
             << setw(15) << ((ticket.getStatus() == booked) ? "Booked" : "Cancelled")
             << endl;
    }
}





CLIController::CLIController(RMSFacade *facade) :facade(facade){

}
void sayWelcome(){
    cout << "===============================================\n";
    cout << "  Welcome to the Railway Reservation System  \n";
    cout << "===============================================\n";
    cout << "Type 'help' to show the list of commands.\n";
    cout << "-----------------------------------------------\n";
    printCurrentDate();
    cout << "-----------------------------------------------\n";
    cout << "Author : Dangerous Team .\n";
    cout << "Under the supervision of Dr.Iman and Eng/Mariem Abdelrahman.\n\n";
}
void CLIController::run() {
    clear();
    sayWelcome();
//lambad function
    auto printUsage = [](MainCmd cmd) {
        switch(cmd) {
            case MainCmd::TRAIN:      cout << "Usage: train <list|add|delete|update|seats|availability>\n"; break;
            case MainCmd::PASSENGER:  cout << "Usage: passenger <list|add|delete|update>\n"; break;
            case MainCmd::TICKET:     cout << "Usage: ticket <list|book|cancel>\n"; break;
            default:                  cout << "Unknown command. Type 'help' for available commands.\n";
        }
    };

    while (true) {
        cout << "\ncmd > ";
        string line = readLine();
        vector<string> args = tokenize(line);

        if (args.empty()) {
            cout << "Please enter a command. Type 'help' for available commands.\n";
            continue;
        }

        MainCmd mainCmd = getMainCmd(args[0]);

        switch (mainCmd) {

            // ===================== TRAIN =====================
            case MainCmd::TRAIN: {
                if (args.size() < 2) { printUsage(mainCmd); break; }
                TrainCmd tCmd = getTrainCmd(args[1]);
                switch (tCmd) {
                    case TrainCmd::LIST:         list_trains(); break;
                    case TrainCmd::ADD:          add_train(args); break;
                    case TrainCmd::DELETE:       delete_train(args); break;
                    case TrainCmd::UPDATE:       update_train(args); break;
                    case TrainCmd::SEATS_ADD:    add_seats(args); break;
                    case TrainCmd::AVAILABILITY: get_train_availability(args); break;
                    case TrainCmd::STATUS: get_train_status(args); break;

                    default: cout << "Invalid train command.\n";
                }
                break;
            }

                // ===================== PASSENGER =====================
            case MainCmd::PASSENGER: {
                if (args.size() < 2) { printUsage(mainCmd); break; }
                PassengerCmd pCmd = getPassengerCmd(args[1]);
                switch (pCmd) {
                    case PassengerCmd::LIST:   list_passengers(); break;
                    case PassengerCmd::ADD:    add_passenger(args); break;
                    case PassengerCmd::DELETE: delete_passenger(args); break;
                    case PassengerCmd::UPDATE: update_passenger(args); break;
                    default: cout << "Invalid passenger command.\n";
                }
                break;
            }

                // ===================== TICKET =====================
            case MainCmd::TICKET: {
                if (args.size() < 2) { printUsage(mainCmd); break; }
                TicketCmd tkCmd = getTicketCmd(args[1]);
                switch (tkCmd) {
                    case TicketCmd::LIST:   list_tickets(); break;
                    case TicketCmd::BOOK:   book_ticket(args); break;
                    case TicketCmd::CANCEL: cancel_ticket(args); break;
                    default: cout << "Invalid ticket command.\n";
                }
                break;
            }

                // ===================== SYSTEM =====================
            case MainCmd::SYSTEM: {
                SystemCmd sCmd = getSystemCmd(args[0]);
                switch (sCmd) {
                    case SystemCmd::HELP: show_help(); break;
                    case SystemCmd::CLEAR :
                        clear();
                        sayWelcome();
                        break;
                    case SystemCmd::EXIT:
                        cout << "Goodbye!\n";
                        waitUser();
                        return;
                    default: cout << "Invalid system command.\n";
                }
                break;
            }

                // ===================== UNKNOWN =====================
            default:
                cout << "Unknown command. Type 'help' for available commands.\n";
        }
    }
}

void CLIController::add_passenger(const vector<string> &args) {
//add passenger <name>
    if(args.size() < 3) {
        cout << "Usage: passenger add  <name>\n";

        return;
    }
     string name;
    try{
        name = combineString(args,2);
        auto p = facade->addPassenger(name);
        p.print("--- Passenger Added Successfully ---\n");

    } catch(const exception& e) {
        cout << "ERROR: Could not add passenger " << name << ". " << "\n";
        cout << "Details: " << e.what() << "\n";

    }
}

void CLIController::get_train_availability(const vector<string> &args) {
//    train availability <train_id>
    if(args.size() < 3) {
        cout << "Usage: train availability <train_id>\n";
        return;
    }
    int id ;
    try{
        id = parseInt(args[2],"id");
        bool isAvailable = facade->getTrainAvailability(id);
        if(!isAvailable)
            cout << "This train is full \n";
        else
            cout << "This train is available \n";

    }catch(const exception& e){
        cout << "Error while get_train_availability : " << e.what() << endl;
        return;
    }



}
void CLIController::clear(){
    system("cls");
}

void CLIController::add_train(const vector<string> &args) {
    if(args.size() < 4) {
        cout << "Usage: train add  <name> <seats> \n";
        return;
    }
    const string& seatArgs = args[3];
    string name;
    try {
        const int &seats = parseInt(seatArgs,"seats");
        name = combineString(args,2,-1);

        auto t = facade->addTrain(name,seats);
        t.print("--- Train Added Successfully ---\n");

    }
    catch (const exception& e) {
        cout << "ERROR: Could not add train " << name << ". " << e.what() << "\n";
    }
}
void CLIController::book_ticket(const vector<string> &args) {
    if(args.size() < 4) { // book ticket <train_id> <passenger_name>
        cout << "Usage: ticket book  <train_id> <passenger_name>\n";
        return;
    }

    const string& trainIdArg = args[2];
     string passengerName ;

    try {
        int trainId = parseInt(trainIdArg, "train ID");
        passengerName = combineString(args,3);

        auto t = facade->bookTicket(trainId, passengerName);
        t.print("--- Ticket Booked Successfully ---\n");

    } catch (const exception& e) {
        cout << "ERROR: Could not book ticket for " << passengerName << " on Train ID " << trainIdArg << ".\n";
        cout << "Details: " << e.what() << "\n";
    }
}

void CLIController::cancel_ticket(const vector<string> &args) {
    if(args.size() < 3) { // cancel ticket <ticket_id>
        cout << "Usage: ticket cancel  <ticket_id>\n";
        return;
    }

    const string& ticketIdArg = args[2];

    try {
        int ticketId = parseInt(ticketIdArg, "ticket ID");
        facade->cancelTicket(ticketId);

        cout << "--- Ticket Cancelled Successfully ---\n";
        cout << "Ticket ID: " << ticketId << " has been cancelled.\n";
        cout << "-------------------------------------\n";

    } catch (const exception& e) {
        // Error Message
        cout << "ERROR: Could not cancel ticket " << ticketIdArg << ".\n";
        cout << "Details: " << e.what() << "\n";
    }
}

void CLIController::update_train(const vector<string> &args) {

    if(args.size() < 5) {
        cout << "Usage: train update  <train_id> <name> <seats>\n";
        return;
    }

    const string& tarinIdArg = args[2];
    const string& seatArg = args[4];
    try {
        int trainId = parseInt(tarinIdArg , "train id");
        int seats = parseInt(seatArg, "seat number");
        string name = combineString(args,3,-1);
        auto t =facade->updateTrain(trainId , name , seats);

        t.print( "------ Train updated successfully ------ \n");


    } catch (const exception& e) {
        cout << "ERROR: Could not updateTrain " << tarinIdArg << ".\n";
        cout << "Details: " << e.what() << "\n";
    }
}

void CLIController::add_seats(const vector<string> &args) {
    if(args.size() < 5) {
        cout << "Usage: train seats  <trainId|trainName> <seats>\n";
        return;
    }

    const string& trainArg = args[2];
    const string& seatArg = args[3];
    try {
        int seats = parseInt(seatArg, "seat number");
        // add seats trainId
        if(isInteger(trainArg)){
            int trainId = parseInt(trainArg , "train id");
            const auto &t = facade->addSeats(trainId, seats);
            t.print( "--- Train updated successfully. --- \n");

        }else{  // add seats trainName
            string name = combineString(args,2,-1); // until last field
            const auto &t =facade->addSeats(name, seats);
            t.print( "Train updated successfully.\n");

        }



    } catch (const exception& e) {
        cout << "ERROR: Could not update Train " << trainArg << ".\n";
        cout << "Details: " << e.what() << "\n";
    }
}

void CLIController::update_passenger(const vector<string> &args) {
    if(args.size() < 5) {
        cout << "Usage: passenger update <passengerId> <newName>\n";
        return;
    }

    const string& passengerArg = args[2];
    try {
        int passengerId = parseInt(passengerArg , "passenger Id");
        string name = combineString(args,3);
        auto p = facade->updatePassenger(passengerId, name);
        p.print( "------ Passenger updated successfully ------ \n");

    } catch (const exception& e) {
        cout << "ERROR: Could not update passenger " << passengerArg<< ".\n";
        cout << "Details: " << e.what() << "\n";
    }
}

void CLIController::delete_train(const vector<string> &args) {
    if(args.size() < 3) {
        cout << "Usage: train delete  <trainId>\n";
        return;
    }
    const string& trainArg = args[2];
    try {
        int trainId = parseInt(trainArg,"train Id");
        facade->deleteTrain(trainId);
        cout << "train with id " << trainId << " deleted successfully \n";
    }catch (const exception& e) {
        cout << "ERROR: Could not delete train" << ".\n";
        cout << "Details: " << e.what() << "\n";
    }
}

void CLIController::delete_passenger(const vector<string> &args) {
    if(args.size() < 3) {
        cout << "Usage: passenger delete  <passengerId>\n";
        return;
    }
    const string& passengerArg = args[2];
    try {
        int passengerId = parseInt(passengerArg,"train Id");
        facade->deletePassenger(passengerId);
        cout << "passenger with id " << passengerId << " deleted successfully \n";
    }catch (const exception& e) {
        cout << "ERROR: Could not delete passenger" << ".\n";
        cout << "Details: " << e.what() << "\n";
    }
}

void CLIController::get_train_status(const vector<string> &args) {
    if(args.size() < 3) {
        cout << "Usage: train status  <trainId>\n";
        return;
    }
    const string& trainArg = args[2];
    try {
        int trainId = parseInt(trainArg,"train Id");
        facade->trainStatus(trainId);
    }catch (const exception& e) {
        cout << "ERROR: could not print train data with id : " << trainArg << ".\n";
        cout << "Details: " << e.what() << "\n";
    }
}




==================================================
FILE PATH: .\src\main.cpp
==================================================

#include "models/SeatAllocator.h"
#include <iostream>
#include "RMSApp.h"



int main(int argc, char **argv)
{
    RMSApp app;
    app.run();
    return 0;
}

==================================================
FILE PATH: .\src\RMSApp.cpp
==================================================

//
// Created by Omar on 12/1/2025.
//

#include "RMSApp.h"

RMSApp::RMSApp() {
    startupManager = std::make_unique<StartupManager>();

    auto facade = startupManager->buildFacade(); // build the app with startup manager

    cli = std::make_unique<CLIController>(facade);// pass facade to startup manager
}

void RMSApp::run() {
    cli->run();
}


==================================================
FILE PATH: .\src\RMSCommand.cpp
==================================================

//
// Created by Omar on 12/1/2025.
//
#include "RMSCommand.h"

RMSCommand::MainCmd RMSCommand::getMainCmd(const string &cmd){
    static const unordered_map<string, MainCmd> table = {
            {"train", MainCmd::TRAIN},
            {"passenger", MainCmd::PASSENGER},
            {"ticket", MainCmd::TICKET},
            {"help", MainCmd::SYSTEM},
            {"h", MainCmd::SYSTEM},
            {"?", MainCmd::SYSTEM},
            {"exit", MainCmd::SYSTEM},
            {"quit", MainCmd::SYSTEM},
            {"q", MainCmd::SYSTEM},
            {"clear", MainCmd::SYSTEM},


    };
    auto it = table.find(cmd);
    return (it != table.end()) ? it->second : MainCmd::UNKNOWN;
}

RMSCommand::TrainCmd RMSCommand::getTrainCmd(const string &sub) {
    static const unordered_map<string, TrainCmd> table = { // static map to initializing only once
            {"list", TrainCmd::LIST},
            {"add", TrainCmd::ADD},
            {"delete", TrainCmd::DELETE},
            {"update", TrainCmd::UPDATE},
            {"seats", TrainCmd::SEATS_ADD},
            {"availability", TrainCmd::AVAILABILITY},
            {"status" , TrainCmd::STATUS}
    };
    auto it = table.find(sub);
    return (it != table.end()) ? it->second : TrainCmd::UNKNOWN;
}
RMSCommand::PassengerCmd RMSCommand::getPassengerCmd(const string &sub)  {
    static const unordered_map<string, PassengerCmd> table = {
            {"list", PassengerCmd::LIST},
            {"add", PassengerCmd::ADD},
            {"delete", PassengerCmd::DELETE},
            {"update", PassengerCmd::UPDATE}
    };
    auto it = table.find(sub);
    return (it != table.end()) ? it->second : PassengerCmd::UNKNOWN;
}
RMSCommand::TicketCmd RMSCommand::getTicketCmd(const string &sub) {
    static const unordered_map<string, TicketCmd> table = {
            {"list", TicketCmd::LIST},
            {"book", TicketCmd::BOOK},
            {"cancel", TicketCmd::CANCEL}
    };
    auto it = table.find(sub);
    return (it != table.end()) ? it->second : TicketCmd::UNKNOWN;
}


RMSCommand::SystemCmd RMSCommand::getSystemCmd(const string &cmd) {
    if(cmd == "help" || cmd == "h" || cmd == "?") return SystemCmd::HELP;
    if(cmd == "exit" || cmd == "quit" || cmd == "q") return SystemCmd::EXIT;
    if(cmd == "clear") return SystemCmd::CLEAR;

    return SystemCmd::UNKNOWN;
}


==================================================
FILE PATH: .\src\RMSFacade.cpp
==================================================

//
// Created by Omar on 11/21/2025.
//
#include "RMSFacade.h"
#include <stdexcept> //for run time exception
#include <iostream>
#include "utils/helpers.h"

RMSFacade::RMSFacade(TrainService *ts, TicketService *tks, PassengerService *ps)
{
    this->trainService = ts;
    this->ticketService = tks;
    this->passengerService = ps;
}

// ============ Trains =============
std::vector<Train> RMSFacade::listTrains()
{
    return trainService->getAllTrains();
}

Train RMSFacade::addTrain(std::string name, int totalSeats)
{
    name = trim(name);
    if (name.empty())
    {
        throw std::invalid_argument("Train name cannot be empty");
    }

    if (totalSeats <= 0)
    {
        throw std::invalid_argument("Total seats must be greater than 0");
    }

    return trainService->createTrain(name, totalSeats);
}

std::optional<Train> RMSFacade::getTrain(int trainId)
{
    return trainService->getTrain(trainId);
}
// ============ Passengers =============

std::optional<Passenger> RMSFacade::getPassenger(int passengerId)
{
    return passengerService->getPassenger(passengerId);
}

Passenger RMSFacade::addPassenger(const std::string& name)
{
    if (!isValidName(name))
        throw std::invalid_argument("Passenger name cannot be empty");
    std::string trimmedName = trim(name);
    
    return passengerService->createPassenger(trimmedName);
}

std::vector<Ticket> RMSFacade::listTickets()
{
    return ticketService->getAllTickets();
}

std::vector<Passenger> RMSFacade::listPassengers()
{
    return passengerService->getAllPassengers();
}

// ============ Tickets =============
Ticket RMSFacade::bookTicket(int trainId, const std::string &passengerName)
{
    // input validation
    if (trainId <= 0)
        throw std::invalid_argument("Train ID must be greater than 0");

    if (!isValidName(passengerName))
        throw std::invalid_argument("Passenger name cannot be empty");
    std::string trimmedName = trim(passengerName);


    Passenger ps = passengerService->find_or_create_passenger(passengerName);
    return ticketService->bookTicket(trainId, ps.getId());

}

void RMSFacade::cancelTicket(int ticketId)
{
    // input validation

    if (ticketId <= 0)
        throw std::invalid_argument("Ticket ID must be greater than 0");

    ticketService->cancelTicket(ticketId);


}

bool RMSFacade::getTrainAvailability(int trainId)
{
    return  trainService->isAvailbleSeat(trainId);

}

Train RMSFacade::updateTrain(int trainId, const std::string& name, int seats) {
    // validation
    if (trainId <= 0) throw std::invalid_argument("Train ID must be > 0");
    std::string trimmedName = trim(name);
    if (!isValidName(trimmedName)) throw std::invalid_argument("Train name cannot be empty");
    if (seats < 0) throw std::invalid_argument("Seats cannot be negative");

    // current Train
    auto currentTrainOpt = trainService->getTrain(trainId);
    if (!currentTrainOpt.has_value())
        throw std::out_of_range("Train with id " + std::to_string(trainId) + " does not exist");

    Train currentTrain = currentTrainOpt.value();
    int currentSeats = currentTrain.getTotalSeats();

    // update train
    Train updatedTrain = trainService->updateTrain(trainId, trimmedName, seats);

    // process waiting
    int seatsAdded = seats - currentSeats;
    if (seatsAdded > 0) {
        auto cb =[this, trainId](int passengerId){ // access to this object& trainId + passengerId as argument
            ticketService->bookTicket(trainId, passengerId);
        };
        updatedTrain.getSeatAllocator()->processWaitingList(seatsAdded,cb);

        // Save updated train after processing waiting list
        trainService->save(updatedTrain);
    }

    return updatedTrain;
}

Train RMSFacade::addSeats(int trainId, int seats)
{
    return trainService->addSeats(trainId, seats);
}

Train RMSFacade::addSeats(const std::string &name, int seats)
{
    return trainService->addSeats(name, seats);
}

Passenger RMSFacade::updatePassenger(int passengerId, const std::string &name)
{
    auto passenger = passengerService->getPassenger(passengerId);
    if (!passenger.has_value())
        throw std::out_of_range("passenger with id : " + std::to_string(passengerId) + " does not exist ");
    // update passenger
    auto newPassenger = passengerService->updatePassenger(passengerId, name);
    // update tickets with this id
    auto tickets = ticketService->getAllTickets();
    for (auto &t : tickets)
    {
        if (compareString(t.getPassenger().getName(), passenger->getName()))
        {
            t.getPassenger().setName(name);
            ticketService->updateTicket(t);
        }
    }

    return newPassenger;
}

void RMSFacade::deleteTrain(int trainId)
{
    bool deleted = trainService->deleteTrain(trainId);
    if (!deleted)
        throw std::out_of_range("failed to delete train with id : " + std::to_string(trainId));
}

void RMSFacade::deletePassenger(int passengerId)
{
    bool deleted = passengerService->deletePassenger(passengerId);
    if (!deleted)
        throw std::out_of_range("failed to delete passenger with id : " + std::to_string(passengerId));
}

void RMSFacade::trainStatus(int trainId) {
    trainService->printStatus(trainId);
}


==================================================
FILE PATH: .\src\StartupManager.cpp
==================================================

//
// Created by Omar on 11/25/2025.
//
#include "StartupManager.h"
#include "Repo/InMemoryTrainRepository.h"
#include "Repo/InMemoryTicketRepository.h"
#include "Repo/InMemoryPassengerRepository.h"
void loadMockData(RMSFacade* facade) {
    // ---- Add Trains ----
    facade->addTrain("Alex NightLine", 30);
    facade->addTrain("Luxor Premium", 40);
    facade->addTrain("Cairo Express", 25);
    facade->addTrain("Aswan Sleeper", 20);
    facade->addTrain("Mediterranean Star", 35);

    // ---- Add Passengers ----
    facade->addPassenger("Omar");
    facade->addPassenger("Sara");
    facade->addPassenger("Mohamed");
    facade->addPassenger("Nour");
    facade->addPassenger("Ali");
    facade->addPassenger("Mona");
    facade->addPassenger("Youssef");
    facade->addPassenger("Laila");
    facade->addPassenger("Karim");
    facade->addPassenger("Dina");

    // ---- Book Tickets ----
    facade->bookTicket(1, "Omar");
    facade->bookTicket(1, "Sara");
    facade->bookTicket(1, "Ali");
    facade->bookTicket(2, "Mohamed");
    facade->bookTicket(2, "Nour");
    facade->bookTicket(3, "Mona");
    facade->bookTicket(3, "Youssef");
    facade->bookTicket(4, "Karim");
    facade->bookTicket(4, "Laila");
    facade->bookTicket(5, "Dina");
    facade->bookTicket(5, "Omar");
}

RMSFacade *StartupManager::buildFacade() {
    // all services and repos only deleted when startup manger deleted (unique)

    // build repos
    // liskov principle
    this->trainRepository= std::make_unique<InMemoryTrainRepository>();
    this->ticketRepository= std::make_unique<InMemoryTicketRepository>();
    this->passengerRepository= std::make_unique<InMemoryPassengerRepository>();

    // build services
    //dependancy injection  + giving access (only not the ownership) to the services
    this->trainService = std::make_unique<TrainService>(trainRepository.get());
    this->passengerService = std::make_unique<PassengerService>(passengerRepository.get());
    this->ticketService = std::make_unique<TicketService>(ticketRepository.get(),trainService.get(),passengerService.get());

    // build facade + dependancy injection
    // give facade access to the services
    this->facade = std::make_unique<RMSFacade>(trainService.get(),ticketService.get(),passengerService.get());
    loadMockData(facade.get());

    // allow acces to facade
    return facade.get();
}


==================================================
FILE PATH: .\src\models\Passenger.cpp
==================================================

//
// Created by Omar on 11/19/2025.
//
#include <stdexcept>
#include "models/Passenger.h"
#include "utils/helpers.h"

#include <iostream>
using std::cout;
using std::endl;




Passenger::Passenger(const int id, const std::string &name) {
    if(!isValidName(name)) throw std::invalid_argument("Invalid input name");
    if(id <0) throw std::invalid_argument("Invalid id");
    this->id = id;
    this->name = trim(name);
}

int Passenger::getId() const {
    return this->id;
}

std::string Passenger::getName() const {
    return this->name;
}

void Passenger::setId(const int &passengerId) {
    if(passengerId <=0) throw std::invalid_argument("Invalid id");
    this->id = passengerId;
}

void Passenger::setName(const std::string& name) {
    if(!isValidName(name)) throw std::invalid_argument("Invalid input name");
    this->name = trim(name);
}

void Passenger::print(const std::string &msg) const {
    cout << "--------------------------------------------------\n";
    cout << msg << endl;
    cout << "Passenger ID   : " << id << "\n";
    cout << "Name   : " << name << "\n";
    cout << "--------------------------------------------------\n";
}





==================================================
FILE PATH: .\src\models\SeatAllocator.cpp
==================================================

//
// Created by Omar on 11/20/2025.
//

#include "models/SeatAllocator.h"
#include <iostream>
#include <functional>

SeatAllocator::SeatAllocator(int totalSeats){
    if(totalSeats <= 0 )
        this->totalSeats = 10 ;
    else
        this->totalSeats = totalSeats;
//    add the seats to the set
    for(int seat = 1 ; seat <= this->totalSeats; seat++ )
        availableSeats.insert(seat);
}




int SeatAllocator::allocateSeat(int passengerId) {
    // prevent duplicate passenger allocation
    for (const auto& p : allocatedSeats) {
        if (p.second == passengerId)
            throw std::runtime_error("Passenger " + std::to_string(passengerId) + " already has a seat.\n");
    }

    // prevent duplicate waiting list insertion
    if (waitingSet.count(passengerId))
        throw std::runtime_error("Passenger " + std::to_string(passengerId) + " already in waiting list.\n");

    // No available seats , push to waiting list
    if (!hasAvailableSeats()) {
        waitingList.push(passengerId);
        waitingSet.insert(passengerId);
        std::cout << "Train full, passenger added to waiting list.\n";
        return -1;
    }

    int seatNumber;

    // prefer reusing cancelled seats first
    if (!cancelledSeats.empty()) {
        seatNumber = cancelledSeats.top();
        cancelledSeats.pop();
    } else {
        // smallest seat in the set
        seatNumber = *availableSeats.begin();
        availableSeats.erase(availableSeats.begin());
    }

    allocatedSeats[seatNumber] = passengerId;
    return seatNumber;
}


int SeatAllocator::freeSeat(int seatNumber) {
    if (seatNumber <= 0 || seatNumber > totalSeats)
        throw std::invalid_argument("Invalid seat number.\n");

    auto it = allocatedSeats.find(seatNumber);
    if (it == allocatedSeats.end())
        throw std::out_of_range("Invalid seat number.\n");

    // delete from the hash map and add to the stack
    allocatedSeats.erase(seatNumber);
    cancelledSeats.push(seatNumber);

    // assign to waiting passenger if any
    if (!waitingList.empty()) {
        int firstPassenger = waitingList.front();
        waitingList.pop();
        waitingSet.erase(firstPassenger);

        std::cout << "Seat " << seatNumber
                  << " freed and assigned to waiting passenger "
                  << firstPassenger << "\n";

        allocatedSeats[seatNumber] = firstPassenger;
        return firstPassenger;
    }

    return 0;  // no waiting passengers
}

void SeatAllocator::addSeats(int seats) {
    if (seats <= 0)
        throw std::runtime_error("Seats must be greater than zero.");

    int oldTotal = totalSeats;
    totalSeats += seats;

    for (int i = oldTotal + 1; i <= totalSeats; i++)
        availableSeats.insert(i);
}


void SeatAllocator::changeTotalSeats(int newTotalSeats) {
    if (newTotalSeats < getAllocatedSeatCount())
        throw std::runtime_error("Cannot shrink below allocated count.");

    if (newTotalSeats > totalSeats) {
        // expand
        for (int i = totalSeats + 1; i <= newTotalSeats; i++)
            availableSeats.insert(i);
    } else {
        // shrink
        int seatsToRemove = totalSeats - newTotalSeats;

        if ( availableSeats.size() < seatsToRemove)
            throw std::runtime_error("Cannot shrink: not enough free seats.");

        while (seatsToRemove-- > 0) {
            auto it = std::prev(availableSeats.end());
            availableSeats.erase(it);
        }
    }

    totalSeats = newTotalSeats;
}


void SeatAllocator::printStatus() const {
    std::cout << "\n========== Seat Allocation Status ==========\n";

    std::cout << "Total Seats          : " << totalSeats << "\n";
    std::cout << "Allocated Seat Count : " << getAllocatedSeatCount() << "\n";
    std::cout << "Available Seat Count : " << getAvailableSeatCount() << "\n\n";

    // ---- Allocated Seats ----
    std::cout << "--- Allocated Seats (Seat  Passenger ID) ---\n";
    if (allocatedSeats.empty()) {
        std::cout << "No seats allocated.\n";
    } else {
        for (const auto &p : allocatedSeats) {
            if (p.second != -1)
                std::cout << "Seat " << p.first << " -> Passenger " << p.second << "\n";
        }
    }
    std::cout << "\n";

    // ---- Available Seats ----
    std::cout << "--- Available Seats ---\n";
    if (availableSeats.empty()) {
        std::cout << "No free seats.\n";
    } else {
        for (int s : availableSeats)
            std::cout << s << " ";
        std::cout << "\n";
    }
    std::cout << "\n";

    // ---- Cancelled Seats Stack ----
    std::cout << "--- Cancelled Seats Stack (top to bottom) ---\n";
    if (cancelledSeats.empty()) {
        std::cout << "Empty\n";
    } else {
        stack<int> temp = cancelledSeats;
        while (!temp.empty()) {
            std::cout << temp.top() << " ";
            temp.pop();
        }
        std::cout << "\n";
    }
    std::cout << "\n";

    // ---- Waiting List ----
    std::cout << "--- Waiting List (front  back) ---\n";
    if (waitingList.empty()) {
        std::cout << "No passengers in waiting list.\n";
    } else {
        std::queue<int> temp = waitingList;
        while (!temp.empty()) {
            std::cout << temp.front() << " ";
            temp.pop();
        }
        std::cout << "\n";
    }

    std::cout << "=============================================\n\n";
}



bool SeatAllocator::hasAvailableSeats() const {
    // if the is seat in cancelled tickets or minHeap
//   return avaiable(true) if availableSeats or cancelledSeats is not  empty
    return !availableSeats.empty() || !cancelledSeats.empty();
}
int SeatAllocator::getAvailableSeatCount() const {
//    return the numbers of seats in the heap and the cancelled seats
    return availableSeats.size() + cancelledSeats.size() ;
}
std::unique_ptr<SeatAllocator> SeatAllocator::clone() const {
    return std::make_unique<SeatAllocator>(*this);
}

SeatAllocator::SeatAllocator(const SeatAllocator& other)
        : availableSeats(other.availableSeats),
          waitingList(other.waitingList),
          allocatedSeats(other.allocatedSeats),
          cancelledSeats(other.cancelledSeats),
          waitingSet(other.waitingSet),
          totalSeats(other.totalSeats) {}

SeatAllocator& SeatAllocator::operator=(const SeatAllocator& other) {
    if (this != &other) {
        availableSeats = other.availableSeats;
        waitingList = other.waitingList;
        allocatedSeats = other.allocatedSeats;
        cancelledSeats = other.cancelledSeats;
        waitingSet = other.waitingSet;
        totalSeats = other.totalSeats;
    }
    return *this;
}


int SeatAllocator::getAllocatedSeatCount() const {
    return allocatedSeats.size();
}

std::queue<int> SeatAllocator::getWaitingList() const {
    return waitingList;
}

int SeatAllocator::getTotalSeats() const {
    return totalSeats;
}

int SeatAllocator::getWaitingListSize() const {
    return waitingList.size();
}

int SeatAllocator::processWaitingList(int seatsToAdd, std::function<void(int)> bookCallback) {
    int processed = 0;
    std::queue<int> waitingCopy = getWaitingList(); // get copy of waiting list

    while (!waitingCopy.empty() && seatsToAdd > 0) {
        int passengerId = waitingCopy.front();
        waitingCopy.pop();
        try {
            bookCallback(passengerId);
            seatsToAdd--;
            processed++;
        }
        catch (const std::exception& e) {
            std::cerr << "Failed to book ticket for waiting passenger "
                      << passengerId << ": " << e.what() << "\n";
        }
    }
    return processed;
}


==================================================
FILE PATH: .\src\models\Ticket.cpp
==================================================

#include <stdexcept>
#include <iostream>
#include <utility>
#include "models/Ticket.h"
using std::cout;
using std::endl;

Ticket::Ticket(const int id, const int seat, const int trainId, Passenger  p)
        :passenger(std::move(p)), status(booked){
    if(id <0 || trainId <= 0 ) throw std::invalid_argument("Invalid id");
    if(seat<=0) throw std::invalid_argument("Invalid seat");
    this->id = id;
    this->ticketSeat = seat;
    this->trainId = trainId;
}
int Ticket::getId() const
{
    return id;
}

int Ticket::getSeat() const
{
    return this->ticketSeat;
}

Status Ticket::getStatus() const
{
    return status;
}

void Ticket::setStatus(const Status& s)
{
    this->status = s;
}

int Ticket::getTrainId() const
{
    return trainId;
}

Passenger Ticket::getPassenger() const
{
    return passenger;
}

void Ticket::setId(const int newId)
{
    if(newId <=0 )throw std::invalid_argument("Invalid id");
    this->id = newId;
}

void Ticket::print(const std::string &msg) const {
    cout << "--------------------------------------------------\n";
    cout << msg << endl;
    cout << "Ticket ID: " << id << "\n";
    cout << "Seat: " << ticketSeat<< "\n";
    cout << "Train ID: " << trainId << "\n";
    cout << "Passenger: " << passenger.getName() << "\n";
    cout << "Status : " << ((status == Status::booked) ? "Booked" : "Cancelled") << "\n";
    cout << "--------------------------------------------------\n";
}



==================================================
FILE PATH: .\src\models\Train.cpp
==================================================

#include "models/Train.h"
#include "utils/helpers.h"

#include <iostream>
using std::cout;
using std::endl;

Train::Train(const int id, const std::string& name, const int totalSeats ){
    if(id < 0 ) throw std::invalid_argument("Invalid  negative id");
    if(!isValidName(name)) throw std::invalid_argument("Invalid input name");
    if(totalSeats <= 0) throw std::invalid_argument("total seat must be greater than 0");
    this->id = id;
    this->name = trim(name);
    this->totalSeats = totalSeats;
    this->seatAllocator = std::make_unique<SeatAllocator>(totalSeats);

}

int Train::getTrainId() const {
    return id;
}

std::string Train::getTrainName() const {
    return name;
}

void Train::setTrainName(const std::string& name) {
    if(!isValidName(name) )
        throw std::invalid_argument("Invalid input name");
    this->name = trim(name);
}

void Train::setTrainId(int trainId) {
    if(trainId <= 0 ) throw std::runtime_error("Invalid id");
    this->id = trainId;
}

SeatAllocator* Train::getSeatAllocator() const {
    return seatAllocator.get();
}

bool Train::hasAvailableSeats() const {
    return seatAllocator->hasAvailableSeats();
}

int Train::getTotalSeats() const {
    return totalSeats;
}

std::unique_ptr<Train> Train::clone() const {

        auto newTrain = std::make_unique<Train>(id, name, totalSeats);
        if (seatAllocator) {
            newTrain->seatAllocator = seatAllocator->clone();
        }
        return newTrain;

}

Train::Train(const Train &other)
        : id(other.id), name(other.name), totalSeats(other.totalSeats),
          seatAllocator(other.seatAllocator ? other.seatAllocator->clone() : nullptr) {}

Train &Train::operator=(const Train &other) {

        if (this != &other) {
            id = other.id;
            name = other.name;
            totalSeats = other.totalSeats;
            seatAllocator = other.seatAllocator ? other.seatAllocator->clone() : nullptr;
        }
        return *this;

}

void Train::addSeats(int seats) {
    if(seats <= 0 )
        throw std::invalid_argument("Seats must be greater than zero");
    seatAllocator->addSeats(seats);

    this->totalSeats = seatAllocator->getTotalSeats();
}

void Train::setSeats(int seats) {
    if(seats <= 0)
        throw std::invalid_argument("Seats must be greater than zero");
    seatAllocator->changeTotalSeats(seats);

    totalSeats =seatAllocator->getTotalSeats();
}

void Train::trainStatus()const {
    if (!seatAllocator) {
        cout << "Train " << name << " has no seat allocator initialized.\n";
        return;
    }

    int waitingSize = seatAllocator->getWaitingListSize();
    cout << "\n=========== Train Status ===========\n";
    cout << "Train ID      : " << id << "\n";
    cout << "Train Name    : " << name << "\n";
    cout << "Total Seats   : " << totalSeats << "\n";
    cout << "Waiting List  : " << waitingSize << "\n";
    cout << "====================================\n\n";

    seatAllocator->printStatus();

}

void Train::print(const std::string& msg) const{
    cout << "--------------------------------------------------\n";
    cout << msg << endl;
    cout << "Train ID   : " << id<< "\n";
    cout << "Name   : " << name << "\n";
    cout << "Seats  : " << totalSeats << "\n";
    cout << "Availability: " << (hasAvailableSeats() ? "Available" : "full") << "\n";
    cout << "--------------------------------------------------\n";
}



==================================================
FILE PATH: .\src\Repo\InMemoryPassengerRepository.cpp
==================================================

//
// Created by Omar on 11/24/2025.
//


#include <iostream>
#include <optional>
#include "Repo/InMemoryPassengerRepository.h"

std::optional<Passenger> InMemoryPassengerRepository::getPassenger(const int &passengerId) {
    auto  result = passengers.find(passengerId);
    if(result != passengers.end()){
        return result->second;
    }
    return std::nullopt; // not found
}

std::vector<Passenger> InMemoryPassengerRepository::getAllPassengers() {
    std::vector<Passenger> results ;
    for(const auto & ps : passengers){
        results.push_back(ps.second);
    }
    return results;
}

void InMemoryPassengerRepository::save(Passenger &passenger) {
    if(passenger.getId() == 0 ){
        passenger.setId(next_id++);
    }else if(passenger.getId() >= next_id){
        next_id =passenger.getId() + 1;
    }
    const int id =passenger.getId();
    auto res = passengers.emplace(id,passenger);
    if(!res.second){ //update
        res.first->second = passenger;
    }


}

bool InMemoryPassengerRepository::deletePassenger(const int &passengerId) {
    auto it = passengers.find(passengerId);
    if (it != passengers.end()) {
        passengers.erase(it);
        return true;
    }
    return false;
}

void InMemoryPassengerRepository::clear() {
    passengers.clear();
    next_id= 1;
    std::cout << "All passengers destroyed\n";
}



==================================================
FILE PATH: .\src\Repo\InMemoryTicketRepository.cpp
==================================================

#include "Repo/InMemoryTicketRepository.h"
#include <stdexcept>
#include <iostream>

std::optional<Ticket> InMemoryTicketRepository::getTicketByTrainAndPassenger(int trainId, int passengerId)
{
    for (const auto &p : tickets)
    {
        const Ticket &t = p.second;
        if (t.getTrainId() == trainId && t.getPassenger().getId() == passengerId)
        {
            return t;
        }
    }
    return std::nullopt;//not found
}

bool InMemoryTicketRepository::deleteTicket(int ticketId)
{
    auto it = tickets.find(ticketId);
    if (it != tickets.end())
    {
        tickets.erase(it);
        return true;
    }
    return false;
}

void InMemoryTicketRepository::save( Ticket& ticket)
{
    // later
    if (ticket.getId() == 0)
    {
        ticket.setId(next_id++);
    }
    else if (ticket.getId() >= next_id)
    {
        next_id = ticket.getId() + 1;
    }

    int id = ticket.getId();
    auto result = tickets.emplace(id, ticket);
    if (!result.second)
    {
        result.first->second = ticket; // update existing
    }

}

std::vector<Ticket> InMemoryTicketRepository::getAllTickets()
{
    std::vector<Ticket> results;
    for (const auto &p : tickets)
    {
        results.push_back(p.second);
    }
    return results;
}

std::optional<Ticket> InMemoryTicketRepository::getTicketById(int ticketId)
{
    auto it = tickets.find(ticketId);
    if (it != tickets.end())
    {
        return it->second;
    }
    throw std::runtime_error("Ticket not found");
}

void InMemoryTicketRepository::clear()
{
    tickets.clear();
    next_id= 1;
    std::cout << "All tickets destroyed\n";

}


==================================================
FILE PATH: .\src\Repo\InMemoryTrainRepository.cpp
==================================================

#include "Repo/InMemoryTrainRepository.h"
#include <iostream>
#include <stdexcept>

std::vector<Train> InMemoryTrainRepository::getAllTrains() const {
    std::vector<Train> result;
    for (const auto& train : trains) {
        result.push_back(train.second);
    }
    return result;
}

void InMemoryTrainRepository::save(Train & newTrain) {
    // assign id if needed
    if (newTrain.getTrainId() == 0) {
        newTrain.setTrainId(next_id++);
    }else if(newTrain.getTrainId() >= next_id){
        next_id = newTrain.getTrainId() + 1;
    }

    int trainId = newTrain.getTrainId();

    auto result = trains.emplace(trainId, newTrain);

    // If trainId already existed, update it
    if (!result.second) {
        result.first->second = newTrain;
    }

    std::cout << "Train save successfully\n";
}

bool InMemoryTrainRepository::deleteTrain(int trainId) {
    auto it = trains.find(trainId);
    if (it != trains.end()) {
        trains.erase(it);
        return true;
    }
    return false;
}

std::optional<Train>   InMemoryTrainRepository::getTrainById(const int& trainId) const {
    auto it = trains.find(trainId);
    if (it != trains.end()) {
        return it->second;
    }
    throw std::runtime_error("Train not found");
}

void InMemoryTrainRepository::clear() {
    trains.clear();
    next_id= 1;
    std::cout << "All trains destroyed\n";
}


==================================================
FILE PATH: .\src\Services\PassengerService.cpp
==================================================

//
// Created by Omar on 11/24/2025.
//
#include <stdexcept>
#include "Services/PassengerService.h"
#include "utils/helpers.h"
PassengerService::PassengerService(IPassengerRepository *repo) {
    this->passengerRepository =repo;
}

std::optional<Passenger> PassengerService::getPassenger(const int &passengerId) {

    return  passengerRepository->getPassenger(passengerId);
}

std::vector<Passenger> PassengerService::getAllPassengers() {
    return passengerRepository->getAllPassengers();
}

bool PassengerService::deletePassenger(const int &passengerId) {
    return passengerRepository->deletePassenger(passengerId);
}

Passenger PassengerService::createPassenger(const std::string& name) {
    Passenger p(0,trim(name));
    passengerRepository->save(p);
    return p;
}
Passenger PassengerService::updatePassenger(const int passengerId , const std::string& name) {
    auto passenger = passengerRepository->getPassenger(passengerId);
    if(!passenger.has_value())
        throw std::runtime_error("passenger with id: "+ std::to_string(passengerId) + " does not exit \n");
    passenger->setName(name); //update name
    passengerRepository->save(passenger.value());
    return passenger.value();
}

Passenger PassengerService::find_or_create_passenger(const std::string &name) {
    const std::vector<Passenger> passengers = passengerRepository->getAllPassengers();

    for(const auto & p : passengers)
        if(toLowerCase(p.getName()) == toLowerCase(name)){
            return   passengerRepository->getPassenger(p.getId()).value();
        }
    Passenger p(0,name);
    passengerRepository->save(p);
    return p;
}



==================================================
FILE PATH: .\src\Services\TicketService.cpp
==================================================

#include "Services/TicketService.h"
#include <stdexcept> //for run time exception
#include <iostream>

TicketService::TicketService(ITicketRepository *repo, TrainService *ts, PassengerService *ps):ticketRepository(repo),trainService(ts),passengerService(ps) {

}


std::optional<Ticket> TicketService::getTicket(const int& ticketId)
{
    return ticketRepository->getTicketById(ticketId);
}

std::vector<Ticket> TicketService::getAllTickets()
{
    return ticketRepository->getAllTickets();
}

std::optional<Ticket> TicketService::getTicketByTrainAndPassenger(const int& trainId, const int& passengerId)
{

    return ticketRepository->getTicketByTrainAndPassenger(trainId, passengerId);
}

Ticket TicketService::bookTicket(const int& trainId, const int& passengerId)
{

    // 1) get train by id if exist
    auto train = trainService->getTrain(trainId);
    if(!train.has_value()){// not found
        throw std::runtime_error("train with id : " +  std::to_string(trainId) + "does not exit");
    }
    if(!train->hasAvailableSeats())
        throw std::runtime_error("train with id : " +  std::to_string(trainId) + "is Full");

    // 2) get passenger by id if exist
    auto  passenger = passengerService->getPassenger(passengerId);
    if(!passenger.has_value()){// not found
        throw std::runtime_error("passenger with id : " +  std::to_string(passengerId) + "does not exit");
    }

    // 3) check if passenger has already ticket for this train
    auto  existTicket = ticketRepository->getTicketByTrainAndPassenger(trainId,passengerId);
    if(existTicket.has_value()){//  found
        throw std::runtime_error("cannot allocate more than one ticket for the same passenger in the same train\n");
    }

    // 4) assign seat to passenger if avialble
    int seat_number;
    if(train->getSeatAllocator() != nullptr && train->hasAvailableSeats()){ // if train have seat allocator and seats
        seat_number = train->getSeatAllocator()->allocateSeat(passengerId);
        if(seat_number == -1)
            throw std::runtime_error("failed to assign seat");
        trainService->save(train.value());
    }

    // 5)  create ticket
    Ticket t(0,seat_number,trainId , passenger.value());
    ticketRepository->save(t);
    return t;
}

void TicketService::cancelTicket(const int& ticketId)
{

    // get train
    auto ticket =ticketRepository->getTicketById(ticketId);
    if(!ticket.has_value()){ //not found
        throw std::runtime_error("ticket with id : " +  std::to_string(ticketId) + "does not exit");
    }

    // return error if it is already cancelled
    if(ticket->getStatus() == cancelled){
        throw std::runtime_error("ticket with id : " +  std::to_string(ticketId) + "is already cancelled");
    }

    //find train
    auto train = trainService->getTrain(ticket->getTrainId());
    if(!train.has_value() || train->getSeatAllocator() == nullptr){
        throw std::runtime_error("train is not exist or not has seat allocator");
    }

    // pass seat to waiting list
    auto waitingPassengerId  = train->getSeatAllocator()->freeSeat(ticket->getSeat());
    if(waitingPassengerId  == -1)
        throw std::runtime_error("fail to free the seat \n");
    // book seat to another passenger from waiting list if available
    if(waitingPassengerId > 0) {  // >0 means there was a waiting passenger
        try {
            bookTicket(train->getTrainId(), waitingPassengerId);
        } catch (const std::exception& e) {
            // Log error and continue with cancellation
            std::cerr << "Failed to book ticket for waiting passenger "
                      << waitingPassengerId << ": " << e.what() << "\n";
        }
    }

    // cancel ticket
    ticket->setStatus(cancelled);
    ticketRepository->save(ticket.value());
}

Ticket TicketService::updateTicket(Ticket &t) {
    ticketRepository->save(t);
    return t;

}



==================================================
FILE PATH: .\src\Services\TrainService.cpp
==================================================

//
// Created by Omar on 11/21/2025.
//

#include "Services/TrainService.h"
#include "utils/helpers.h"
#include <stdexcept> //for run time exception

std::optional<Train> TrainService::getTrain(const int& trainId) {
    return trainRepository->getTrainById(trainId);
}

TrainService::TrainService(ITrainRepository *repo) {
    this->trainRepository = repo;
}

TrainService::~TrainService() {
    // do not delete repo because service is not owning the  repo it just use it
}

std::vector<Train> TrainService::getAllTrains() {
    return trainRepository->getAllTrains();
}

Train TrainService::createTrain(const std::string& name,int seats) {
    Train t(0,name ,seats);
    trainRepository->save(t); // save the train  and give id by the repo
    return t;
}

bool TrainService::deleteTrain(int trainId) {
    return trainRepository->deleteTrain(trainId);
}

bool TrainService::isAvailbleSeat(int trainId) {
    auto train = trainRepository->getTrainById(trainId);
    if(!train.has_value())
        throw std::runtime_error("train with id : " +  std::to_string(trainId) + "does not exit");

    return train->hasAvailableSeats() ;
}

void TrainService::save(Train &train) {
    trainRepository->save(train);
}

Train TrainService::updateTrain(const int &trainId, const std::string &name, int seats) {
    auto train = trainRepository->getTrainById(trainId);
    if(!train.has_value())  // not exist
        throw std::runtime_error("cannot update train because train with id : " +  std::to_string(trainId) + "does not exit") ;
    // update name
    if(!name.empty())
        train->setTrainName(name);
    // update seats
    if(seats != 0)
        train->setSeats(seats);
    trainRepository->save(train.value());
    return train.value();
}

Train TrainService::addSeats(const int trainId, const int seats) {
    auto train =trainRepository->getTrainById(trainId);
    if(!train.has_value())
        throw std::runtime_error("train with id : " +  std::to_string(trainId) + "does not exit");
    train->addSeats(seats);
    trainRepository->save(train.value());
    return train.value();
}

Train TrainService::addSeats(const std::string name, const int seats) {
    if(name.empty())
        throw std::runtime_error("invalid name (empty string)");

    auto trains = trainRepository->getAllTrains();
    if(trains.empty())
        throw std::runtime_error("train with name : " + name +" does not exit");
    for(auto &train : trains){ // search train
        // if match update
        if(compareString(train.getTrainName() ,name))
            return  addSeats(train.getTrainId(),seats);
    }
    throw std::runtime_error("train with name : " + name +" does not exit");

}

void TrainService::printStatus(int trainId) {
    auto train = trainRepository->getTrainById(trainId);
    if(!train.has_value())
        throw std::runtime_error("train with id : " +  std::to_string(trainId) + "does not exit");
    train->trainStatus();
}


==================================================
FILE PATH: .\src\utils\helpers.cpp
==================================================



#include "utils/helpers.h"
#include <cctype> // for toLower
#include <stdexcept>
#include <regex>
#include <iostream>
#include <chrono>
#include <iomanip>

using std::string;
using std::cout;
using std::endl;

std::string toLowerCase(std::string word){
    for(char & ch : word){
        ch = (char)tolower(ch);
    }
    return word;
}
// Function to trim leading and trailing whitespace
std::string trim(const std::string &str) {
    if (str.empty()) return "";

    auto start = 0;
    auto end = str.length() - 1;

    // find first char from the left
    while (start < str.size() && str[start] == ' ') {
        start++;
    }

    // all string is space
    if (start == str.size()) return "";

    // find first char from the right
    while (end > start && str[end] == ' ') {
        end--;
    }

    // return actual string
    return str.substr(start, end - start + 1);
}

int parseInt(const std::string& arg , const std::string& argName){
    try{
        std::size_t pos; // have the index of non int char
       int res = stoi(arg,&pos);
       if(pos == 0 || pos != arg.size()) // to pass 12a and abc
           throw std::invalid_argument("");

       return res;

    }catch (std::invalid_argument& e) {
        throw std::invalid_argument( argName +" must be a number");
    }
    catch ( std::out_of_range& e) {
        throw std::out_of_range( argName +" value is too large");
    }
}

bool isValidName(const std::string& name) {
    static const std::regex pattern("^[A-Za-z]+([' -][A-Za-z]+)*$"); // a-z - '
    return std::regex_match(name, pattern);
}
std::string combineString(const std::vector<std::string>& args,int start){
    if(args[start].empty())
        return "";
    std::string text;
    for(int i = start ; i < args.size() ; i++){
        if(!isValidName(args[i]))
            throw std::runtime_error("invalid name");
        text+= args[i] + " ";
    }
    text.pop_back(); //remove last char
    return text;
}

std::string combineString(const std::vector<std::string>& args, int start , int end){
    if(args[start].empty())
        return "";
    if (end == -1) {
        end = args.size() - 1; // stop at prev-last element
    }

    if (start < 0 || start >= args.size() || end < start) {
        throw std::runtime_error("Invalid start/end range for combineString");
    }
    std::string text;
    for(int i = start ; i < end; i++){
        if(!isValidName(args[i]))
            throw std::runtime_error("invalid name");
        text+= args[i] + " ";
    }
    text.pop_back(); //remove last char
    return text;
}
bool compareString(const std::string& str1 , const std::string& str2){
    return toLowerCase(trim(str1)) ==toLowerCase(trim(str2));
}
bool isInteger(const std::string& str) {
    try {
        std::stoi(str);
        return true;
    } catch (std::exception&) {
        return false;
    }
}


void printCurrentDate(){
    auto now = std::chrono::system_clock::now();
    auto time = std::chrono::system_clock::to_time_t(now);

    std::cout << "Current Date & Time: "
              << std::put_time(std::localtime(&time), "%Y-%m-%d %H:%M:%S")
              << "\n";
}


==================================================
FILE PATH: .\tests\test_cliController.cpp
==================================================

#include <gtest/gtest.h>
#include "CLIController.h"
#include "RMSFacade.h"
#include "Services/TrainService.h"
#include "Services/PassengerService.h"
#include "Services/TicketService.h"
#include "Repo/InMemoryTrainRepository.h"
#include "Repo/InMemoryPassengerRepository.h"
#include "Repo/InMemoryTicketRepository.h"
#include "RMSCommand.h"
#include <sstream>
#include <iostream>

class CLICommandFlowTest : public ::testing::Test {
protected:
    InMemoryTrainRepository* trainRepo;
    InMemoryPassengerRepository* passengerRepo;
    InMemoryTicketRepository* ticketRepo;
    TrainService* trainService;
    PassengerService* passengerService;
    TicketService* ticketService;
    RMSFacade* facade;
    CLIController* cli;

    std::stringstream outputBuffer;
    std::streambuf* originalCoutBuffer;

    void SetUp() override {
        // Setup repositories
        trainRepo = new InMemoryTrainRepository();
        passengerRepo = new InMemoryPassengerRepository();
        ticketRepo = new InMemoryTicketRepository();

        // Setup services
        trainService = new TrainService(trainRepo);
        passengerService = new PassengerService(passengerRepo);
        ticketService = new TicketService(ticketRepo, trainService, passengerService);

        // Setup facade
        facade = new RMSFacade(trainService, ticketService, passengerService);

        // Setup CLI controller
        cli = new CLIController(facade);

        // Redirect cout to buffer
        originalCoutBuffer = std::cout.rdbuf();
        std::cout.rdbuf(outputBuffer.rdbuf());

        // Clear any existing data
        trainRepo->clear();
        passengerRepo->clear();
        ticketRepo->clear();
    }

    void TearDown() override {
        // Restore cout
        std::cout.rdbuf(originalCoutBuffer);

        // Cleanup
        delete cli;
        delete facade;
        delete ticketService;
        delete passengerService;
        delete trainService;
        delete ticketRepo;
        delete passengerRepo;
        delete trainRepo;
    }

    std::string getOutputAndClear() {
        std::string output = outputBuffer.str();
        outputBuffer.str("");
        outputBuffer.clear();
        return output;
    }

    void simulateCommand(const std::string& command) {
        // Simulate tokenization and command execution
        std::vector<std::string> args = CLIController::tokenize(command);

        if (args.empty()) {
            std::cout << "Please enter a command. Type 'help' for available commands.\n";
            return;
        }

        // Simplified version of CLIController::run() logic
        using MainCmd = RMSCommand::MainCmd;
        using TrainCmd = RMSCommand::TrainCmd;
        using PassengerCmd = RMSCommand::PassengerCmd;
        using TicketCmd = RMSCommand::TicketCmd;
        using SystemCmd = RMSCommand::SystemCmd;

        MainCmd mainCmd = RMSCommand::getMainCmd(args[0]);

        switch (mainCmd) {
            case MainCmd::TRAIN: {
                if (args.size() < 2) {
                    std::cout << "Usage: train <list|add|delete|update|seats|availability>\n";
                    break;
                }
                TrainCmd tCmd = RMSCommand::getTrainCmd(args[1]);
                switch (tCmd) {
                    case TrainCmd::LIST:         cli->list_trains(); break;
                    case TrainCmd::ADD:          cli->add_train(args); break;
                    case TrainCmd::DELETE:       cli->delete_train(args); break;
                    case TrainCmd::UPDATE:       cli->update_train(args); break;
                    case TrainCmd::SEATS_ADD:    cli->add_seats(args); break;
                    case TrainCmd::AVAILABILITY: cli->get_train_availability(args); break;
                    default: std::cout << "Invalid train command.\n";
                }
                break;
            }

            case MainCmd::PASSENGER: {
                if (args.size() < 2) {
                    std::cout << "Usage: passenger <list|add|delete|update>\n";
                    break;
                }
                PassengerCmd pCmd = RMSCommand::getPassengerCmd(args[1]);
                switch (pCmd) {
                    case PassengerCmd::LIST:   cli->list_passengers(); break;
                    case PassengerCmd::ADD:    cli->add_passenger(args); break;
                    case PassengerCmd::DELETE: cli->delete_passenger(args); break;
                    case PassengerCmd::UPDATE: cli->update_passenger(args); break;
                    default: std::cout << "Invalid passenger command.\n";
                }
                break;
            }

            case MainCmd::TICKET: {
                if (args.size() < 2) {
                    std::cout << "Usage: ticket <list|book|cancel>\n";
                    break;
                }
                TicketCmd tkCmd = RMSCommand::getTicketCmd(args[1]);
                switch (tkCmd) {
                    case TicketCmd::LIST:   cli->list_tickets(); break;
                    case TicketCmd::BOOK:   cli->book_ticket(args); break;
                    case TicketCmd::CANCEL: cli->cancel_ticket(args); break;
                    default: std::cout << "Invalid ticket command.\n";
                }
                break;
            }

            case MainCmd::SYSTEM: {
                SystemCmd sCmd = RMSCommand::getSystemCmd(args[0]);
                switch (sCmd) {
                    case SystemCmd::HELP: cli->show_help(); break;
                    case SystemCmd::EXIT:
                        std::cout << "Goodbye!\n";
                        exit(0);
                    default: std::cout << "Invalid system command.\n";
                }
                break;
            }

            default:
                std::cout << "Unknown command. Type 'help' for available commands.\n";
        }
    }
};

TEST_F(CLICommandFlowTest, CompleteBookingScenario) {
    // Simulate a complete booking scenario through CLI commands

    // 1. Add a train
    simulateCommand("train add Express 100");
    std::string output = getOutputAndClear();
    EXPECT_NE(output.find("Train Added Successfully"), std::string::npos);

    // 2. Add a passenger
    simulateCommand("passenger add John Doe");
    output = getOutputAndClear();
    EXPECT_NE(output.find("Passenger Added Successfully"), std::string::npos);

    // 3. List trains to see ID
    simulateCommand("train list");
    output = getOutputAndClear();
    EXPECT_NE(output.find("Express"), std::string::npos);

    // 4. Book a ticket (assuming train ID is 1)
    simulateCommand("ticket book 1 John Doe");
    output = getOutputAndClear();
    EXPECT_NE(output.find("Ticket Booked Successfully"), std::string::npos);

    // 5. List tickets
    simulateCommand("ticket list");
    output = getOutputAndClear();
    EXPECT_NE(output.find("John Doe"), std::string::npos);

    // 6. Cancel ticket (assuming ticket ID is 1)
    simulateCommand("ticket cancel 1");
    output = getOutputAndClear();
    EXPECT_NE(output.find("Ticket Cancelled Successfully"), std::string::npos);

    // 7. Verify ticket is cancelled
    simulateCommand("ticket list");
    output = getOutputAndClear();
    EXPECT_NE(output.find("Cancelled"), std::string::npos);
}

TEST_F(CLICommandFlowTest, InvalidCommandFlow) {
    // Test various invalid command sequences

    // 1. Unknown command
    simulateCommand("unknown command");
    std::string output = getOutputAndClear();
    EXPECT_NE(output.find("Unknown command"), std::string::npos);

    // 2. Valid command but missing arguments
    simulateCommand("train add");
    output = getOutputAndClear();
    EXPECT_NE(output.find("Usage: train add"), std::string::npos);

    // 3. Invalid subcommand
    simulateCommand("train invalid");
    output = getOutputAndClear();
    EXPECT_NE(output.find("Invalid train command"), std::string::npos);
}

TEST_F(CLICommandFlowTest, HelpCommandIntegration) {
    // Test help command integration

    simulateCommand("help");
    std::string output = getOutputAndClear();

    EXPECT_NE(output.find("RMS - Railway Management System"), std::string::npos);
    EXPECT_NE(output.find("train:"), std::string::npos);
    EXPECT_NE(output.find("passenger:"), std::string::npos);
    EXPECT_NE(output.find("ticket:"), std::string::npos);
    EXPECT_NE(output.find("system:"), std::string::npos);
}

TEST_F(CLICommandFlowTest, SystemExitCommands) {
    // Note: Can't test exit command directly as it calls exit()
    // This test verifies other system commands

    // Test help aliases
    simulateCommand("h");
    std::string output = getOutputAndClear();
    EXPECT_NE(output.find("RMS - Railway Management System"), std::string::npos);

    simulateCommand("?");
    output = getOutputAndClear();
    EXPECT_NE(output.find("RMS - Railway Management System"), std::string::npos);
}

TEST_F(CLICommandFlowTest, TrainManagementFlow) {
    // Complete train management flow

    // 1. Add multiple trains
    simulateCommand("train add Express 100");
    getOutputAndClear();

    simulateCommand("train add Local 50");
    getOutputAndClear();

    // 2. List all trains
    simulateCommand("train list");
    std::string output = getOutputAndClear();
    EXPECT_NE(output.find("Express"), std::string::npos);
    EXPECT_NE(output.find("Local"), std::string::npos);

    // 3. Update a train
    simulateCommand("train update 1 Super Express 150");
    output = getOutputAndClear();
    EXPECT_NE(output.find("Train updated successfully"), std::string::npos);

    // 4. Check availability
    simulateCommand("train availability 1");
    output = getOutputAndClear();
    EXPECT_NE(output.find("available"), std::string::npos);

    // 5. Add seats
    simulateCommand("train seats 1 50");
    output = getOutputAndClear();
    EXPECT_NE(output.find("Train updated successfully"), std::string::npos);

    // 6. Delete a train
    simulateCommand("train delete 2");
    output = getOutputAndClear();
    EXPECT_NE(output.find("deleted successfully"), std::string::npos);
}

TEST_F(CLICommandFlowTest, PassengerManagementFlow) {
    // Complete passenger management flow

    // 1. Add multiple passengers
    simulateCommand("passenger add Alice Smith");
    getOutputAndClear();

    simulateCommand("passenger add Bob Johnson");
    getOutputAndClear();

    simulateCommand("passenger add Charlie Brown");
    getOutputAndClear();

    // 2. List all passengers
    simulateCommand("passenger list");
    std::string output = getOutputAndClear();
    EXPECT_NE(output.find("Alice Smith"), std::string::npos);
    EXPECT_NE(output.find("Bob Johnson"), std::string::npos);
    EXPECT_NE(output.find("Charlie Brown"), std::string::npos);

    // 3. Update a passenger
    simulateCommand("passenger update 1 Alice Jones");
    output = getOutputAndClear();
    EXPECT_NE(output.find("Passenger updated successfully"), std::string::npos);

    // 4. Delete a passenger
    simulateCommand("passenger delete 3");
    output = getOutputAndClear();
    EXPECT_NE(output.find("deleted successfully"), std::string::npos);

    // 5. Verify deletion
    simulateCommand("passenger list");
    output = getOutputAndClear();
    EXPECT_NE(output.find("Alice Jones"), std::string::npos);
    EXPECT_NE(output.find("Bob Johnson"), std::string::npos);
    EXPECT_EQ(output.find("Charlie Brown"), std::string::npos); // Should not find deleted passenger
}

==================================================
FILE PATH: .\tests\test_facade.cpp
==================================================

#include <gtest/gtest.h>
#include "RMSFacade.h"
#include "Services/TrainService.h"
#include "Services/PassengerService.h"
#include "Services/TicketService.h"
#include "Repo/InMemoryTrainRepository.h"
#include "Repo/InMemoryPassengerRepository.h"
#include "Repo/InMemoryTicketRepository.h"

class RMSFacadeTest : public ::testing::Test {
protected:
    // Repositories
    std::unique_ptr<InMemoryTrainRepository> trainRepo;
    std::unique_ptr<InMemoryPassengerRepository> passengerRepo;
    std::unique_ptr<InMemoryTicketRepository> ticketRepo;

    // Services
    std::unique_ptr<TrainService> trainService;
    std::unique_ptr<PassengerService> passengerService;
    std::unique_ptr<TicketService> ticketService;

    // Facade (System Under Test)
    std::unique_ptr<RMSFacade> rms;

    void SetUp() override {
        // 1. Initialize Repositories
        trainRepo = std::make_unique<InMemoryTrainRepository>();
        passengerRepo = std::make_unique<InMemoryPassengerRepository>();
        ticketRepo = std::make_unique<InMemoryTicketRepository>();

        // Clear any static/residual state
        trainRepo->clear();
        passengerRepo->clear();
        ticketRepo->clear();

        // 2. Initialize Services with Repo pointers
        trainService = std::make_unique<TrainService>(trainRepo.get());
        passengerService = std::make_unique<PassengerService>(passengerRepo.get());

        // TicketService depends on the other two services
        ticketService = std::make_unique<TicketService>(ticketRepo.get(), trainService.get(), passengerService.get());

        // 3. Initialize Facade with Service pointers
        rms = std::make_unique<RMSFacade>(trainService.get(), ticketService.get(), passengerService.get());
    }
};

// ================= TRAIN MANAGEMENT TESTS =================

TEST_F(RMSFacadeTest, AddTrain_ValidInput) {
    Train train = rms->addTrain("Express A", 100);

    EXPECT_GT(train.getTrainId(), 0);
    EXPECT_EQ(train.getTrainName(), "Express A");
    EXPECT_EQ(train.getTotalSeats(), 100);
    EXPECT_TRUE(train.hasAvailableSeats());
}

TEST_F(RMSFacadeTest, AddTrain_ThrowsOnEmptyName) {
    EXPECT_THROW(rms->addTrain("", 100), std::invalid_argument);
    EXPECT_THROW(rms->addTrain("   ", 100), std::invalid_argument);
}

TEST_F(RMSFacadeTest, AddTrain_ThrowsOnInvalidSeats) {
    EXPECT_THROW(rms->addTrain("Express", 0), std::invalid_argument);
    EXPECT_THROW(rms->addTrain("Express", -10), std::invalid_argument);
}

TEST_F(RMSFacadeTest, AddAndListTrains) {
    rms->addTrain("Express A", 100);
    rms->addTrain("Local B", 50);

    std::vector<Train> trains = rms->listTrains();

    EXPECT_EQ(trains.size(), 2);
    EXPECT_EQ(trains[0].getTrainName(), "Express A");
    EXPECT_EQ(trains[1].getTrainName(), "Local B");
}

TEST_F(RMSFacadeTest, GetTrain_ReturnsCorrectDetails) {
    Train t = rms->addTrain("Bullet Train", 200);

    auto fetched = rms->getTrain(t.getTrainId());

    ASSERT_TRUE(fetched.has_value());
    EXPECT_EQ(fetched->getTrainName(), "Bullet Train");
    EXPECT_EQ(fetched->getTotalSeats(), 200);
}

TEST_F(RMSFacadeTest, GetTrain_ReturnsNulloptForNonExistent) {
    auto fetched = rms->getTrain(999);
    EXPECT_FALSE(fetched.has_value());
}

TEST_F(RMSFacadeTest, GetTrainAvailability_CorrectlyReportsStatus) {
    Train t = rms->addTrain("Empty Train", 10);
    EXPECT_TRUE(rms->getTrainAvailability(t.getTrainId()));
}

TEST_F(RMSFacadeTest, GetTrainAvailability_ThrowsForNonExistentTrain) {
    EXPECT_THROW(rms->getTrainAvailability(999), std::out_of_range);
}

TEST_F(RMSFacadeTest, UpdateTrain_Success) {
    Train original = rms->addTrain("Old Name", 50);
    int id = original.getTrainId();

    Train updated = rms->updateTrain(id, "New Name", 75);

    EXPECT_EQ(updated.getTrainId(), id);
    EXPECT_EQ(updated.getTrainName(), "New Name");
    EXPECT_EQ(updated.getTotalSeats(), 75);

    auto fetched = rms->getTrain(id);
    ASSERT_TRUE(fetched.has_value());
    EXPECT_EQ(fetched->getTrainName(), "New Name");
    EXPECT_EQ(fetched->getTotalSeats(), 75);
}

TEST_F(RMSFacadeTest, UpdateTrain_ThrowsForNonExistentTrain) {
    EXPECT_THROW(rms->updateTrain(999, "New Name", 100), std::out_of_range);
}

TEST_F(RMSFacadeTest, UpdateTrain_ThrowsForInvalidInput) {
    Train train = rms->addTrain("Test Train", 10);
    int id = train.getTrainId();

    // Invalid train ID
    EXPECT_THROW(rms->updateTrain(0, "New Name", 100), std::invalid_argument);
    EXPECT_THROW(rms->updateTrain(-1, "New Name", 100), std::invalid_argument);

    // Empty name
    EXPECT_THROW(rms->updateTrain(id, "", 100), std::invalid_argument);
    EXPECT_THROW(rms->updateTrain(id, "   ", 100), std::invalid_argument);

    // Negative seats
    EXPECT_THROW(rms->updateTrain(id, "New Name", -5), std::invalid_argument);
}

TEST_F(RMSFacadeTest, UpdateTrain_WithWaitingList_Option2) {
    // Create train with 1 seat
    Train train = rms->addTrain("Small Train", 1);
    int trainId = train.getTrainId();

    // Book the only seat
    rms->addPassenger("John");
    Ticket johnTicket = rms->bookTicket(trainId, "John");

    // Try to book Jane - should fail (train full)
    rms->addPassenger("Jane");
    EXPECT_THROW(rms->bookTicket(trainId, "Jane"), std::runtime_error);

    // Update train to add more seats (now 2 seats)
    Train updated = rms->updateTrain(trainId, "Small Train", 2);

    // Now Jane should be able to book
    EXPECT_NO_THROW(rms->bookTicket(trainId, "Jane"));

    auto tickets = rms->listTickets();
    EXPECT_EQ(tickets.size(), 2);
}

TEST_F(RMSFacadeTest, AddSeats_ByTrainId) {
    Train train = rms->addTrain("Train", 10);
    int id = train.getTrainId();

    Train updated = rms->addSeats(id, 5);

    EXPECT_EQ(updated.getTotalSeats(), 15);

    auto fetched = rms->getTrain(id);
    ASSERT_TRUE(fetched.has_value());
    EXPECT_EQ(fetched->getTotalSeats(), 15);
}

TEST_F(RMSFacadeTest, AddSeats_ByTrainName) {
    rms->addTrain("Express Train", 10);

    Train updated = rms->addSeats("Express Train", 5);

    EXPECT_EQ(updated.getTotalSeats(), 15);

    auto trains = rms->listTrains();
    ASSERT_EQ(trains.size(), 1);
    EXPECT_EQ(trains[0].getTotalSeats(), 15);
}

TEST_F(RMSFacadeTest, AddSeats_ThrowsForNonExistentTrain) {
    EXPECT_THROW(rms->addSeats(999, 5), std::runtime_error);
    EXPECT_THROW(rms->addSeats("NonExistent", 5), std::runtime_error);
}

TEST_F(RMSFacadeTest, DeleteTrain_Success) {
    Train train = rms->addTrain("To Delete", 10);
    int id = train.getTrainId();

    rms->deleteTrain(id);

    auto trains = rms->listTrains();
    EXPECT_TRUE(trains.empty());

    auto fetched = rms->getTrain(id);
    EXPECT_FALSE(fetched.has_value());
}

TEST_F(RMSFacadeTest, DeleteTrain_ThrowsForNonExistent) {
    EXPECT_THROW(rms->deleteTrain(999), std::out_of_range);
}

// ================= PASSENGER MANAGEMENT TESTS =================

TEST_F(RMSFacadeTest, AddPassenger_ValidInput) {
    Passenger p = rms->addPassenger("Alice");

    EXPECT_GT(p.getId(), 0);
    EXPECT_EQ(p.getName(), "Alice");
}

TEST_F(RMSFacadeTest, AddPassenger_ThrowsOnEmptyName) {
    EXPECT_THROW(rms->addPassenger(""), std::invalid_argument);
    EXPECT_THROW(rms->addPassenger("   "), std::invalid_argument);
}

TEST_F(RMSFacadeTest, AddAndListPassengers) {
    rms->addPassenger("Alice");
    rms->addPassenger("Bob");

    auto passengers = rms->listPassengers();

    EXPECT_EQ(passengers.size(), 2);
    EXPECT_EQ(passengers[0].getName(), "Alice");
    EXPECT_EQ(passengers[1].getName(), "Bob");
}

TEST_F(RMSFacadeTest, GetPassenger_FoundAndNotFound) {
    Passenger p = rms->addPassenger("Charlie");

    // Found
    auto found = rms->getPassenger(p.getId());
    ASSERT_TRUE(found.has_value());
    EXPECT_EQ(found->getName(), "Charlie");

    // Not Found
    auto notFound = rms->getPassenger(999);
    EXPECT_FALSE(notFound.has_value());
}

TEST_F(RMSFacadeTest, UpdatePassenger_Success) {
    Passenger original = rms->addPassenger("Old Name");
    int id = original.getId();

    Passenger updated = rms->updatePassenger(id, "New Name");

    EXPECT_EQ(updated.getId(), id);
    EXPECT_EQ(updated.getName(), "New Name");

    auto fetched = rms->getPassenger(id);
    ASSERT_TRUE(fetched.has_value());
    EXPECT_EQ(fetched->getName(), "New Name");
}

TEST_F(RMSFacadeTest, UpdatePassenger_ThrowsForNonExistent) {
    EXPECT_THROW(rms->updatePassenger(999, "New Name"), std::out_of_range);
}

TEST_F(RMSFacadeTest, UpdatePassenger_ThrowsForInvalidName) {
    Passenger p = rms->addPassenger("Test");
    int id = p.getId();

    EXPECT_THROW(rms->updatePassenger(id, ""), std::invalid_argument);
    EXPECT_THROW(rms->updatePassenger(id, "   "), std::invalid_argument);
}

TEST_F(RMSFacadeTest, UpdatePassenger_UpdatesTickets) {
    // Create train and passenger
    Train train = rms->addTrain("Express", 10);
    int trainId = train.getTrainId();
    Passenger passenger = rms->addPassenger("Old Name");
    int passengerId = passenger.getId();

    // Book ticket
    Ticket ticket = rms->bookTicket(trainId, "Old Name");

    // Update passenger name
    rms->updatePassenger(passengerId, "New Name");

    // Check ticket passenger name is updated
    auto tickets = rms->listTickets();
    ASSERT_EQ(tickets.size(), 1);
    EXPECT_EQ(tickets[0].getPassenger().getName(), "New Name");
}

TEST_F(RMSFacadeTest, DeletePassenger_Success) {
    Passenger p = rms->addPassenger("To Delete");
    int id = p.getId();

    rms->deletePassenger(id);

    auto passengers = rms->listPassengers();
    EXPECT_TRUE(passengers.empty());

    auto fetched = rms->getPassenger(id);
    EXPECT_FALSE(fetched.has_value());
}

TEST_F(RMSFacadeTest, DeletePassenger_ThrowsForNonExistent) {
    EXPECT_THROW(rms->deletePassenger(999), std::out_of_range);
}

// ================= TICKET MANAGEMENT TESTS =================

TEST_F(RMSFacadeTest, BookTicket_HappyPath) {
    // 1. Setup
    Train t = rms->addTrain("City Connector", 50);
    // Passenger is added explicitly to get ID for assertion, but Facade uses the name
    Passenger p = rms->addPassenger("David");

    // 2. Action: Use passenger's name for booking
    Ticket ticket = rms->bookTicket(t.getTrainId(), "David");

    // 3. Assert
    EXPECT_GT(ticket.getId(), 0);
    EXPECT_EQ(ticket.getTrainId(), t.getTrainId());
    // Verify the ticket was issued to the expected passenger ID
    EXPECT_EQ(ticket.getPassenger().getId(), p.getId());
    EXPECT_EQ(ticket.getStatus(), booked);

    // Verify it appears in the list
    auto allTickets = rms->listTickets();
    EXPECT_EQ(allTickets.size(), 1);
}

TEST_F(RMSFacadeTest, BookTicket_CreatesPassengerIfNotExists) {
    Train t = rms->addTrain("Express", 10);

    // Passenger "John" doesn't exist yet
    Ticket ticket = rms->bookTicket(t.getTrainId(), "John");

    EXPECT_GT(ticket.getId(), 0);
    EXPECT_EQ(ticket.getPassenger().getName(), "John");

    // Passenger should now exist
    auto passengers = rms->listPassengers();
    EXPECT_EQ(passengers.size(), 1);
    EXPECT_EQ(passengers[0].getName(), "John");
}

TEST_F(RMSFacadeTest, BookTicket_FindsExistingPassengerCaseInsensitive) {
    Train t = rms->addTrain("Express", 10);
    rms->addPassenger("John Doe");

    // Should find existing passenger despite case difference
    Ticket ticket = rms->bookTicket(t.getTrainId(), "john doe");

    EXPECT_EQ(ticket.getPassenger().getName(), "John Doe");

    // Should only have one passenger
    auto passengers = rms->listPassengers();
    EXPECT_EQ(passengers.size(), 1);
}

TEST_F(RMSFacadeTest, BookTicket_UpdatesSeatAvailability) {
    // 1. Create a train with EXACTLY 1 seat
    Train t = rms->addTrain("Tiny Train", 1);

    // 2. Book the only seat using passenger's name
    rms->bookTicket(t.getTrainId(), "Eve");

    // 3. Verify availability via Facade
    EXPECT_FALSE(rms->getTrainAvailability(t.getTrainId()));

    // 4. Verify second booking fails (using a different passenger's name)
    EXPECT_THROW(rms->bookTicket(t.getTrainId(), "Frank"), std::runtime_error);
}

TEST_F(RMSFacadeTest, BookTicket_ValidatesInputs) {
    // Invalid Train ID (999 does not exist)
    EXPECT_THROW(rms->bookTicket(999, "David"), std::out_of_range);

    // Invalid Train ID (0 or negative)
    EXPECT_THROW(rms->bookTicket(0, "David"), std::invalid_argument);
    EXPECT_THROW(rms->bookTicket(-1, "David"), std::invalid_argument);

    Train t = rms->addTrain("Valid Train", 10);
    // Invalid Passenger Name (empty or whitespace)
    EXPECT_THROW(rms->bookTicket(t.getTrainId(), ""), std::invalid_argument);
    EXPECT_THROW(rms->bookTicket(t.getTrainId(), "   "), std::invalid_argument);
}

TEST_F(RMSFacadeTest, BookTicket_ThrowsIfAlreadyBooked) {
    Train t = rms->addTrain("Express", 10);
    rms->addPassenger("John");

    rms->bookTicket(t.getTrainId(), "John");

    // Same passenger cannot book twice on same train
    EXPECT_THROW(rms->bookTicket(t.getTrainId(), "John"), std::runtime_error);
}

TEST_F(RMSFacadeTest, BookTicket_SamePassengerDifferentTrains) {
    Train t1 = rms->addTrain("Train A", 10);
    Train t2 = rms->addTrain("Train B", 10);
    rms->addPassenger("John");

    EXPECT_NO_THROW(rms->bookTicket(t1.getTrainId(), "John"));
    EXPECT_NO_THROW(rms->bookTicket(t2.getTrainId(), "John"));

    auto tickets = rms->listTickets();
    EXPECT_EQ(tickets.size(), 2);
}

TEST_F(RMSFacadeTest, ListTickets) {
    Train t = rms->addTrain("Express", 10);
    rms->addPassenger("Alice");
    rms->addPassenger("Bob");

    rms->bookTicket(t.getTrainId(), "Alice");
    rms->bookTicket(t.getTrainId(), "Bob");

    auto tickets = rms->listTickets();
    EXPECT_EQ(tickets.size(), 2);

    // Check tickets have correct data
    EXPECT_EQ(tickets[0].getTrainId(), t.getTrainId());
    EXPECT_EQ(tickets[1].getTrainId(), t.getTrainId());
}

TEST_F(RMSFacadeTest, CancelTicket_Success) {
    Train t = rms->addTrain("Express", 10);
    rms->addPassenger("John");
    Ticket ticket = rms->bookTicket(t.getTrainId(), "John");

    rms->cancelTicket(ticket.getId());

    // Check ticket status changed
    auto tickets = rms->listTickets();
    ASSERT_EQ(tickets.size(), 1);
    EXPECT_EQ(tickets[0].getStatus(), cancelled);
}

TEST_F(RMSFacadeTest, CancelTicket_ThrowsForInvalidId) {
    // Invalid ticket ID
    EXPECT_THROW(rms->cancelTicket(0), std::invalid_argument);
    EXPECT_THROW(rms->cancelTicket(-1), std::invalid_argument);
}


TEST_F(RMSFacadeTest, CancelTicket_ThrowsForNonExistent) {
    EXPECT_THROW(rms->cancelTicket(999), std::runtime_error);
}

TEST_F(RMSFacadeTest, CancelTicket_ThrowsIfAlreadyCancelled) {
    Train t = rms->addTrain("Express", 10);
    rms->addPassenger("John");
    Ticket ticket = rms->bookTicket(t.getTrainId(), "John");

    rms->cancelTicket(ticket.getId());

    EXPECT_THROW(rms->cancelTicket(ticket.getId()), std::runtime_error);
}

TEST_F(RMSFacadeTest, CancelTicket_WithWaitingListReallocation_Option2) {
    // Create train with 1 seat
    Train t = rms->addTrain("Small", 1);
    int trainId = t.getTrainId();

    // Fill train with first passenger
    rms->addPassenger("First");
    Ticket ticket1 = rms->bookTicket(trainId, "First");

    // Try to book second passenger (should fail - train full)
    rms->addPassenger("Second");
    EXPECT_THROW(rms->bookTicket(trainId, "Second"), std::runtime_error);

    // Cancel first ticket - should trigger booking for waiting passenger (Second)
    rms->cancelTicket(ticket1.getId());

    // Check that second passenger got the seat
    auto tickets = rms->listTickets();
    EXPECT_EQ(tickets.size(), 2); // First (cancelled) + Second (booked)

    // Find the active (booked) ticket
    bool foundSecond = false;
    for (const auto& ticket : tickets) {
        if (ticket.getStatus() == booked &&
            ticket.getPassenger().getName() == "Second") {
            foundSecond = true;
            break;
        }
    }
    EXPECT_TRUE(foundSecond);
}

TEST_F(RMSFacadeTest, CancelledSeatsLIFO_Behavior_Option2) {
    Train t = rms->addTrain("LIFO Test", 3);
    rms->addPassenger("P1");
    rms->addPassenger("P2");
    rms->addPassenger("P3");
    rms->addPassenger("P4");

    // Book all seats
    Ticket t1 = rms->bookTicket(t.getTrainId(), "P1"); // Seat 1
    Ticket t2 = rms->bookTicket(t.getTrainId(), "P2"); // Seat 2
    Ticket t3 = rms->bookTicket(t.getTrainId(), "P3"); // Seat 3

    // Cancel in order: Seat 2, then Seat 1
    rms->cancelTicket(t2.getId()); // Cancels Seat 2 (goes to cancelledSeats stack)
    rms->cancelTicket(t1.getId()); // Cancels Seat 1 (goes to cancelledSeats stack - top)

    // Now book P4 - should get Seat 1 (last cancelled - LIFO)
    Ticket t4 = rms->bookTicket(t.getTrainId(), "P4");
    EXPECT_EQ(t4.getSeat(), 1); // Last in, first out

    // Next booking should get Seat 2
    rms->addPassenger("P5");
    Ticket t5 = rms->bookTicket(t.getTrainId(), "P5");
    EXPECT_EQ(t5.getSeat(), 2); // Next from cancelledSeats stack
}

// ================= INTEGRATION TESTS =================

TEST_F(RMSFacadeTest, FullWorkflow_Scenario) {
    // 1. Admin sets up system
    Train express = rms->addTrain("Hogwarts Express", 100);
    // Explicitly add passengers for consistency and verification
    rms->addPassenger("Harry");
    rms->addPassenger("Ron");

    // 2. Users book tickets using names
    Ticket t1 = rms->bookTicket(express.getTrainId(), "Harry");
    Ticket t2 = rms->bookTicket(express.getTrainId(), "Ron");

    // 3. Verify Manifest
    auto tickets = rms->listTickets();
    EXPECT_EQ(tickets.size(), 2);

    // 4. Ron cancels
    rms->cancelTicket(t2.getId());

    // 5. Verify cancellation logic
    int activeCount = 0;
    int cancelledCount = 0;
    for(const auto& t : rms->listTickets()) {
        if(t.getStatus() == booked) activeCount++;
        if(t.getStatus() == cancelled) cancelledCount++;
    }

    EXPECT_EQ(activeCount, 1);
    EXPECT_EQ(cancelledCount, 1);

    // 6. Verify passengers still exist
    auto passengers = rms->listPassengers();
    EXPECT_EQ(passengers.size(), 2);
}

TEST_F(RMSFacadeTest, ComplexScenario_MultipleTrainsAndPassengers) {
    // Setup multiple trains
    Train t1 = rms->addTrain("Express A", 5);
    Train t2 = rms->addTrain("Express B", 3);

    // Add multiple passengers
    rms->addPassenger("Alice");
    rms->addPassenger("Bob");
    rms->addPassenger("Charlie");
    rms->addPassenger("David");

    // Book tickets across different trains
    rms->bookTicket(t1.getTrainId(), "Alice");
    rms->bookTicket(t1.getTrainId(), "Bob");
    rms->bookTicket(t2.getTrainId(), "Charlie");
    rms->bookTicket(t2.getTrainId(), "David");

    // Verify counts
    auto trains = rms->listTrains();
    auto passengers = rms->listPassengers();
    auto tickets = rms->listTickets();

    EXPECT_EQ(trains.size(), 2);
    EXPECT_EQ(passengers.size(), 4);
    EXPECT_EQ(tickets.size(), 4);

    // Cancel Bob's ticket
    for (const auto& ticket : tickets) {
        if (ticket.getPassenger().getName() == "Bob") {
            rms->cancelTicket(ticket.getId());
            break;
        }
    }

    // Update train capacity
    rms->updateTrain(t1.getTrainId(), "Express A", 10);

    // Add more seats to train 2
    rms->addSeats(t2.getTrainId(), 2);

    // Verify final state
    trains = rms->listTrains();
    tickets = rms->listTickets();

    EXPECT_EQ(trains[0].getTotalSeats(), 10);
    EXPECT_EQ(trains[1].getTotalSeats(), 5);

    int activeTickets = 0;
    for (const auto& t : tickets) {
        if (t.getStatus() == booked) activeTickets++;
    }
    EXPECT_EQ(activeTickets, 3); // Alice, Charlie, David (Bob cancelled)
}

TEST_F(RMSFacadeTest, EdgeCase_DeletePassengerWithTickets) {
    Train t = rms->addTrain("Express", 10);
    Passenger p = rms->addPassenger("John");
    Ticket ticket = rms->bookTicket(t.getTrainId(), "John");

    // Delete passenger
    rms->deletePassenger(p.getId());

    // Ticket should still exist but passenger is gone
    auto tickets = rms->listTickets();
    EXPECT_EQ(tickets.size(), 1);

    // Passenger list should be empty
    auto passengers = rms->listPassengers();
    EXPECT_TRUE(passengers.empty());
}

TEST_F(RMSFacadeTest, EdgeCase_DeleteTrainWithTickets) {
    Train t = rms->addTrain("Express", 10);
    rms->addPassenger("John");
    rms->bookTicket(t.getTrainId(), "John");

    // Delete train
    rms->deleteTrain(t.getTrainId());

    // Train should be gone
    auto trains = rms->listTrains();
    EXPECT_TRUE(trains.empty());

    // Ticket should still exist (orphaned)
    auto tickets = rms->listTickets();
    EXPECT_EQ(tickets.size(), 1);
}

// ================= NEW VALIDATION TESTS =================

TEST_F(RMSFacadeTest, BookTicket_ThrowsWhenTrainHasNoSeats) {
    Train t = rms->addTrain("Empty Train", 0);
    rms->addPassenger("John");

    // Train has 0 seats, should throw
    EXPECT_THROW(rms->bookTicket(t.getTrainId(), "John"), std::runtime_error);
}

TEST_F(RMSFacadeTest, BookTicket_TrimsPassengerName) {
    Train t = rms->addTrain("Express", 10);

    // Leading/trailing whitespace should be trimmed
    Ticket ticket = rms->bookTicket(t.getTrainId(), "  John Doe  ");
    EXPECT_EQ(ticket.getPassenger().getName(), "John Doe");
}

TEST_F(RMSFacadeTest, UpdateTrain_TrimsTrainName) {
    Train original = rms->addTrain("Original Train", 10);
    int id = original.getTrainId();

    // Update with leading/trailing whitespace - should be trimmed
    Train updated = rms->updateTrain(id, "  New Train Name  ", 20);
    EXPECT_EQ(updated.getTrainName(), "New Train Name");
}

TEST_F(RMSFacadeTest, AddPassenger_TrimsName) {
    Passenger p = rms->addPassenger("  Alice Smith  ");
    EXPECT_EQ(p.getName(), "Alice Smith");
}

TEST_F(RMSFacadeTest, Validation_CascadingErrors) {
    // Test that errors cascade properly through the facade
    Train t = rms->addTrain("Test Train", 5);

    // Book a ticket
    rms->addPassenger("John");
    Ticket ticket = rms->bookTicket(t.getTrainId(), "John");

    // Try to cancel with invalid ID
    EXPECT_THROW(rms->cancelTicket(0), std::invalid_argument);
    EXPECT_THROW(rms->cancelTicket(-5), std::invalid_argument);

    // Valid cancellation
    EXPECT_NO_THROW(rms->cancelTicket(ticket.getId()));

    // Try to cancel already cancelled ticket
    EXPECT_THROW(rms->cancelTicket(ticket.getId()), std::runtime_error);
}

TEST_F(RMSFacadeTest, ErrorMessages_AreDescriptive) {
    try {
        rms->addTrain("", 10);
        FAIL() << "Expected std::invalid_argument";
    } catch (const std::invalid_argument& e) {
        EXPECT_NE(std::string(e.what()).find("Train name cannot be empty"), std::string::npos);
    }

    try {
        rms->addPassenger("");
        FAIL() << "Expected std::invalid_argument";
    } catch (const std::invalid_argument& e) {
        EXPECT_NE(std::string(e.what()).find("Passenger name cannot be empty"), std::string::npos);
    }

    try {
        rms->bookTicket(0, "John");
        FAIL() << "Expected std::invalid_argument";
    } catch (const std::invalid_argument& e) {
        EXPECT_NE(std::string(e.what()).find("Train ID must be greater than 0"), std::string::npos);
    }
}


==================================================
FILE PATH: .\tests\test_helpers.cpp
==================================================

#include <iostream>
#include <vector>
#include <string>
#include <chrono>
#include "utils/helpers.h"
#include <cctype>
#include <stdexcept>
#include <regex>


// Print functions omitted to focus on logic testing,
// as they only output to cout and return void.

// =========================================================
// TEST SUITE
// =========================================================

// Helper macros for clean output
#define ASSERT_EQUAL(expected, actual) \
    if ((expected) != (actual)) { \
        std::cerr << " [FAIL] " << __FUNCTION__ << " line " << __LINE__ \
                  << ": Expected '" << (expected) << "', got '" << (actual) << "'" << std::endl; \
        exit(1); \
    } else { \
        std::cout << " [PASS] " << #expected << " == " << #actual << std::endl; \
    }

#define ASSERT_TRUE(condition) \
    if (!(condition)) { \
        std::cerr << " [FAIL] " << __FUNCTION__ << " line " << __LINE__ \
                  << ": Condition false: " << #condition << std::endl; \
        exit(1); \
    }

#define ASSERT_THROWS(expression, exceptionType) \
    try { \
        expression; \
        std::cerr << " [FAIL] " << __FUNCTION__ << " line " << __LINE__ \
                  << ": Expected exception " << #exceptionType << " not thrown." << std::endl; \
        exit(1); \
    } catch (const exceptionType&) { \
        std::cout << " [PASS] Exception caught as expected: " << #exceptionType << std::endl; \
    } catch (...) { \
        std::cerr << " [FAIL] " << __FUNCTION__ << " line " << __LINE__ \
                  << ": Wrong exception type caught." << std::endl; \
        exit(1); \
    }

void test_trim() {
    std::cout << "\n--- Testing trim() ---" << std::endl;
    ASSERT_EQUAL("hello", trim("hello"));
    ASSERT_EQUAL("hello", trim("  hello"));
    ASSERT_EQUAL("hello", trim("hello  "));
    ASSERT_EQUAL("hello", trim("  hello  "));
    ASSERT_EQUAL("", trim(""));
    ASSERT_EQUAL("", trim("   "));
    ASSERT_EQUAL("hello world", trim("  hello world  ")); // Middle spaces preserved
}

void test_toLowerCase() {
    std::cout << "\n--- Testing toLowerCase() ---" << std::endl;
    ASSERT_EQUAL("hello", toLowerCase("HELLO"));
    ASSERT_EQUAL("hello", toLowerCase("Hello"));
    ASSERT_EQUAL("123", toLowerCase("123")); // Numbers untouched
    ASSERT_EQUAL("", toLowerCase(""));
    ASSERT_EQUAL("hello world", toLowerCase("HELLO WORLD"));
}

void test_parseInt() {
    std::cout << "\n--- Testing parseInt() ---" << std::endl;

    // Normal cases
    ASSERT_EQUAL(123, parseInt("123", "ID"));
    ASSERT_EQUAL(-50, parseInt("-50", "Balance"));

    // Error cases
    ASSERT_THROWS(parseInt("12a", "ID"), std::invalid_argument);
    ASSERT_THROWS(parseInt("abc", "ID"), std::invalid_argument);
    ASSERT_THROWS(parseInt("", "ID"), std::invalid_argument);
    ASSERT_THROWS(parseInt("   ", "ID"), std::invalid_argument);
    ASSERT_THROWS(parseInt("12.5", "ID"), std::invalid_argument); // Float is invalid for int parsing logic provided

    // Boundary/Overflow cases
    ASSERT_THROWS(parseInt("9999999999999999999", "ID"), std::out_of_range);
}

void test_isValidName() {
    std::cout << "\n--- Testing isValidName() ---" << std::endl;

    ASSERT_TRUE(isValidName("John"));
    ASSERT_TRUE(isValidName("Sarah Connor"));
    ASSERT_TRUE(isValidName("Jean-Luc"));
    ASSERT_TRUE(isValidName("O'Neil"));

    // Fail cases
    ASSERT_EQUAL(false, isValidName("John123")); // Numbers
    ASSERT_EQUAL(false, isValidName(" John"));   // Leading space
    ASSERT_EQUAL(false, isValidName("John "));   // Trailing space
    ASSERT_EQUAL(false, isValidName(""));        // Empty
    ASSERT_EQUAL(false, isValidName("-John"));   // Starts with hyphen
    ASSERT_EQUAL(false, isValidName("John--Doe")); // Double hyphen (depending on your regex strictly)
}

void test_combineString() {
    std::cout << "\n--- Testing combineString() ---" << std::endl;
    std::vector<std::string> args = {"cmd", "John", "Doe", "Smith"};
    std::vector<std::string> invalidArgs = {"cmd", "John", "123"};

    // Test overload 1 (start to end)
    ASSERT_EQUAL("John Doe Smith", combineString(args, 1));
    ASSERT_EQUAL("Doe Smith", combineString(args, 2));

    // Test Invalid Name inside vector
    ASSERT_THROWS(combineString(invalidArgs, 1), std::runtime_error);

    // Test overload 2 (start to specific end)
    // Note: If you meant 'end' is inclusive or exclusive matters.
    // Assuming standard C++ style (exclusive) or size based.
    // Based on logic: i < end.

    ASSERT_EQUAL("John Doe", combineString(args, 1, 3));

    // Test Range Errors
    ASSERT_THROWS(combineString(args, 10, 12), std::runtime_error); // Start out of bounds
    ASSERT_THROWS(combineString(args, 2, 1), std::runtime_error);   // End before start
}

void test_compareString() {
    std::cout << "\n--- Testing compareString() ---" << std::endl;
    ASSERT_TRUE(compareString("Hello", "hello"));
    ASSERT_TRUE(compareString("  JoHn  ", "john"));
    ASSERT_TRUE(compareString("", "   "));

    ASSERT_EQUAL(false, compareString("Apple", "Banana"));
}

void test_isInteger() {
    std::cout << "\n--- Testing isInteger() ---" << std::endl;
    ASSERT_TRUE(isInteger("123"));
    ASSERT_TRUE(isInteger("-123"));
    ASSERT_EQUAL(false, isInteger("12a"));
    ASSERT_EQUAL(false, isInteger("abc"));

    // Note: stoi handles "123 " (trailing space) as valid usually, but your wrapper catches exceptions.
    // Standard stoi("123 ") works.
    ASSERT_TRUE(isInteger(" 123 "));
}

void stress_test() {
    std::cout << "\n--- Running Heavy Stress Test ---" << std::endl;

    auto start = std::chrono::high_resolution_clock::now();

    // 1. Hammer toLowerCase and trim
    std::string huge = "   START ";
    for(int i=0; i<10000; i++) huge += "TeStInG ";
    huge += " END   ";

    std::string processed = trim(huge);
    // Should remove leading/trailing but keep middle
    ASSERT_TRUE(processed.size() < huge.size());
    ASSERT_TRUE(processed.front() == 'S');
    ASSERT_TRUE(processed.back() == 'D');

    // 2. Hammer parseInt with bad data
    for(int i=0; i<50000; i++) {
        try {
            parseInt("NOT_A_NUMBER", "dummy");
        } catch(const std::invalid_argument&) {
            // Expected
        }
    }

    auto end = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> diff = end - start;
    std::cout << " [PASS] Stress test finished in " << diff.count() << " s\n";
}


==================================================
FILE PATH: .\tests\test_models.cpp
==================================================

//
// Created by Omar on 12/1/2025.
//

#include <gtest/gtest.h>
#include "models/Passenger.h"
#include "models/Train.h"
#include "models/SeatAllocator.h"
#include "models/Ticket.h"
#include <vector>

class IntegrationTest : public ::testing::Test {
protected:
    void SetUp() override {}
    void TearDown() override {}
};

// ============================================================================
// BASIC BOOKING FLOW TESTS
// ============================================================================

TEST_F(IntegrationTest, CompleteBookingFlow) {
// Create train
Train train(1, "Express", 5);

// Create passenger
Passenger passenger(101, "John Doe");

// Allocate seat
int seatNumber = train.getSeatAllocator()->allocateSeat(passenger.getId());
EXPECT_GT(seatNumber, 0);

// Create ticket
Ticket ticket(1, seatNumber, train.getTrainId(), passenger);

// Verify ticket details
EXPECT_EQ(ticket.getSeat(), seatNumber);
EXPECT_EQ(ticket.getTrainId(), train.getTrainId());
EXPECT_EQ(ticket.getPassenger().getId(), passenger.getId());
EXPECT_EQ(ticket.getStatus(), booked);
}

TEST_F(IntegrationTest, MultiplePassengersBooking) {
Train train(1, "Express", 10);
std::vector<Passenger> passengers;
std::vector<Ticket> tickets;

// Create and book for 5 passengers
for (int i = 1; i <= 5; i++) {
Passenger p(100 + i, "Passenger " + std::to_string(i));
passengers.push_back(p);

int seat = train.getSeatAllocator()->allocateSeat(p.getId());
EXPECT_EQ(seat, i);

Ticket ticket(i, seat, train.getTrainId(), p);
tickets.push_back(ticket);
}

EXPECT_EQ(tickets.size(), 5);
EXPECT_EQ(train.getSeatAllocator()->getAllocatedSeatCount(), 5);
EXPECT_TRUE(train.hasAvailableSeats());
}

TEST_F(IntegrationTest, BookingUntilFull) {
Train train(1, "Express", 3);

Passenger p1(101, "John");
Passenger p2(102, "Jane");
Passenger p3(103, "Bob");

int seat1 = train.getSeatAllocator()->allocateSeat(p1.getId());
int seat2 = train.getSeatAllocator()->allocateSeat(p2.getId());
int seat3 = train.getSeatAllocator()->allocateSeat(p3.getId());

EXPECT_EQ(seat1, 1);
EXPECT_EQ(seat2, 2);
EXPECT_EQ(seat3, 3);
EXPECT_FALSE(train.hasAvailableSeats());
}

// ============================================================================
// CANCELLATION FLOW TESTS
// ============================================================================

TEST_F(IntegrationTest, BookingCancellationFlow) {
Train train(1, "Express", 5);
Passenger passenger(101, "John Doe");

int seatNumber = train.getSeatAllocator()->allocateSeat(passenger.getId());
Ticket ticket(1, seatNumber, train.getTrainId(), passenger);

// Cancel ticket
ticket.setStatus(cancelled);
int result = train.getSeatAllocator()->freeSeat(seatNumber);

EXPECT_EQ(ticket.getStatus(), cancelled);
EXPECT_EQ(result, 0); // No waiting passenger
EXPECT_TRUE(train.hasAvailableSeats());
}

TEST_F(IntegrationTest, CancellationWithReallocation) {
Train train(1, "Express", 2);

Passenger p1(101, "John");
Passenger p2(102, "Jane");

int seat1 = train.getSeatAllocator()->allocateSeat(p1.getId());
int seat2 = train.getSeatAllocator()->allocateSeat(p2.getId());

Ticket ticket1(1, seat1, train.getTrainId(), p1);
Ticket ticket2(2, seat2, train.getTrainId(), p2);

// Cancel ticket1 and reallocate
ticket1.setStatus(cancelled);
train.getSeatAllocator()->freeSeat(seat1);

Passenger p3(103, "Bob");
int seat3 = train.getSeatAllocator()->allocateSeat(p3.getId());

EXPECT_EQ(seat3, seat1); // Should get cancelled seat
}

TEST_F(IntegrationTest, MultipleCancellationsSequence) {
Train train(1, "Express", 5);
std::vector<Ticket> tickets;

// Book all seats
for (int i = 1; i <= 5; i++) {
Passenger p(100 + i, "Passenger " + std::to_string(i));
int seat = train.getSeatAllocator()->allocateSeat(p.getId());
tickets.push_back(Ticket(i, seat, train.getTrainId(), p));
}

// Cancel tickets 1, 2, 3
for (int i = 0; i < 3; i++) {
tickets[i].setStatus(cancelled);
train.getSeatAllocator()->freeSeat(tickets[i].getSeat());
}

EXPECT_EQ(train.getSeatAllocator()->getAvailableSeatCount(), 3);
EXPECT_EQ(train.getSeatAllocator()->getAllocatedSeatCount(), 2);
}

// ============================================================================
// WAITING LIST FLOW TESTS
// ============================================================================

TEST_F(IntegrationTest, WaitingListBasicFlow) {
Train train(1, "Express", 2);

Passenger p1(101, "John");
Passenger p2(102, "Jane");
Passenger p3(103, "Bob");

// Fill train
train.getSeatAllocator()->allocateSeat(p1.getId());
train.getSeatAllocator()->allocateSeat(p2.getId());

// Try to book when full
int seat3 = train.getSeatAllocator()->allocateSeat(p3.getId());
EXPECT_EQ(seat3, -1);
EXPECT_FALSE(train.getSeatAllocator()->getWaitingList().empty());
}

TEST_F(IntegrationTest, WaitingListAutoAllocation) {
Train train(1, "Express", 2);

Passenger p1(101, "John");
Passenger p2(102, "Jane");
Passenger p3(103, "Bob");

int seat1 = train.getSeatAllocator()->allocateSeat(p1.getId());
int seat2 = train.getSeatAllocator()->allocateSeat(p2.getId());

// Add to waiting list
train.getSeatAllocator()->allocateSeat(p3.getId());

// Cancel first booking - should auto-assign to waiting passenger
int newPassenger = train.getSeatAllocator()->freeSeat(seat1);
EXPECT_EQ(newPassenger, p3.getId());

// Verify waiting list is empty
EXPECT_TRUE(train.getSeatAllocator()->getWaitingList().empty());
}

TEST_F(IntegrationTest, MultipleWaitingPassengers) {
Train train(1, "Express", 2);

// Fill train
train.getSeatAllocator()->allocateSeat(101);
train.getSeatAllocator()->allocateSeat(102);

// Add multiple to waiting list
train.getSeatAllocator()->allocateSeat(103);
train.getSeatAllocator()->allocateSeat(104);
train.getSeatAllocator()->allocateSeat(105);

std::queue<int> waiting = train.getSeatAllocator()->getWaitingList();
EXPECT_EQ(waiting.size(), 3);

// Free one seat - first waiting gets it
int assigned = train.getSeatAllocator()->freeSeat(1);
EXPECT_EQ(assigned, 103);

waiting = train.getSeatAllocator()->getWaitingList();
EXPECT_EQ(waiting.size(), 2);
}

// ============================================================================
// TRAIN CAPACITY MODIFICATION TESTS
// ============================================================================

TEST_F(IntegrationTest, AddSeatsWithActiveBookings) {
Train train(1, "Express", 5);

// Book 3 seats
train.getSeatAllocator()->allocateSeat(101);
train.getSeatAllocator()->allocateSeat(102);
train.getSeatAllocator()->allocateSeat(103);

// Add more seats
train.addSeats(5);

EXPECT_EQ(train.getTotalSeats(), 10);
EXPECT_EQ(train.getSeatAllocator()->getAllocatedSeatCount(), 3);
EXPECT_EQ(train.getSeatAllocator()->getAvailableSeatCount(), 7);
}

TEST_F(IntegrationTest, ExpandTrainToAccommodateWaitingList) {
Train train(1, "Express", 2);

// Fill train and add to waiting list
train.getSeatAllocator()->allocateSeat(101);
train.getSeatAllocator()->allocateSeat(102);
train.getSeatAllocator()->allocateSeat(103); // Waiting
train.getSeatAllocator()->allocateSeat(104); // Waiting

// Expand train
train.addSeats(3);

// Now allocate waiting passengers
EXPECT_TRUE(train.hasAvailableSeats());

// Waiting passengers can now be allocated
int seat3 = train.getSeatAllocator()->allocateSeat(105);
EXPECT_GT(seat3, 0);
}

TEST_F(IntegrationTest, ShrinkTrainWithUnusedCapacity) {
Train train(1, "Express", 10);

// Book only 3 seats
train.getSeatAllocator()->allocateSeat(101);
train.getSeatAllocator()->allocateSeat(102);
train.getSeatAllocator()->allocateSeat(103);

// Shrink to 5 seats (still have space)
train.setSeats(5);

EXPECT_EQ(train.getTotalSeats(), 5);
EXPECT_EQ(train.getSeatAllocator()->getAllocatedSeatCount(), 3);
}

// ============================================================================
// COMPLEX SCENARIO TESTS
// ============================================================================

TEST_F(IntegrationTest, FullOperationalDay) {
Train train(1, "Morning Express", 5);
std::vector<Ticket> activeTickets;

// Morning rush - fill train
for (int i = 1; i <= 5; i++) {
Passenger p(100 + i, "Passenger " + std::to_string(i));
int seat = train.getSeatAllocator()->allocateSeat(p.getId());
activeTickets.push_back(Ticket(i, seat, train.getTrainId(), p));
}

EXPECT_FALSE(train.hasAvailableSeats());

// Two passengers cancel
activeTickets[0].setStatus(cancelled);
activeTickets[2].setStatus(cancelled);
train.getSeatAllocator()->freeSeat(activeTickets[0].getSeat());
train.getSeatAllocator()->freeSeat(activeTickets[2].getSeat());

EXPECT_TRUE(train.hasAvailableSeats());

// New bookings
Passenger p6(106, "Late Passenger 1");
Passenger p7(107, "Late Passenger 2");
int seat6 = train.getSeatAllocator()->allocateSeat(p6.getId());
int seat7 = train.getSeatAllocator()->allocateSeat(p7.getId());

EXPECT_GT(seat6, 0);
EXPECT_GT(seat7, 0);
EXPECT_FALSE(train.hasAvailableSeats());
}

TEST_F(IntegrationTest, TrainUpgradeScenario) {
Train train(1, "Local Train", 10);

// Book 7 seats
for (int i = 1; i <= 7; i++) {
train.getSeatAllocator()->allocateSeat(100 + i);
}

// Train upgraded - add more seats
train.setTrainName("Express Train");
train.addSeats(10);

EXPECT_EQ(train.getTrainName(), "Express Train");
EXPECT_EQ(train.getTotalSeats(), 20);
EXPECT_EQ(train.getSeatAllocator()->getAllocatedSeatCount(), 7);
EXPECT_EQ(train.getSeatAllocator()->getAvailableSeatCount(), 13);
}

TEST_F(IntegrationTest, PeakHourWithWaitingList) {
Train train(1, "Express", 3);

// Fill train
Passenger p1(101, "John");
Passenger p2(102, "Jane");
Passenger p3(103, "Bob");

train.getSeatAllocator()->allocateSeat(p1.getId());
train.getSeatAllocator()->allocateSeat(p2.getId());
train.getSeatAllocator()->allocateSeat(p3.getId());

// Add 3 to waiting list
Passenger p4(104, "Alice");
Passenger p5(105, "Charlie");
Passenger p6(106, "Diana");

train.getSeatAllocator()->allocateSeat(p4.getId());
train.getSeatAllocator()->allocateSeat(p5.getId());
train.getSeatAllocator()->allocateSeat(p6.getId());

std::queue<int> waiting = train.getSeatAllocator()->getWaitingList();
EXPECT_EQ(waiting.size(), 3);

// One cancellation
int newPassenger = train.getSeatAllocator()->freeSeat(1);
EXPECT_EQ(newPassenger, p4.getId());

waiting = train.getSeatAllocator()->getWaitingList();
EXPECT_EQ(waiting.size(), 2);
}

// ============================================================================
// EDGE CASE INTEGRATION TESTS
// ============================================================================

TEST_F(IntegrationTest, SingleSeatTrainOperations) {
Train train(1, "Mini Train", 1);
Passenger p1(101, "John");

int seat = train.getSeatAllocator()->allocateSeat(p1.getId());
EXPECT_EQ(seat, 1);
EXPECT_FALSE(train.hasAvailableSeats());

Passenger p2(102, "Jane");
int seat2 = train.getSeatAllocator()->allocateSeat(p2.getId());
EXPECT_EQ(seat2, -1); // Goes to waiting

train.getSeatAllocator()->freeSeat(1);
// p2 should now have seat 1
EXPECT_TRUE(train.getSeatAllocator()->getWaitingList().empty());
}

TEST_F(IntegrationTest, PassengerWithMultipleBookingAttempts) {
Train train(1, "Express", 5);
Passenger passenger(101, "John Doe");

int seat1 = train.getSeatAllocator()->allocateSeat(passenger.getId());
EXPECT_GT(seat1, 0);

// Try to book again with same ID
int seat2 = train.getSeatAllocator()->allocateSeat(passenger.getId());
EXPECT_EQ(seat2, -1); // Should fail
}

TEST_F(IntegrationTest, CopyTrainWithBookings) {
Train train(1, "Express", 5);

train.getSeatAllocator()->allocateSeat(101);
train.getSeatAllocator()->allocateSeat(102);
train.getSeatAllocator()->allocateSeat(103);

Train trainCopy(train);

EXPECT_EQ(trainCopy.getTotalSeats(), train.getTotalSeats());
EXPECT_EQ(trainCopy.getSeatAllocator()->getAllocatedSeatCount(),
train.getSeatAllocator()->getAllocatedSeatCount());

// Verify independence
trainCopy.getSeatAllocator()->allocateSeat(104);
EXPECT_NE(trainCopy.getSeatAllocator()->getAllocatedSeatCount(),
train.getSeatAllocator()->getAllocatedSeatCount());
}

// ============================================================================
// DATA CONSISTENCY TESTS
// ============================================================================

TEST_F(IntegrationTest, TicketDataMatchesAllocation) {
Train train(1, "Express", 5);
Passenger passenger(101, "John Doe");

int allocatedSeat = train.getSeatAllocator()->allocateSeat(passenger.getId());
Ticket ticket(1, allocatedSeat, train.getTrainId(), passenger);

EXPECT_EQ(ticket.getSeat(), allocatedSeat);
EXPECT_EQ(ticket.getTrainId(), train.getTrainId());
EXPECT_EQ(ticket.getPassenger().getId(), passenger.getId());
EXPECT_EQ(ticket.getPassenger().getName(), passenger.getName());
}

TEST_F(IntegrationTest, ConsistencyAfterMultipleOperations) {
Train train(1, "Express", 10);

// Multiple allocations and cancellations
std::vector<int> seats;
for (int i = 1; i <= 5; i++) {
int seat = train.getSeatAllocator()->allocateSeat(100 + i);
seats.push_back(seat);
}

train.getSeatAllocator()->freeSeat(seats[1]);
train.getSeatAllocator()->freeSeat(seats[3]);

train.getSeatAllocator()->allocateSeat(201);
train.getSeatAllocator()->allocateSeat(202);

// Check consistency
int total = train.getTotalSeats();
int allocated = train.getSeatAllocator()->getAllocatedSeatCount();
int available = train.getSeatAllocator()->getAvailableSeatCount();

EXPECT_EQ(total, allocated + available);
}



==================================================
FILE PATH: .\tests\test_passenger.cpp
==================================================

#include <gtest/gtest.h>
#include "models/Passenger.h"

class PassengerTest : public ::testing::Test {
protected:
    void SetUp() override {}
    void TearDown() override {}
};


TEST_F(PassengerTest, ValidConstruction) {
    Passenger p(1, "John Doe");
    EXPECT_EQ(p.getId(), 1);
    EXPECT_EQ(p.getName(), "John Doe");
}

TEST_F(PassengerTest, InvalidIdThrowsException) {
    EXPECT_THROW(Passenger(-1, "John Doe"), std::runtime_error);
}

TEST_F(PassengerTest, EmptyNameThrowsException) {
    EXPECT_THROW(Passenger(1, ""), std::runtime_error);
}

TEST_F(PassengerTest, SetValidId) {
    Passenger p(1, "John Doe");
    p.setId(2);
    EXPECT_EQ(p.getId(), 2);
}

TEST_F(PassengerTest, SetInvalidIdThrowsException) {
    Passenger p(1, "John Doe");
    EXPECT_THROW(p.setId(-1), std::runtime_error);
}

TEST_F(PassengerTest, SetValidName) {
    Passenger p(1, "John Doe");
    p.setName("Jane Smith");
    EXPECT_EQ(p.getName(), "Jane Smith");
}

TEST_F(PassengerTest, SetEmptyNameThrowsException) {
    Passenger p(1, "John Doe");
    EXPECT_THROW(p.setName(""), std::runtime_error);
}

==================================================
FILE PATH: .\tests\test_passengerRepoMemo.cpp
==================================================

#include <gtest/gtest.h>
#include "models/Passenger.h"
#include "Repo/InMemoryPassengerRepository.h"
#include <optional>

class InMemoryPassengerRepositoryTest : public ::testing::Test {
protected:
    InMemoryPassengerRepository repo;

    void SetUp() override {
        repo.clear();
    }

    void TearDown() override {
        repo.clear();
    }
};

TEST_F(InMemoryPassengerRepositoryTest, SavePassengerWithZeroIdGeneratesNewId) {
    Passenger p(0, "Alice");
    repo.save(p);
    EXPECT_GT(p.getId(), 0);
}

TEST_F(InMemoryPassengerRepositoryTest, SaveGeneratesSequentialIds) {
    Passenger p1(0, "Alice");
    Passenger p2(0, "Bob");

    repo.save(p1);
    repo.save(p2);

    EXPECT_EQ(1, p1.getId());
    EXPECT_EQ(2, p2.getId());
}

TEST_F(InMemoryPassengerRepositoryTest, SavePassengerWithExistingIdPreservesId) {
    Passenger p(42, "Charlie");
    repo.save(p);
    EXPECT_EQ(42, p.getId());
}

TEST_F(InMemoryPassengerRepositoryTest, SaveUpdatesExistingPassenger) {
    Passenger p(0, "David");
    repo.save(p);
    int originalId = p.getId();

    Passenger updated(originalId, "David Updated");
    repo.save(updated);

    auto retrieved = repo.getPassenger(originalId);
    ASSERT_TRUE(retrieved.has_value());
    EXPECT_EQ(originalId, retrieved->getId());
    EXPECT_EQ("David Updated", retrieved->getName());
}

TEST_F(InMemoryPassengerRepositoryTest, SaveMultipleTimesWithSameId) {
    Passenger p1(5, "Eve");
    repo.save(p1);

    Passenger p2(5, "Eve Updated");
    repo.save(p2);

    auto retrieved = repo.getPassenger(5);
    ASSERT_TRUE(retrieved.has_value());
    EXPECT_EQ("Eve Updated", retrieved->getName());

    std::vector<Passenger> all = repo.getAllPassengers();
    EXPECT_EQ(1, all.size());
}

TEST_F(InMemoryPassengerRepositoryTest, GetPassengerReturnsCorrectPassenger) {
    Passenger p(0, "Frank");
    repo.save(p);

    auto retrieved = repo.getPassenger(p.getId());

    ASSERT_TRUE(retrieved.has_value());
    EXPECT_EQ(p.getId(), retrieved->getId());
    EXPECT_EQ("Frank", retrieved->getName());
}

TEST_F(InMemoryPassengerRepositoryTest, GetPassengerReturnsNulloptWhenNotFound) {
    // Implementation returns nullopt, does not throw
    auto result = repo.getPassenger(999);
    EXPECT_FALSE(result.has_value());
}

TEST_F(InMemoryPassengerRepositoryTest, GetPassengerAfterMultipleSaves) {
    Passenger p1(0, "Grace");
    Passenger p2(0, "Henry");
    Passenger p3(0, "Ivan");

    repo.save(p1);
    repo.save(p2);
    repo.save(p3);

    auto retrieved = repo.getPassenger(p2.getId());
    ASSERT_TRUE(retrieved.has_value());
    EXPECT_EQ("Henry", retrieved->getName());
}

TEST_F(InMemoryPassengerRepositoryTest, GetAllPassengersReturnsEmptyvectorWhenEmpty) {
    std::vector<Passenger> passengers = repo.getAllPassengers();
    EXPECT_TRUE(passengers.empty());
}

TEST_F(InMemoryPassengerRepositoryTest, GetAllPassengersReturnsAllSavedPassengers) {
    Passenger p1(0, "Jack");
    Passenger p2(0, "Kate");
    Passenger p3(0, "Liam");

    repo.save(p1);
    repo.save(p2);
    repo.save(p3);

    std::vector<Passenger> passengers = repo.getAllPassengers();
    EXPECT_EQ(3, passengers.size());
}

TEST_F(InMemoryPassengerRepositoryTest, GetAllPassengersContainsCorrectData) {
    Passenger p1(0, "Mia");
    Passenger p2(0, "Noah");

    repo.save(p1);
    repo.save(p2);

    std::vector<Passenger> passengers = repo.getAllPassengers();

    bool foundMia = false;
    bool foundNoah = false;

    for (const auto& p : passengers) {
        if (p.getName() == "Mia") foundMia = true;
        if (p.getName() == "Noah") foundNoah = true;
    }

    EXPECT_TRUE(foundMia);
    EXPECT_TRUE(foundNoah);
}

TEST_F(InMemoryPassengerRepositoryTest, DeletePassengerRemovesPassenger) {
    Passenger p(0, "Olivia");
    repo.save(p);
    int id = p.getId();

    bool deleted = repo.deletePassenger(id);

    EXPECT_TRUE(deleted);

    auto result = repo.getPassenger(id);
    EXPECT_FALSE(result.has_value());
}

TEST_F(InMemoryPassengerRepositoryTest, DeletePassengerReturnsFalseWhenNotFound) {
    bool deleted = repo.deletePassenger(999);
    EXPECT_FALSE(deleted);
}

TEST_F(InMemoryPassengerRepositoryTest, DeletePassengerReducesCount) {
    Passenger p1(0, "Paul");
    Passenger p2(0, "Quinn");

    repo.save(p1);
    repo.save(p2);

    EXPECT_EQ(2, repo.getAllPassengers().size());

    repo.deletePassenger(p1.getId());

    EXPECT_EQ(1, repo.getAllPassengers().size());
}

TEST_F(InMemoryPassengerRepositoryTest, DeleteAllPassengersOneByOne) {
    Passenger p1(0, "Rachel");
    Passenger p2(0, "Sam");
    Passenger p3(0, "Tina");

    repo.save(p1);
    repo.save(p2);
    repo.save(p3);

    repo.deletePassenger(p1.getId());
    repo.deletePassenger(p2.getId());
    repo.deletePassenger(p3.getId());

    EXPECT_TRUE(repo.getAllPassengers().empty());
}

TEST_F(InMemoryPassengerRepositoryTest, ClearRemovesAllPassengers) {
    Passenger p1(0, "Uma");
    Passenger p2(0, "Victor");
    repo.save(p1);
    repo.save(p2);

    repo.clear();

    std::vector<Passenger> passengers = repo.getAllPassengers();
    EXPECT_TRUE(passengers.empty());
}

TEST_F(InMemoryPassengerRepositoryTest, ClearResetsNextId) {
    Passenger p1(0, "Wendy");
    repo.save(p1);
    repo.clear();

    Passenger p2(0, "Xavier");
    repo.save(p2);

    EXPECT_EQ(1, p2.getId());
}

TEST_F(InMemoryPassengerRepositoryTest, ClearCanBeCalledMultipleTimes) {
    repo.clear();
    repo.clear();
    EXPECT_TRUE(repo.getAllPassengers().empty());
}

TEST_F(InMemoryPassengerRepositoryTest, SaveWithHighIdUpdatesNextId) {
    Passenger p1(100, "Yara");
    repo.save(p1);

    Passenger p2(0, "Zara");
    repo.save(p2);

    EXPECT_EQ(101, p2.getId());
}

TEST_F(InMemoryPassengerRepositoryTest, SaveWithMultipleHighIds) {
    Passenger p1(50, "Adam");
    Passenger p2(100, "Beth");
    Passenger p3(0, "Carl");

    repo.save(p1);
    repo.save(p2);
    repo.save(p3);

    EXPECT_EQ(101, p3.getId());
}

TEST_F(InMemoryPassengerRepositoryTest, SaveAfterDeleteMaintainsNextId) {
    Passenger p1(0, "Dana");
    Passenger p2(0, "Evan");

    repo.save(p1);
    repo.save(p2);

    repo.deletePassenger(p1.getId());

    Passenger p3(0, "Fiona");
    repo.save(p3);

    EXPECT_EQ(3, p3.getId());
}

==================================================
FILE PATH: .\tests\test_passengerService.cpp
==================================================

#include <gtest/gtest.h>
#include "models/Passenger.h"
#include "Repo/InMemoryPassengerRepository.h"
#include "Services/PassengerService.h"
#include "utils/helpers.h"
#include <optional>

class PassengerServiceTest : public ::testing::Test {
protected:
    InMemoryPassengerRepository repo;
    PassengerService* service;

    void SetUp() override {
        repo.clear();
        service = new PassengerService(&repo);
    }

    void TearDown() override {
        delete service;
        repo.clear();
    }
};

/// ------------------------------------------------------------
/// BASIC CREATION TESTS
/// ------------------------------------------------------------

TEST_F(PassengerServiceTest, CreatePassenger_AssignsUniqueIds) {
    Passenger a = service->createPassenger("A");
    Passenger b = service->createPassenger("B");

    EXPECT_NE(a.getId(), b.getId());
}

TEST_F(PassengerServiceTest, CreatePassenger_TrimsName) {
    Passenger p = service->createPassenger("  Omar  ");
    // According to RMSFacade::addPassenger, names are trimmed
    EXPECT_EQ("Omar", p.getName());  // Trimmed version
}

TEST_F(PassengerServiceTest, CreatePassenger_ValidatesName) {
    // Based on Passenger constructor, empty name should throw
    EXPECT_THROW(service->createPassenger(""), std::runtime_error);
}

TEST_F(PassengerServiceTest, CreatePassenger_DoesNotModifyRepositoryObjectDirectly) {
    Passenger p = service->createPassenger("Test");
    auto retrievedOpt = service->getPassenger(p.getId());

    ASSERT_TRUE(retrievedOpt.has_value());
    EXPECT_EQ(p.getId(), retrievedOpt->getId());
    EXPECT_EQ(p.getName(), retrievedOpt->getName());
}

/// ------------------------------------------------------------
/// GET PASSENGER TESTS
/// ------------------------------------------------------------

TEST_F(PassengerServiceTest, GetPassenger_ReturnsNulloptForNegativeId) {
    EXPECT_FALSE(service->getPassenger(-1).has_value());
}

TEST_F(PassengerServiceTest, GetPassenger_ReturnsNulloptForZeroId) {
    EXPECT_FALSE(service->getPassenger(0).has_value());
}

TEST_F(PassengerServiceTest, GetPassenger_AfterMultipleCreates) {
    Passenger a = service->createPassenger("A");
    Passenger b = service->createPassenger("B");

    auto retrieved = service->getPassenger(b.getId());

    ASSERT_TRUE(retrieved.has_value());
    EXPECT_EQ("B", retrieved->getName());
}

TEST_F(PassengerServiceTest, GetPassenger_ReturnsNulloptForNonExistent) {
    service->createPassenger("A");  // ID 1
    EXPECT_FALSE(service->getPassenger(999).has_value());
}

/// ------------------------------------------------------------
/// GET ALL PASSENGERS TESTS
/// ------------------------------------------------------------

TEST_F(PassengerServiceTest, GetAllPassengers_OrderIsConsistent) {
    service->createPassenger("A");
    service->createPassenger("B");
    service->createPassenger("C");

    std::vector<Passenger> all = service->getAllPassengers();
    EXPECT_EQ(3, all.size());
}

TEST_F(PassengerServiceTest, GetAllPassengers_NotAffectedByExternalModification) {
    service->createPassenger("A");
    std::vector<Passenger> all = service->getAllPassengers();

    // modifying list should NOT modify repo
    all.clear();

    EXPECT_EQ(1, service->getAllPassengers().size());
}

/// ------------------------------------------------------------
/// DELETE PASSENGER TESTS
/// ------------------------------------------------------------

TEST_F(PassengerServiceTest, DeletePassenger_DoesNotAffectOtherPassengers) {
    Passenger p1 = service->createPassenger("A");
    Passenger p2 = service->createPassenger("B");

    service->deletePassenger(p1.getId());

    EXPECT_EQ(1, service->getAllPassengers().size());
    auto remaining = service->getAllPassengers();
    EXPECT_EQ("B", remaining[0].getName());
}

TEST_F(PassengerServiceTest, DeletePassenger_ReturnsFalseForNonExistent) {
    bool result = service->deletePassenger(999);
    EXPECT_FALSE(result);
}

TEST_F(PassengerServiceTest, DeletePassenger_ReturnsTrueForSuccess) {
    Passenger p = service->createPassenger("A");
    bool result = service->deletePassenger(p.getId());
    EXPECT_TRUE(result);
}

/// ------------------------------------------------------------
/// UPDATE PASSENGER TESTS
/// ------------------------------------------------------------

TEST_F(PassengerServiceTest, UpdatePassenger_Success) {
    Passenger p = service->createPassenger("Original");
    int id = p.getId();

    Passenger updated = service->updatePassenger(id, "Updated");

    EXPECT_EQ(updated.getId(), id);
    EXPECT_EQ(updated.getName(), "Updated");

    auto retrieved = service->getPassenger(id);
    ASSERT_TRUE(retrieved.has_value());
    EXPECT_EQ(retrieved->getName(), "Updated");
}

TEST_F(PassengerServiceTest, UpdatePassenger_ThrowsForNonExistent) {
    EXPECT_THROW(service->updatePassenger(999, "NewName"), std::runtime_error);
}

/// ------------------------------------------------------------
/// FIND OR CREATE TESTS (CORE LOGIC)
/// ------------------------------------------------------------

TEST_F(PassengerServiceTest, FindOrCreate_CaseInsensitiveComparison) {
    service->createPassenger("Omar");

    Passenger found = service->find_or_create_passenger("oMaR");

    EXPECT_EQ("Omar", found.getName());
    EXPECT_EQ(1, service->getAllPassengers().size());
}

TEST_F(PassengerServiceTest, FindOrCreate_ReturnsExistingEvenIfExactNameDifferentCase) {
    Passenger p = service->createPassenger("HELLO");

    Passenger found = service->find_or_create_passenger("hello");

    EXPECT_EQ(p.getId(), found.getId());
    EXPECT_EQ("HELLO", found.getName()); // Original case preserved
}

TEST_F(PassengerServiceTest, FindOrCreate_DoesNotMatchSimilarNames) {
    service->createPassenger("John");

    Passenger p = service->find_or_create_passenger("Johnny");

    EXPECT_EQ("Johnny", p.getName());
    EXPECT_EQ(2, service->getAllPassengers().size());
}

TEST_F(PassengerServiceTest, FindOrCreate_AfterDeletionCreatesNewId) {
    Passenger p1 = service->createPassenger("Adam");
    service->deletePassenger(p1.getId());

    Passenger p2 = service->find_or_create_passenger("Adam");

    EXPECT_NE(p1.getId(), p2.getId());
    EXPECT_EQ(1, service->getAllPassengers().size());
}

/// ------------------------------------------------------------
/// STRESS TESTS
/// ------------------------------------------------------------

TEST_F(PassengerServiceTest, Create100Passengers_HaveUniqueIds) {
    std::set<int> ids;

    for (int i = 0; i < 100; i++) {
        Passenger p = service->createPassenger("P" + std::to_string(i));
        ids.insert(p.getId());
    }

    EXPECT_EQ(100, ids.size());
}

TEST_F(PassengerServiceTest, FindOrCreate_Stress100Lookups) {
    service->createPassenger("David");

    for (int i = 0; i < 100; i++) {
        Passenger p = service->find_or_create_passenger("DAVID");
        EXPECT_EQ("David", p.getName());
    }

    EXPECT_EQ(1, service->getAllPassengers().size());
}

==================================================
FILE PATH: .\tests\test_SeatAllocator.cpp
==================================================

// ============================================================================
// SeatAllocatorTest.cpp - SeatAllocator Model Tests
// ============================================================================

#include <gtest/gtest.h>
#include "models/SeatAllocator.h"

class SeatAllocatorTest : public ::testing::Test {
protected:
    void SetUp() override {}
    void TearDown() override {}
};



TEST_F(SeatAllocatorTest, DefaultConstruction) {
    SeatAllocator allocator;
    EXPECT_EQ(allocator.getTotalSeats(), 10);
    EXPECT_EQ(allocator.getAvailableSeatCount(), 10);
    EXPECT_TRUE(allocator.hasAvailableSeats());
}

TEST_F(SeatAllocatorTest, CustomSeatCount) {
    SeatAllocator allocator(20);
    EXPECT_EQ(allocator.getTotalSeats(), 20);
    EXPECT_EQ(allocator.getAvailableSeatCount(), 20);
}

TEST_F(SeatAllocatorTest, InvalidSeatCountDefaultsTo10) {
    SeatAllocator allocator(-5);
    EXPECT_EQ(allocator.getTotalSeats(), 10);
}

TEST_F(SeatAllocatorTest, ZeroSeatCountDefaultsTo10) {
    SeatAllocator allocator(0);
    EXPECT_EQ(allocator.getTotalSeats(), 10);
}

// ============================================================================
// SEAT ALLOCATION TESTS
// ============================================================================

TEST_F(SeatAllocatorTest, AllocateSingleSeat) {
    SeatAllocator allocator(5);
    int seat = allocator.allocateSeat(101);
    EXPECT_EQ(seat, 1);
    EXPECT_EQ(allocator.getAvailableSeatCount(), 4);
    EXPECT_EQ(allocator.getAllocatedSeatCount(), 1);
}

TEST_F(SeatAllocatorTest, AllocateMultipleSeats) {
    SeatAllocator allocator(5);
    EXPECT_EQ(allocator.allocateSeat(101), 1);
    EXPECT_EQ(allocator.allocateSeat(102), 2);
    EXPECT_EQ(allocator.allocateSeat(103), 3);
    EXPECT_EQ(allocator.getAvailableSeatCount(), 2);
    EXPECT_EQ(allocator.getAllocatedSeatCount(), 3);
}

TEST_F(SeatAllocatorTest, AllocateSeatsInOrder) {
    SeatAllocator allocator(5);
    for (int i = 1; i <= 5; i++) {
        int seat = allocator.allocateSeat(100 + i);
        EXPECT_EQ(seat, i);
    }
}

TEST_F(SeatAllocatorTest, DuplicatePassengerIdReturnsMinusOne) {
    SeatAllocator allocator(5);
    allocator.allocateSeat(101);
    int result = allocator.allocateSeat(101);
    EXPECT_EQ(result, -1);
}

TEST_F(SeatAllocatorTest, DuplicatePassengerInWaitingListReturnsMinusOne) {
    SeatAllocator allocator(2);
    allocator.allocateSeat(101);
    allocator.allocateSeat(102);
    allocator.allocateSeat(103); // Goes to waiting list
    int result = allocator.allocateSeat(103); // Try to add same passenger again
    EXPECT_EQ(result, -1);
}

TEST_F(SeatAllocatorTest, FullTrainAddsToWaitingList) {
    SeatAllocator allocator(2);
    allocator.allocateSeat(101);
    allocator.allocateSeat(102);
    int result = allocator.allocateSeat(103);
    EXPECT_EQ(result, -1);
    EXPECT_FALSE(allocator.getWaitingList().empty());
    EXPECT_FALSE(allocator.hasAvailableSeats());
}

TEST_F(SeatAllocatorTest, MultiplePassengersInWaitingList) {
    SeatAllocator allocator(2);
    allocator.allocateSeat(101);
    allocator.allocateSeat(102);
    allocator.allocateSeat(103); // Waiting
    allocator.allocateSeat(104); // Waiting
    allocator.allocateSeat(105); // Waiting

    std::queue<int> waiting = allocator.getWaitingList();
    EXPECT_EQ(waiting.size(), 3);
    EXPECT_EQ(waiting.front(), 103);
}

// ============================================================================
// SEAT FREEING TESTS
// ============================================================================

TEST_F(SeatAllocatorTest, FreeSeatValid) {
    SeatAllocator allocator(5);
    allocator.allocateSeat(101);
    int result = allocator.freeSeat(1);
    EXPECT_EQ(result, 0);
    EXPECT_EQ(allocator.getAvailableSeatCount(), 5);
}

TEST_F(SeatAllocatorTest, FreeSeatInvalidSeatNumberZero) {
    SeatAllocator allocator(5);
    EXPECT_EQ(allocator.freeSeat(0), -1);
}

TEST_F(SeatAllocatorTest, FreeSeatInvalidSeatNumberNegative) {
    SeatAllocator allocator(5);
    EXPECT_EQ(allocator.freeSeat(-1), -1);
}

TEST_F(SeatAllocatorTest, FreeSeatInvalidSeatNumberTooLarge) {
    SeatAllocator allocator(5);
    EXPECT_EQ(allocator.freeSeat(10), -1);
}

TEST_F(SeatAllocatorTest, FreeSeatNotAllocated) {
    SeatAllocator allocator(5);
    int result = allocator.freeSeat(1);
    EXPECT_EQ(result, -1);
}


TEST_F(SeatAllocatorTest, FreeAlreadyFreedSeat) {
    SeatAllocator allocator(5);
    allocator.allocateSeat(101);
    allocator.freeSeat(1);
    int result = allocator.freeSeat(1);
    EXPECT_EQ(result, -1);
}

// ============================================================================
// CANCELLED SEAT REUSE TESTS
// ============================================================================

TEST_F(SeatAllocatorTest, CancelledSeatReusedBeforeNewSeats) {
    SeatAllocator allocator(5);
    allocator.allocateSeat(101); // Seat 1
    allocator.allocateSeat(102); // Seat 2
    allocator.freeSeat(1);       // Free seat 1

    int newSeat = allocator.allocateSeat(103);
    EXPECT_EQ(newSeat, 1); // Should reuse cancelled seat 1
}

TEST_F(SeatAllocatorTest, MultipleCancelledSeatsReusedLIFO) {
    SeatAllocator allocator(5);
    allocator.allocateSeat(101); // Seat 1
    allocator.allocateSeat(102); // Seat 2
    allocator.allocateSeat(103); // Seat 3

    allocator.freeSeat(1);
    allocator.freeSeat(2);

    EXPECT_EQ(allocator.allocateSeat(104), 2); // LIFO - last cancelled first
    EXPECT_EQ(allocator.allocateSeat(105), 1);
}

// ============================================================================
// ADD SEATS TESTS
// ============================================================================

TEST_F(SeatAllocatorTest, AddSeats) {
    SeatAllocator allocator(5);
    allocator.addSeats(5);
    EXPECT_EQ(allocator.getTotalSeats(), 10);
    EXPECT_EQ(allocator.getAvailableSeatCount(), 10);
}

TEST_F(SeatAllocatorTest, AddSeatsWithAllocations) {
    SeatAllocator allocator(5);
    allocator.allocateSeat(101);
    allocator.allocateSeat(102);

    allocator.addSeats(3);
    EXPECT_EQ(allocator.getTotalSeats(), 8);
    EXPECT_EQ(allocator.getAvailableSeatCount(), 6);
    EXPECT_EQ(allocator.getAllocatedSeatCount(), 2);
}

TEST_F(SeatAllocatorTest, AddInvalidSeatsThrowsZero) {
    SeatAllocator allocator(5);
    EXPECT_THROW(allocator.addSeats(0), std::runtime_error);
}

TEST_F(SeatAllocatorTest, AddInvalidSeatsThrowsNegative) {
    SeatAllocator allocator(5);
    EXPECT_THROW(allocator.addSeats(-5), std::runtime_error);
}

TEST_F(SeatAllocatorTest, AddSeatsNewSeatsAvailable) {
    SeatAllocator allocator(3);
    allocator.allocateSeat(101);
    allocator.allocateSeat(102);
    allocator.allocateSeat(103);

    allocator.addSeats(2);
    int newSeat = allocator.allocateSeat(104);
    EXPECT_EQ(newSeat, 4);
}

// ============================================================================
// CHANGE TOTAL SEATS TESTS
// ============================================================================

TEST_F(SeatAllocatorTest, ExpandTotalSeats) {
    SeatAllocator allocator(5);
    allocator.changeTotalSeats(10);
    EXPECT_EQ(allocator.getTotalSeats(), 10);
    EXPECT_EQ(allocator.getAvailableSeatCount(), 10);
}

TEST_F(SeatAllocatorTest, ShrinkTotalSeatsWithSpace) {
    SeatAllocator allocator(10);
    allocator.allocateSeat(101); // Seat 1
    allocator.allocateSeat(102); // Seat 2
    allocator.changeTotalSeats(8); // 2 allocated, 8 free -> shrink by 2
    EXPECT_EQ(allocator.getTotalSeats(), 8);
}

TEST_F(SeatAllocatorTest, ShrinkTotalSeatsWithoutSpaceThrows) {
    SeatAllocator allocator(10);
    for (int i = 1; i <= 10; i++) {
        allocator.allocateSeat(100 + i);
    }
    EXPECT_THROW(allocator.changeTotalSeats(5), std::runtime_error);
}

TEST_F(SeatAllocatorTest, ShrinkBelowAllocatedThrows) {
    SeatAllocator allocator(10);
    allocator.allocateSeat(101);
    allocator.allocateSeat(102);
    allocator.allocateSeat(103);
    EXPECT_THROW(allocator.changeTotalSeats(2), std::runtime_error);
}

TEST_F(SeatAllocatorTest, ChangeTotalSeatsToSameSize) {
    SeatAllocator allocator(10);
    allocator.changeTotalSeats(10);
    EXPECT_EQ(allocator.getTotalSeats(), 10);
}

TEST_F(SeatAllocatorTest, ExpandAfterShrink) {
    SeatAllocator allocator(10);
    allocator.changeTotalSeats(5);
    allocator.changeTotalSeats(15);
    EXPECT_EQ(allocator.getTotalSeats(), 15);
}

// ============================================================================
// COPY AND CLONE TESTS
// ============================================================================

TEST_F(SeatAllocatorTest, CopyConstructor) {
    SeatAllocator allocator(5);
    allocator.allocateSeat(101);
    allocator.allocateSeat(102);

    SeatAllocator copy(allocator);
    EXPECT_EQ(copy.getTotalSeats(), allocator.getTotalSeats());
    EXPECT_EQ(copy.getAvailableSeatCount(), allocator.getAvailableSeatCount());
    EXPECT_EQ(copy.getAllocatedSeatCount(), allocator.getAllocatedSeatCount());
}

TEST_F(SeatAllocatorTest, CopyConstructorIndependence) {
    SeatAllocator allocator(5);
    allocator.allocateSeat(101);

    SeatAllocator copy(allocator);
    copy.allocateSeat(102);

    EXPECT_EQ(allocator.getAllocatedSeatCount(), 1);
    EXPECT_EQ(copy.getAllocatedSeatCount(), 2);
}

TEST_F(SeatAllocatorTest, AssignmentOperator) {
    SeatAllocator allocator(5);
    allocator.allocateSeat(101);

    SeatAllocator other(10);
    other = allocator;
    EXPECT_EQ(other.getTotalSeats(), 5);
    EXPECT_EQ(other.getAllocatedSeatCount(), 1);
}

TEST_F(SeatAllocatorTest, SelfAssignment) {
    SeatAllocator allocator(5);
    allocator.allocateSeat(101);

    allocator = allocator;
    EXPECT_EQ(allocator.getTotalSeats(), 5);
    EXPECT_EQ(allocator.getAllocatedSeatCount(), 1);
}

TEST_F(SeatAllocatorTest, CloneMethod) {
    SeatAllocator allocator(5);
    allocator.allocateSeat(101);

    auto cloned = allocator.clone();
    EXPECT_EQ(cloned->getTotalSeats(), allocator.getTotalSeats());
    EXPECT_EQ(cloned->getAvailableSeatCount(), allocator.getAvailableSeatCount());
    EXPECT_EQ(cloned->getAllocatedSeatCount(), allocator.getAllocatedSeatCount());
}

// ============================================================================
// STATUS AND QUERY TESTS
// ============================================================================

TEST_F(SeatAllocatorTest, HasAvailableSeatsWhenEmpty) {
    SeatAllocator allocator(5);
    EXPECT_TRUE(allocator.hasAvailableSeats());
}

TEST_F(SeatAllocatorTest, HasAvailableSeatsWhenPartiallyFull) {
    SeatAllocator allocator(5);
    allocator.allocateSeat(101);
    EXPECT_TRUE(allocator.hasAvailableSeats());
}

TEST_F(SeatAllocatorTest, HasNoAvailableSeatsWhenFull) {
    SeatAllocator allocator(2);
    allocator.allocateSeat(101);
    allocator.allocateSeat(102);
    EXPECT_FALSE(allocator.hasAvailableSeats());
}

TEST_F(SeatAllocatorTest, GetAvailableSeatCountCorrect) {
    SeatAllocator allocator(10);
    allocator.allocateSeat(101);
    allocator.allocateSeat(102);
    allocator.allocateSeat(103);
    EXPECT_EQ(allocator.getAvailableSeatCount(), 7);
}

TEST_F(SeatAllocatorTest, GetAllocatedSeatCountCorrect) {
    SeatAllocator allocator(10);
    allocator.allocateSeat(101);
    allocator.allocateSeat(102);
    allocator.allocateSeat(103);
    EXPECT_EQ(allocator.getAllocatedSeatCount(), 3);
}

TEST_F(SeatAllocatorTest, TotalEqualsAllocatedPlusAvailable) {
    SeatAllocator allocator(10);
    allocator.allocateSeat(101);
    allocator.allocateSeat(102);

    int total = allocator.getTotalSeats();
    int allocated = allocator.getAllocatedSeatCount();
    int available = allocator.getAvailableSeatCount();

    EXPECT_EQ(total, allocated + available);
}



TEST_F(SeatAllocatorTest, FreeSeatReturnsWaitingPassengerIdButDoesNotAssign) {
    SeatAllocator allocator(1);

    // Fill the single seat
    allocator.allocateSeat(101); // Seat 1

    // Add to waiting list
    allocator.allocateSeat(102); // Waiting

    // Free seat - returns waiting passenger ID
    int waitingPassengerId = allocator.freeSeat(1);
    EXPECT_EQ(waitingPassengerId, 102); // Returns the waiting passenger ID

    // IMPORTANT: Seat is NOT automatically assigned to passenger 102
    // It's in cancelledSeats stack and marked as unallocated (-1)
    EXPECT_TRUE(allocator.hasAvailableSeats()); // Because seat is in cancelledSeats

    // The caller (TicketService) must now call allocateSeat for passenger 102
    int seatFor102 = allocator.allocateSeat(102);
    EXPECT_EQ(seatFor102, 1); // Now gets the seat

    // After allocation, seat is assigned to passenger 102
    EXPECT_FALSE(allocator.hasAvailableSeats()); // No more available seats
}
// ============================================================================
// WAITING LIST AND FREE/ALLOCATE INTERACTION TESTS
// ============================================================================

TEST_F(SeatAllocatorTest, WaitingListReceivesSeatWhenFreed) {
    SeatAllocator allocator(3);

    // Fill all seats
    EXPECT_EQ(allocator.allocateSeat(101), 1);
    EXPECT_EQ(allocator.allocateSeat(102), 2);
    EXPECT_EQ(allocator.allocateSeat(103), 3);

    // Add passenger to waiting list
    EXPECT_EQ(allocator.allocateSeat(104), -1);
    auto waitingList = allocator.getWaitingList();
    EXPECT_EQ(waitingList.front(), 104);

    // Free a seat; should notify waiting passenger
    int notifiedPassenger = allocator.freeSeat(2);
    EXPECT_EQ(notifiedPassenger, 104);

    // Seat is not auto-assigned; allocate explicitly
    int seatNumber = allocator.allocateSeat(104);
    EXPECT_EQ(seatNumber, 2);
}

TEST_F(SeatAllocatorTest, MultipleWaitingPassengersAllocatedInOrder) {
    SeatAllocator allocator(2);

    // Fill seats
    EXPECT_EQ(allocator.allocateSeat(101), 1);
    EXPECT_EQ(allocator.allocateSeat(102), 2);

    // Add multiple waiting passengers
    EXPECT_EQ(allocator.allocateSeat(103), -1);
    EXPECT_EQ(allocator.allocateSeat(104), -1);

    // Free seats; waiting passengers notified in order
    int firstNotified = allocator.freeSeat(1);
    EXPECT_EQ(firstNotified, 103);
    int secondNotified = allocator.freeSeat(2);
    EXPECT_EQ(secondNotified, 104);

    // Allocate waiting passengers explicitly
    int seat103 = allocator.allocateSeat(103);
    int seat104 = allocator.allocateSeat(104);
    EXPECT_TRUE((seat103 == 1 || seat103 == 2));
    EXPECT_TRUE((seat104 == 1 || seat104 == 2));
    EXPECT_NE(seat103, seat104); // Ensure distinct seats
}

TEST_F(SeatAllocatorTest, FreeSeatWithoutWaitingListAddsToCancelledStack) {
    SeatAllocator allocator(2);

    EXPECT_EQ(allocator.allocateSeat(101), 1);
    EXPECT_EQ(allocator.allocateSeat(102), 2);

    // Free seat when no waiting passengers
    int result = allocator.freeSeat(1);
    EXPECT_EQ(result, 0);

    // Next allocation should reuse the cancelled seat (LIFO)
    EXPECT_EQ(allocator.allocateSeat(103), 1);
}

TEST_F(SeatAllocatorTest, WaitingListPreservesOrderEvenWithMultipleFrees) {
    SeatAllocator allocator(3);

    EXPECT_EQ(allocator.allocateSeat(101), 1);
    EXPECT_EQ(allocator.allocateSeat(102), 2);
    EXPECT_EQ(allocator.allocateSeat(103), 3);

    // Add multiple waiting passengers
    EXPECT_EQ(allocator.allocateSeat(104), -1);
    EXPECT_EQ(allocator.allocateSeat(105), -1);
    EXPECT_EQ(allocator.allocateSeat(106), -1);

    // Free seats one by one; check waiting list order
    EXPECT_EQ(allocator.freeSeat(1), 104);
    EXPECT_EQ(allocator.freeSeat(2), 105);
    EXPECT_EQ(allocator.freeSeat(3), 106);

    // Allocate waiting passengers; should reverse their original freed seats
    EXPECT_EQ(allocator.allocateSeat(104), 3);
    EXPECT_EQ(allocator.allocateSeat(105), 2);
    EXPECT_EQ(allocator.allocateSeat(106), 1);
}

TEST_F(SeatAllocatorTest, CancelledSeatsReusedBeforeNewSeats) {
    SeatAllocator allocator(3);

    EXPECT_EQ(allocator.allocateSeat(101), 1);
    EXPECT_EQ(allocator.allocateSeat(102), 2);

    // Free seat 1
    allocator.freeSeat(1);

    // Allocate new passenger; should get seat 1 first
    EXPECT_EQ(allocator.allocateSeat(103), 1);

    // Add one more seat by expanding total seats
    allocator.addSeats(1); // Total seats now 4
    int newSeat = allocator.allocateSeat(104);
    EXPECT_EQ(newSeat, 3); // Allocates new available seat, not cancelled
}


==================================================
FILE PATH: .\tests\test_startUpManager.cpp
==================================================

#include <gtest/gtest.h>
#include "StartupManager.h"
#include "RMSFacade.h"

class StartupManagerTest : public ::testing::Test {
protected:
    std::unique_ptr<StartupManager> manager;
    RMSFacade* facade;

    void SetUp() override {
        // Initialize the manager
        manager = std::make_unique<StartupManager>();

        // Build the system and get the facade pointer
        facade = manager->buildFacade();
    }

    void TearDown() override {
        // Manager destructor handles the cleanup of Facade, Services, and Repos
        manager.reset();
    }
};

// 1. Basic Construction Test
TEST_F(StartupManagerTest, BuildFacade_ReturnsValidPointer) {
    EXPECT_NE(facade, nullptr);
}

// 2. Verify Wiring: Train Service -> Repo
TEST_F(StartupManagerTest, Facade_HasWorkingTrainService) {
    // Try to use the facade to ensure the underlying TrainService is initialized
    facade->addTrain("Startup Express", 100);

    auto trains = facade->listTrains();
    EXPECT_EQ(trains.size(), 1);
    EXPECT_EQ(trains.front().getTrainName(), "Startup Express");
}

// 3. Verify Wiring: Passenger Service -> Repo
TEST_F(StartupManagerTest, Facade_HasWorkingPassengerService) {
    facade->addPassenger("Test User");

    auto passengers = facade->listPassengers();
    EXPECT_EQ(passengers.size(), 1);
    EXPECT_EQ(passengers.front().getName(), "Test User");
}

// 4. Verify Wiring: Ticket Service -> TrainService + PassengerService
TEST_F(StartupManagerTest, Facade_IntegrationIsWiredCorrectly) {
    // This tests the deepest part of the graph:
    // Facade -> TicketService -> (Repo + TrainService + PassengerService)

    Train t = facade->addTrain("Integration Train", 10);
    Passenger p = facade->addPassenger("Integration Passenger");

    // If pointers were null, this would crash
    Ticket ticket = facade->bookTicket(t.getTrainId(), p.getName());

    EXPECT_GT(ticket.getId(), 0);

    auto allTickets = facade->listTickets();
    EXPECT_EQ(allTickets.size(), 1);
}

// 5. Test Waiting List and Cancellation Flow (NEW TEST)
TEST_F(StartupManagerTest, Facade_HandlesWaitingListAndCancellation) {
    // Create a train with only 1 seat
    Train t = facade->addTrain("Small Train", 1);
    Passenger p1 = facade->addPassenger("First Passenger");
    Passenger p2 = facade->addPassenger("Second Passenger");

    // Book the only seat
    Ticket ticket1 = facade->bookTicket(t.getTrainId(), "First Passenger");
    EXPECT_EQ(ticket1.getStatus(), booked);

    // Try to book second passenger - should work but go to waiting list
    // Note: bookTicket will throw if train is full, so we need to handle waiting list differently
    // Actually, in the current design, bookTicket will throw when train is full
    // Let's test the cancellation and waiting list flow

    // Cancel the first ticket
    facade->cancelTicket(ticket1.getId());

    // Check if ticket was cancelled
    auto tickets = facade->listTickets();
    EXPECT_EQ(tickets.size(), 1);
    EXPECT_EQ(tickets.front().getStatus(), cancelled);
}

// 6. Verify Lifecycle / Reset Behavior
TEST_F(StartupManagerTest, BuildFacade_ResetsApplicationState) {
    // Add data to the current instance
    facade->addTrain("Data to be lost", 10);
    EXPECT_EQ(facade->listTrains().size(), 1);

    // Call buildFacade again on the same manager
    // Based on your implementation, this re-assigns the unique_ptrs,
    // which deletes the old repos and creates new empty ones.
    RMSFacade* newFacade = manager->buildFacade();

    // Verify pointer is still valid
    EXPECT_NE(newFacade, nullptr);

    // Verify data is GONE (Empty state)
    EXPECT_EQ(newFacade->listTrains().size(), 0);
}

// 7. Test Complex Workflow (NEW TEST)
TEST_F(StartupManagerTest, Facade_CompleteBookingWorkflow) {
    // Setup
    Train train = facade->addTrain("Workflow Train", 2);
    Passenger p1 = facade->addPassenger("Alice");
    Passenger p2 = facade->addPassenger("Bob");
    Passenger p3 = facade->addPassenger("Charlie");

    // Book two seats
    Ticket t1 = facade->bookTicket(train.getTrainId(), "Alice");
    Ticket t2 = facade->bookTicket(train.getTrainId(), "Bob");

    EXPECT_EQ(t1.getStatus(), booked);
    EXPECT_EQ(t2.getStatus(), booked);

    // Train should be full now
    EXPECT_FALSE(facade->getTrainAvailability(train.getTrainId()));

    // Cancel Alice's ticket
    facade->cancelTicket(t1.getId());

    // Train should have availability again
    EXPECT_TRUE(facade->getTrainAvailability(train.getTrainId()));

    // Verify tickets
    auto tickets = facade->listTickets();
    // Should have 3 tickets now: Bob's (booked), Alice's (cancelled), and possibly Charlie's if waiting list worked
    EXPECT_GE(tickets.size(), 2);
}

// 8. Test Add Seats Functionality (NEW TEST)
TEST_F(StartupManagerTest, Facade_AddSeatsWorksCorrectly) {
    Train train = facade->addTrain("Expandable Train", 2);

    // Get initial seat count
    auto initialTrains = facade->listTrains();
    int initialSeats = initialTrains.front().getTotalSeats();
    EXPECT_EQ(initialSeats, 2);

    // Add more seats
    facade->addSeats(train.getTrainId(), 3);

    // Verify seats were added
    auto updatedTrains = facade->listTrains();
    int updatedSeats = updatedTrains.front().getTotalSeats();
    EXPECT_EQ(updatedSeats, 5);

    // Train should have availability
    EXPECT_TRUE(facade->getTrainAvailability(train.getTrainId()));
}

// 9. Test Update Passenger (NEW TEST)
TEST_F(StartupManagerTest, Facade_UpdatePassengerWorks) {
    // Add a passenger
    Passenger p = facade->addPassenger("Old Name");
    int passengerId = p.getId();

    // Update the passenger
    Passenger updated = facade->updatePassenger(passengerId, "New Name");

    EXPECT_EQ(updated.getName(), "New Name");

    // Verify in list
    auto passengers = facade->listPassengers();
    bool foundUpdated = false;
    for (const auto& passenger : passengers) {
        if (passenger.getId() == passengerId && passenger.getName() == "New Name") {
            foundUpdated = true;
            break;
        }
    }
    EXPECT_TRUE(foundUpdated);
}

// 10. Test Error Handling (NEW TEST)
TEST_F(StartupManagerTest, Facade_HandlesInvalidOperationsGracefully) {
    // Try to get non-existent train
    auto train = facade->getTrain(999);
    EXPECT_FALSE(train.has_value());

    // Try to delete non-existent train - should throw
    EXPECT_THROW(facade->deleteTrain(999), std::exception);

    // Try to book ticket for non-existent train - should throw
    EXPECT_THROW(facade->bookTicket(999, "Ghost Passenger"), std::exception);
}

==================================================
FILE PATH: .\tests\test_ticket.cpp
==================================================

// ============================================================================
// TicketTest.cpp - Ticket Model Tests
// ============================================================================

#include <gtest/gtest.h>
#include "models/Ticket.h"
#include "models/Passenger.h"

class TicketTest : public ::testing::Test {
protected:
    void SetUp() override {}
    void TearDown() override {}
};

// ============================================================================
// CONSTRUCTION TESTS
// ============================================================================

TEST_F(TicketTest, ValidConstruction) {
    Passenger p(101, "John Doe");
    Ticket ticket(1, 5, 10, p);

    EXPECT_EQ(ticket.getId(), 1);
    EXPECT_EQ(ticket.getSeat(), 5);
    EXPECT_EQ(ticket.getTrainId(), 10);
    EXPECT_EQ(ticket.getStatus(), booked);
    EXPECT_EQ(ticket.getPassenger().getId(), 101);
    EXPECT_EQ(ticket.getPassenger().getName(), "John Doe");
}

TEST_F(TicketTest, ConstructionWithDifferentPassenger) {
    Passenger p(202, "Jane Smith");
    Ticket ticket(2, 10, 5, p);

    EXPECT_EQ(ticket.getId(), 2);
    EXPECT_EQ(ticket.getSeat(), 10);
    EXPECT_EQ(ticket.getTrainId(), 5);
    EXPECT_EQ(ticket.getPassenger().getId(), 202);
}

TEST_F(TicketTest, DefaultStatusIsBooked) {
    Passenger p(101, "John Doe");
    Ticket ticket(1, 5, 10, p);

    EXPECT_EQ(ticket.getStatus(), booked);
}

// ============================================================================
// INVALID CONSTRUCTION TESTS
// ============================================================================

TEST_F(TicketTest, InvalidTicketIdNegative) {
    Passenger p(101, "John Doe");
    EXPECT_THROW(Ticket(-1, 5, 10, p), std::runtime_error);
}

TEST_F(TicketTest, InvalidTicketIdZero) {
    Passenger p(101, "John Doe");
    Ticket t (100, 5, 10, p);
    EXPECT_THROW(t.setId(0), std::invalid_argument);
}

TEST_F(TicketTest, InvalidTrainIdNegative) {
    Passenger p(101, "John Doe");
    EXPECT_THROW(Ticket(1, 5, -1, p), std::runtime_error);
}

TEST_F(TicketTest, InvalidTrainIdZero) {
    Passenger p(101, "John Doe");
    EXPECT_THROW(Ticket(1, 5, 0, p), std::runtime_error);
}

TEST_F(TicketTest, InvalidSeatZero) {
    Passenger p(101, "John Doe");
    EXPECT_THROW(Ticket(1, 0, 10, p), std::runtime_error);
}

TEST_F(TicketTest, InvalidSeatNegative) {
    Passenger p(101, "John Doe");
    EXPECT_THROW(Ticket(1, -5, 10, p), std::runtime_error);
}

TEST_F(TicketTest, AllInvalidParameters) {
    Passenger p(101, "John Doe");
    EXPECT_THROW(Ticket(-1, -5, -10, p), std::runtime_error);
}

// ============================================================================
// GETTER TESTS
// ============================================================================

TEST_F(TicketTest, GetIdReturnsCorrectValue) {
    Passenger p(101, "John Doe");
    Ticket ticket(15, 5, 10, p);
    EXPECT_EQ(ticket.getId(), 15);
}

TEST_F(TicketTest, GetSeatReturnsCorrectValue) {
    Passenger p(101, "John Doe");
    Ticket ticket(1, 25, 10, p);
    EXPECT_EQ(ticket.getSeat(), 25);
}

TEST_F(TicketTest, GetTrainIdReturnsCorrectValue) {
    Passenger p(101, "John Doe");
    Ticket ticket(1, 5, 99, p);
    EXPECT_EQ(ticket.getTrainId(), 99);
}

TEST_F(TicketTest, GetPassengerReturnsCorrectPassenger) {
    Passenger p(303, "Alice Brown");
    Ticket ticket(1, 5, 10, p);

    Passenger retrieved = ticket.getPassenger();
    EXPECT_EQ(retrieved.getId(), 303);
    EXPECT_EQ(retrieved.getName(), "Alice Brown");
}

TEST_F(TicketTest, GetStatusReturnsCorrectStatus) {
    Passenger p(101, "John Doe");
    Ticket ticket(1, 5, 10, p);
    EXPECT_EQ(ticket.getStatus(), booked);
}

// ============================================================================
// SETTER TESTS
// ============================================================================

TEST_F(TicketTest, SetStatusToBooked) {
    Passenger p(101, "John Doe");
    Ticket ticket(1, 5, 10, p);

    ticket.setStatus(booked);
    EXPECT_EQ(ticket.getStatus(), booked);
}

TEST_F(TicketTest, SetStatusToCancelled) {
    Passenger p(101, "John Doe");
    Ticket ticket(1, 5, 10, p);

    ticket.setStatus(cancelled);
    EXPECT_EQ(ticket.getStatus(), cancelled);
}

TEST_F(TicketTest, ToggleStatusMultipleTimes) {
    Passenger p(101, "John Doe");
    Ticket ticket(1, 5, 10, p);

    ticket.setStatus(cancelled);
    EXPECT_EQ(ticket.getStatus(), cancelled);

    ticket.setStatus(booked);
    EXPECT_EQ(ticket.getStatus(), booked);

    ticket.setStatus(cancelled);
    EXPECT_EQ(ticket.getStatus(), cancelled);
}

TEST_F(TicketTest, SetIdChangesTicketId) {
    Passenger p(101, "John Doe");
    Ticket ticket(1, 5, 10, p);

    ticket.setId(100);
    EXPECT_EQ(ticket.getId(), 100);
}

TEST_F(TicketTest, SetIdDoesNotAffectOtherFields) {
    Passenger p(101, "John Doe");
    Ticket ticket(1, 5, 10, p);

    ticket.setId(200);

    EXPECT_EQ(ticket.getId(), 200);
    EXPECT_EQ(ticket.getSeat(), 5);
    EXPECT_EQ(ticket.getTrainId(), 10);
    EXPECT_EQ(ticket.getPassenger().getId(), 101);
}

// ============================================================================
// STATUS WORKFLOW TESTS
// ============================================================================

TEST_F(TicketTest, BookedToCancelledWorkflow) {
    Passenger p(101, "John Doe");
    Ticket ticket(1, 5, 10, p);

    EXPECT_EQ(ticket.getStatus(), booked);

    ticket.setStatus(cancelled);
    EXPECT_EQ(ticket.getStatus(), cancelled);
}

TEST_F(TicketTest, CancelledTicketRetainsAllInformation) {
    Passenger p(101, "John Doe");
    Ticket ticket(1, 5, 10, p);

    ticket.setStatus(cancelled);

    EXPECT_EQ(ticket.getId(), 1);
    EXPECT_EQ(ticket.getSeat(), 5);
    EXPECT_EQ(ticket.getTrainId(), 10);
    EXPECT_EQ(ticket.getPassenger().getId(), 101);
}

// ============================================================================
// PASSENGER RELATIONSHIP TESTS
// ============================================================================

TEST_F(TicketTest, PassengerDataIndependent) {
    Passenger p(101, "John Doe");
    Ticket ticket(1, 5, 10, p);

    // Modifying original passenger shouldn't affect ticket
    p.setName("Modified Name");

    EXPECT_EQ(ticket.getPassenger().getName(), "John Doe");
}

TEST_F(TicketTest, MultipleTicketsSamePassenger) {
    Passenger p(101, "John Doe");
    Ticket ticket1(1, 5, 10, p);
    Ticket ticket2(2, 6, 10, p);

    EXPECT_EQ(ticket1.getPassenger().getId(), 101);
    EXPECT_EQ(ticket2.getPassenger().getId(), 101);
    EXPECT_NE(ticket1.getId(), ticket2.getId());
    EXPECT_NE(ticket1.getSeat(), ticket2.getSeat());
}

TEST_F(TicketTest, TicketWithLongPassengerName) {
    Passenger p(101, "Christopher Alexander Montgomery III");
    Ticket ticket(1, 5, 10, p);

    EXPECT_EQ(ticket.getPassenger().getName(), "Christopher Alexander Montgomery III");
}

// ============================================================================
// EDGE CASE TESTS
// ============================================================================

TEST_F(TicketTest, LargeTicketId) {
    Passenger p(101, "John Doe");
    Ticket ticket(999999, 5, 10, p);
    EXPECT_EQ(ticket.getId(), 999999);
}

TEST_F(TicketTest, LargeSeatNumber) {
    Passenger p(101, "John Doe");
    Ticket ticket(1, 10000, 10, p);
    EXPECT_EQ(ticket.getSeat(), 10000);
}

TEST_F(TicketTest, LargeTrainId) {
    Passenger p(101, "John Doe");
    Ticket ticket(1, 5, 999999, p);
    EXPECT_EQ(ticket.getTrainId(), 999999);
}

TEST_F(TicketTest, AllMaximumValues) {
    Passenger p(999999, "John Doe");
    Ticket ticket(999999, 999999, 999999, p);

    EXPECT_EQ(ticket.getId(), 999999);
    EXPECT_EQ(ticket.getSeat(), 999999);
    EXPECT_EQ(ticket.getTrainId(), 999999);
    EXPECT_EQ(ticket.getPassenger().getId(), 999999);
}

TEST_F(TicketTest, MinimumValidValues) {
    Passenger p(1, "A");
    Ticket ticket(1, 1, 1, p);

    EXPECT_EQ(ticket.getId(), 1);
    EXPECT_EQ(ticket.getSeat(), 1);
    EXPECT_EQ(ticket.getTrainId(), 1);
    EXPECT_EQ(ticket.getPassenger().getId(), 1);
}

// ============================================================================
// MULTIPLE TICKETS TESTS
// ============================================================================

TEST_F(TicketTest, MultipleTicketsIndependent) {
    Passenger p1(101, "John Doe");
    Passenger p2(102, "Jane Smith");

    Ticket ticket1(1, 5, 10, p1);
    Ticket ticket2(2, 6, 10, p2);

    ticket1.setStatus(cancelled);

    EXPECT_EQ(ticket1.getStatus(), cancelled);
    EXPECT_EQ(ticket2.getStatus(), booked);
}

TEST_F(TicketTest, TicketArrayScenario) {
    Passenger p1(101, "John");
    Passenger p2(102, "Jane");
    Passenger p3(103, "Bob");

    Ticket tickets[3] = {
            Ticket(1, 1, 10, p1),
            Ticket(2, 2, 10, p2),
            Ticket(3, 3, 10, p3)
    };

    for (int i = 0; i < 3; i++) {
        EXPECT_EQ(tickets[i].getId(), i + 1);
        EXPECT_EQ(tickets[i].getSeat(), i + 1);
    }
}



==================================================
FILE PATH: .\tests\test_ticketService.cpp
==================================================

#include <gtest/gtest.h>
#include "Services/TicketService.h"
#include "Services/TrainService.h"
#include "Services/PassengerService.h"
#include "Repo/InMemoryTicketRepository.h"
#include "Repo/InMemoryTrainRepository.h"
#include "Repo/InMemoryPassengerRepository.h"

class TicketServiceTest : public ::testing::Test {
protected:
    InMemoryTicketRepository* ticketRepo{};
    InMemoryTrainRepository* trainRepo{};
    InMemoryPassengerRepository* passengerRepo{};

    TrainService* trainService{};
    PassengerService* passengerService{};
    TicketService* ticketService{};

    void SetUp() override {
        ticketRepo = new InMemoryTicketRepository();
        trainRepo = new InMemoryTrainRepository();
        passengerRepo = new InMemoryPassengerRepository();

        trainService = new TrainService(trainRepo);
        passengerService = new PassengerService(passengerRepo);
        ticketService = new TicketService(ticketRepo, trainService, passengerService);
    }

    void TearDown() override {
        delete ticketService;
        delete passengerService;
        delete trainService;
        delete ticketRepo;
        delete trainRepo;
        delete passengerRepo;
    }
};

/* ============================================================
   BASIC BOOKING TESTS
   ============================================================ */

TEST_F(TicketServiceTest, BookTicket_HappyPath) {
    Train t = trainService->createTrain("Express", 10);
    Passenger p = passengerService->createPassenger("Omar");

    Ticket ticket = ticketService->bookTicket(t.getTrainId(), p.getId());

    EXPECT_GT(ticket.getId(), 0);
    EXPECT_EQ(ticket.getTrainId(), t.getTrainId());
    EXPECT_EQ(ticket.getPassenger().getId(), p.getId());
    EXPECT_EQ(ticket.getStatus(), booked);

    auto saved = ticketService->getTicket(ticket.getId());
    ASSERT_TRUE(saved.has_value());
    EXPECT_EQ(saved->getId(), ticket.getId());
}

TEST_F(TicketServiceTest, BookTicket_ThrowsIfTrainNotFound) {
    Passenger p = passengerService->createPassenger("Omar");
    EXPECT_THROW(ticketService->bookTicket(999, p.getId()), std::runtime_error);
}

TEST_F(TicketServiceTest, BookTicket_ThrowsIfPassengerNotFound) {
    Train t = trainService->createTrain("Express", 10);
    EXPECT_THROW(ticketService->bookTicket(t.getTrainId(), 999), std::runtime_error);
}

TEST_F(TicketServiceTest, BookTicket_ThrowsIfAlreadyBooked) {
    Train t = trainService->createTrain("Express", 10);
    Passenger p = passengerService->createPassenger("Omar");

    ticketService->bookTicket(t.getTrainId(), p.getId());
    EXPECT_THROW(ticketService->bookTicket(t.getTrainId(), p.getId()), std::runtime_error);
}

TEST_F(TicketServiceTest, BookTicket_AssignsSeatsCorrectly) {
    Train t = trainService->createTrain("Express", 2);
    Passenger p1 = passengerService->createPassenger("P1");
    Passenger p2 = passengerService->createPassenger("P2");

    Ticket t1 = ticketService->bookTicket(t.getTrainId(), p1.getId());
    Ticket t2 = ticketService->bookTicket(t.getTrainId(), p2.getId());

    EXPECT_NE(t1.getSeat(), t2.getSeat());
    EXPECT_GT(t1.getSeat(), 0);
    EXPECT_GT(t2.getSeat(), 0);
}

TEST_F(TicketServiceTest, BookTicket_ThrowsWhenTrainIsFull) {
    Train t = trainService->createTrain("TinyTrain", 1);
    Passenger p1 = passengerService->createPassenger("A");
    Passenger p2 = passengerService->createPassenger("B");

    ticketService->bookTicket(t.getTrainId(), p1.getId());
    EXPECT_THROW(ticketService->bookTicket(t.getTrainId(), p2.getId()), std::runtime_error);
}

TEST_F(TicketServiceTest, BookTicket_SamePassengerDifferentTrains) {
    Train t1 = trainService->createTrain("Train A", 5);
    Train t2 = trainService->createTrain("Train B", 5);
    Passenger p = passengerService->createPassenger("Traveler");

    EXPECT_NO_THROW(ticketService->bookTicket(t1.getTrainId(), p.getId()));
    EXPECT_NO_THROW(ticketService->bookTicket(t2.getTrainId(), p.getId()));

    EXPECT_EQ(ticketService->getAllTickets().size(), 2);
}

/* ============================================================
   CANCELLATION TESTS
   ============================================================ */

TEST_F(TicketServiceTest, CancelTicket_Success) {
    Train t = trainService->createTrain("Express", 10);
    Passenger p = passengerService->createPassenger("Omar");
    Ticket ticket = ticketService->bookTicket(t.getTrainId(), p.getId());

    ticketService->cancelTicket(ticket.getId());

    auto updated = ticketService->getTicket(ticket.getId());
    ASSERT_TRUE(updated.has_value());
    EXPECT_EQ(updated->getStatus(), cancelled);
}

TEST_F(TicketServiceTest, CancelTicket_ThrowsIfNotFound) {
    EXPECT_THROW(ticketService->cancelTicket(9999), std::runtime_error);
}

TEST_F(TicketServiceTest, CancelTicket_ThrowsIfAlreadyCancelled) {
    Train t = trainService->createTrain("Express", 10);
    Passenger p = passengerService->createPassenger("Omar");

    Ticket ticket = ticketService->bookTicket(t.getTrainId(), p.getId());
    ticketService->cancelTicket(ticket.getId());

    EXPECT_THROW(ticketService->cancelTicket(ticket.getId()), std::runtime_error);
}

/* ============================================================
   LOOKUP TESTS
   ============================================================ */

TEST_F(TicketServiceTest, GetTicketByTrainAndPassenger_Found) {
    Train t = trainService->createTrain("Search", 10);
    Passenger p = passengerService->createPassenger("Finder");

    Ticket created = ticketService->bookTicket(t.getTrainId(), p.getId());

    auto found = ticketService->getTicketByTrainAndPassenger(t.getTrainId(), p.getId());
    ASSERT_TRUE(found.has_value());
    EXPECT_EQ(found->getId(), created.getId());
}

TEST_F(TicketServiceTest, GetTicketByTrainAndPassenger_NotFound) {
    Train t = trainService->createTrain("Empty", 10);
    Passenger p = passengerService->createPassenger("Ghost");

    EXPECT_FALSE(ticketService->getTicketByTrainAndPassenger(t.getTrainId(), p.getId()).has_value());
}

TEST_F(TicketServiceTest, GetAllTickets_ReturnsAll) {
    Train t = trainService->createTrain("Express", 5);
    Passenger p1 = passengerService->createPassenger("P1");
    Passenger p2 = passengerService->createPassenger("P2");

    ticketService->bookTicket(t.getTrainId(), p1.getId());
    ticketService->bookTicket(t.getTrainId(), p2.getId());

    EXPECT_EQ(ticketService->getAllTickets().size(), 2);
}

/* ============================================================
   UPDATE TESTS
   ============================================================ */

TEST_F(TicketServiceTest, UpdateTicket_Success) {
    Train t = trainService->createTrain("Express", 10);
    Passenger p = passengerService->createPassenger("Test");

    Ticket ticket = ticketService->bookTicket(t.getTrainId(), p.getId());
    ticket.setStatus(cancelled);

    Ticket updated = ticketService->updateTicket(ticket);

    EXPECT_EQ(updated.getStatus(), cancelled);

    auto retrieved = ticketService->getTicket(ticket.getId());
    ASSERT_TRUE(retrieved.has_value());
    EXPECT_EQ(retrieved->getStatus(), cancelled);
}

/* ============================================================
   WAITING LIST / DEALLOCATION TESTS
   ============================================================ */

TEST_F(TicketServiceTest, BookTicket_NoWaitingList_Behavior) {
    Train t = trainService->createTrain("Small", 2);
    Passenger p1 = passengerService->createPassenger("P1");
    Passenger p2 = passengerService->createPassenger("P2");
    Passenger p3 = passengerService->createPassenger("P3");

    ticketService->bookTicket(t.getTrainId(), p1.getId());
    ticketService->bookTicket(t.getTrainId(), p2.getId());

    EXPECT_THROW(ticketService->bookTicket(t.getTrainId(), p3.getId()), std::runtime_error);
}

TEST_F(TicketServiceTest, CancelAndReBook_ReusesSeat) {
    Train t = trainService->createTrain("Test", 3);
    Passenger p1 = passengerService->createPassenger("P1");
    Passenger p2 = passengerService->createPassenger("P2");

    // Book first passenger
    Ticket t1 = ticketService->bookTicket(t.getTrainId(), p1.getId());
    int freedSeat = t1.getSeat();

    // Cancel ticket  seat becomes free
    ticketService->cancelTicket(t1.getId());

    // Book second passenger  must get the same seat
    Ticket t2 = ticketService->bookTicket(t.getTrainId(), p2.getId());

    EXPECT_EQ(t2.getSeat(), freedSeat)
                        << "SeatAllocator must reuse the freed seat.";
}
TEST_F(TicketServiceTest, CancelTicket_FreesSeat) {
    Train t = trainService->createTrain("Express", 1);
    Passenger p1 = passengerService->createPassenger("P1");
    Passenger p2 = passengerService->createPassenger("P2");

    // Book and capture seat number
    Ticket t1 = ticketService->bookTicket(t.getTrainId(), p1.getId());
    int freedSeat = t1.getSeat();

    // Cancel  seat must become free
    ticketService->cancelTicket(t1.getId());

    // Booking P2 must succeed (train has 1 seat)
    ASSERT_NO_THROW({
                        ticketService->bookTicket(t.getTrainId(), p2.getId());
                    });

    // Verify P2 actually got the seat that was freed
    auto ticketForP2 = ticketService->getTicketByTrainAndPassenger(t.getTrainId(), p2.getId());
    ASSERT_TRUE(ticketForP2.has_value());
    EXPECT_EQ(ticketForP2->getSeat(), freedSeat)
                        << "After cancellation the same seat must be reallocated.";
}


TEST_F(TicketServiceTest, CancelTicket_ReallocatesToWaitingList) {
    Train t = trainService->createTrain("Test", 1);
    Passenger p1 = passengerService->createPassenger("P1");
    Passenger p2 = passengerService->createPassenger("P2");
    Passenger p3 = passengerService->createPassenger("P3");

    Ticket t1 = ticketService->bookTicket(t.getTrainId(), p1.getId());
    int seat1 = t1.getSeat();

    EXPECT_THROW(ticketService->bookTicket(t.getTrainId(), p2.getId()), std::runtime_error);

    ticketService->cancelTicket(t1.getId());

    auto ticketP2 = ticketService->getTicketByTrainAndPassenger(t.getTrainId(), p2.getId());
    EXPECT_TRUE(ticketP2.has_value());
    EXPECT_EQ(ticketP2->getSeat(), seat1);

    auto trainNow = trainService->getTrain(t.getTrainId());
    ASSERT_TRUE(trainNow.has_value());
    EXPECT_FALSE(trainNow->hasAvailableSeats());

    EXPECT_THROW(ticketService->bookTicket(t.getTrainId(), p3.getId()), std::runtime_error);
}

TEST_F(TicketServiceTest, MultipleWaitingPassengers_ReallocationOrder) {
    Train t = trainService->createTrain("Small", 2);
    Passenger p1 = passengerService->createPassenger("P1");
    Passenger p2 = passengerService->createPassenger("P2");
    Passenger p3 = passengerService->createPassenger("P3");
    Passenger p4 = passengerService->createPassenger("P4");

    Ticket t1 = ticketService->bookTicket(t.getTrainId(), p1.getId());
    Ticket t2 = ticketService->bookTicket(t.getTrainId(), p2.getId());

    EXPECT_THROW(ticketService->bookTicket(t.getTrainId(), p3.getId()), std::runtime_error);
    EXPECT_THROW(ticketService->bookTicket(t.getTrainId(), p4.getId()), std::runtime_error);

    ticketService->cancelTicket(t1.getId());
    EXPECT_TRUE(ticketService->getTicketByTrainAndPassenger(t.getTrainId(), p3.getId()).has_value());

    ticketService->cancelTicket(t2.getId());
    EXPECT_TRUE(ticketService->getTicketByTrainAndPassenger(t.getTrainId(), p4.getId()).has_value());
}

TEST_F(TicketServiceTest, CancelledSeats_AreReusedLIFO) {
    Train t = trainService->createTrain("LIFO Test", 3);
    Passenger p1 = passengerService->createPassenger("P1");
    Passenger p2 = passengerService->createPassenger("P2");
    Passenger p3 = passengerService->createPassenger("P3");
    Passenger p4 = passengerService->createPassenger("P4");

    Ticket t1 = ticketService->bookTicket(t.getTrainId(), p1.getId()); // seat1
    Ticket t2 = ticketService->bookTicket(t.getTrainId(), p2.getId()); // seat2
    Ticket t3 = ticketService->bookTicket(t.getTrainId(), p3.getId()); // seat3

    ticketService->cancelTicket(t2.getId()); // frees seat2
    ticketService->cancelTicket(t1.getId()); // frees seat1 last  LIFO

    Ticket t4 = ticketService->bookTicket(t.getTrainId(), p4.getId());
    EXPECT_EQ(t4.getSeat(), 1); // LIFO
}

TEST_F(TicketServiceTest, CancelTicket_GracefulWhenWaitingBookingFails) {
    Train t = trainService->createTrain("Error Test", 1);
    Passenger p1 = passengerService->createPassenger("P1");
    Passenger p2 = passengerService->createPassenger("P2");

    Ticket t1 = ticketService->bookTicket(t.getTrainId(), p1.getId());
    EXPECT_THROW(ticketService->bookTicket(t.getTrainId(), p2.getId()), std::runtime_error);

    EXPECT_NO_THROW(ticketService->cancelTicket(t1.getId()));

    EXPECT_EQ(ticketService->getAllTickets().size(), 2);
}


==================================================
FILE PATH: .\tests\test_ticktRepo.cpp
==================================================

//
// Created by Omar on 11/24/2025.
//
#include <gtest/gtest.h>
#include "Repo/InMemoryTicketRepository.h"
#include "models/Ticket.h"
#include "models/Passenger.h"

class TicketRepositoryTest : public ::testing::Test {
protected:
    InMemoryTicketRepository repo;
    Passenger testPassenger;

    TicketRepositoryTest() : testPassenger(1, "John Doe") {}

    void SetUp() override {
        repo.clear();
    }

    void TearDown() override {
        repo.clear();
    }
};

TEST_F(TicketRepositoryTest, SaveTicket_GeneratesId) {
    Ticket t(0, 1, 101, testPassenger);
    repo.save(t);

    EXPECT_GT(t.getId(), 0);
    EXPECT_EQ(t.getSeat(), 1);
}

TEST_F(TicketRepositoryTest, GetTicketById_Success) {
    Ticket t(0, 5, 200, testPassenger);
    repo.save(t);

    auto retrieved = repo.getTicketById(t.getId());

    // Based on your repo code, getTicketById returns optional or throws
    // Your implementation throws runtime_error if not found, but returns optional if found
    ASSERT_TRUE(retrieved.has_value());
    EXPECT_EQ(retrieved->getId(), t.getId());
    EXPECT_EQ(retrieved->getPassenger().getName(), "John Doe");
}

TEST_F(TicketRepositoryTest, GetTicketById_ThrowsWhenNotFound) {
    // Your implementation explicitly throws runtime_error for ID lookup failures
    EXPECT_THROW(repo.getTicketById(999), std::runtime_error);
}

TEST_F(TicketRepositoryTest, GetTicketByTrainAndPassenger_Success) {
    int trainId = 100;
    Passenger p(50, "Jane");
    Ticket t(0, 10, trainId, p);
    repo.save(t);

    auto result = repo.getTicketByTrainAndPassenger(trainId, p.getId());

    ASSERT_TRUE(result.has_value());
    EXPECT_EQ(result->getId(), t.getId());
}

TEST_F(TicketRepositoryTest, GetTicketByTrainAndPassenger_ReturnsNulloptWhenNotFound) {
    // Your implementation returns std::nullopt here (doesn't throw)
    auto result = repo.getTicketByTrainAndPassenger(100, 999);
    EXPECT_FALSE(result.has_value());
}

TEST_F(TicketRepositoryTest, DeleteTicket_Success) {
    Ticket t(0, 1, 100, testPassenger);
    repo.save(t);
    int id = t.getId();

    bool deleted = repo.deleteTicket(id);
    EXPECT_TRUE(deleted);

    EXPECT_THROW(repo.getTicketById(id), std::runtime_error);
}

TEST_F(TicketRepositoryTest, GetAllTickets) {
    Ticket t1(0, 1, 100, testPassenger);
    Ticket t2(0, 2, 100, testPassenger);
    repo.save(t1);
    repo.save(t2);

    auto all = repo.getAllTickets();
    EXPECT_EQ(all.size(), 2);
}

==================================================
FILE PATH: .\tests\test_train.cpp
==================================================

// ============================================================================
// TrainTest.cpp - Train Model Tests
// ============================================================================

#include <gtest/gtest.h>
#include "models/Train.h"
#include "models/SeatAllocator.h"

class TrainTest : public ::testing::Test {
protected:
    void SetUp() override {}
    void TearDown() override {}
};

// ============================================================================
// CONSTRUCTION TESTS
// ============================================================================

TEST_F(TrainTest, ValidConstruction) {
    Train train(1, "Express Train", 20);
    EXPECT_EQ(train.getTrainId(), 1);
    EXPECT_EQ(train.getTrainName(), "Express Train");
    EXPECT_EQ(train.getTotalSeats(), 20);
    EXPECT_TRUE(train.hasAvailableSeats());
}

TEST_F(TrainTest, DefaultSeatCount) {
    Train train(1, "Local Train");
    EXPECT_EQ(train.getTotalSeats(), 10);
}

TEST_F(TrainTest, ConstructionWithMinimumSeats) {
    Train train(1, "Mini Train", 1);
    EXPECT_EQ(train.getTotalSeats(), 1);
}

TEST_F(TrainTest, ConstructionWithLargeCapacity) {
    Train train(1, "Mega Train", 1000);
    EXPECT_EQ(train.getTotalSeats(), 1000);
}

TEST_F(TrainTest, SeatAllocatorCreatedAutomatically) {
    Train train(1, "Express Train", 20);
    SeatAllocator* allocator = train.getSeatAllocator();
    EXPECT_NE(allocator, nullptr);
    EXPECT_EQ(allocator->getTotalSeats(), 20);
}

// ============================================================================
// INVALID CONSTRUCTION TESTS
// ============================================================================

TEST_F(TrainTest, InvalidTrainIdNegative) {
    EXPECT_THROW(Train(-1, "Express Train", 20), std::runtime_error);
}

TEST_F(TrainTest, InvalidTrainIdZero) {
    Train t(100, "Express Train", 20);
    EXPECT_THROW(t.setTrainId(0), std::runtime_error);
}

TEST_F(TrainTest, EmptyNameThrows) {
    EXPECT_THROW(Train(1, "", 20), std::runtime_error);
}

TEST_F(TrainTest, NegativeSeatsThrows) {
    EXPECT_THROW(Train(1, "Express Train", -5), std::runtime_error);
}

TEST_F(TrainTest, AllInvalidParametersThrows) {
    EXPECT_THROW(Train(-1, "", -5), std::runtime_error);
}

// ============================================================================
// GETTER TESTS
// ============================================================================

TEST_F(TrainTest, GetTrainIdReturnsCorrectValue) {
    Train train(42, "Express Train", 20);
    EXPECT_EQ(train.getTrainId(), 42);
}

TEST_F(TrainTest, GetTrainNameReturnsCorrectValue) {
    Train train(1, "Super Express", 20);
    EXPECT_EQ(train.getTrainName(), "Super Express");
}

TEST_F(TrainTest, GetTotalSeatsReturnsCorrectValue) {
    Train train(1, "Express Train", 50);
    EXPECT_EQ(train.getTotalSeats(), 50);
}

TEST_F(TrainTest, GetSeatAllocatorReturnsValidPointer) {
    Train train(1, "Express Train", 20);
    SeatAllocator* allocator = train.getSeatAllocator();
    EXPECT_NE(allocator, nullptr);
}

// ============================================================================
// SETTER TESTS
// ============================================================================

TEST_F(TrainTest, SetValidTrainName) {
    Train train(1, "Express Train", 20);
    train.setTrainName("Super Express");
    EXPECT_EQ(train.getTrainName(), "Super Express");
}

TEST_F(TrainTest, SetEmptyNameThrows) {
    Train train(1, "Express Train", 20);
    EXPECT_THROW(train.setTrainName(""), std::runtime_error);
}

TEST_F(TrainTest, SetTrainNameMultipleTimes) {
    Train train(1, "Express Train", 20);
    train.setTrainName("Fast Train");
    train.setTrainName("Ultra Fast Train");
    EXPECT_EQ(train.getTrainName(), "Ultra Fast Train");
}

TEST_F(TrainTest, SetTrainNameWithSpecialCharacters) {
    Train train(1, "Express Train", 20);
    train.setTrainName("Train-X #1 (Express)");
    EXPECT_EQ(train.getTrainName(), "Train-X #1 (Express)");
}

// ============================================================================
// ADD SEATS TESTS
// ============================================================================

TEST_F(TrainTest, AddSeatsIncreasesTotalSeats) {
    Train train(1, "Express Train", 20);
    train.addSeats(10);
    EXPECT_EQ(train.getTotalSeats(), 30);
}

TEST_F(TrainTest, AddSeatsMultipleTimes) {
    Train train(1, "Express Train", 20);
    train.addSeats(5);
    train.addSeats(5);
    train.addSeats(10);
    EXPECT_EQ(train.getTotalSeats(), 40);
}

TEST_F(TrainTest, AddSeatsUpdatesAllocator) {
    Train train(1, "Express Train", 20);
    train.addSeats(10);

    SeatAllocator* allocator = train.getSeatAllocator();
    EXPECT_EQ(allocator->getTotalSeats(), 30);
}

TEST_F(TrainTest, AddInvalidSeatsZeroThrows) {
    Train train(1, "Express Train", 20);
    EXPECT_THROW(train.addSeats(0), std::runtime_error);
}

TEST_F(TrainTest, AddInvalidSeatsNegativeThrows) {
    Train train(1, "Express Train", 20);
    EXPECT_THROW(train.addSeats(-5), std::runtime_error);
}

TEST_F(TrainTest, AddSeatsAfterAllocations) {
    Train train(1, "Express Train", 5);
    train.getSeatAllocator()->allocateSeat(101);
    train.getSeatAllocator()->allocateSeat(102);

    train.addSeats(5);
    EXPECT_EQ(train.getTotalSeats(), 10);
    EXPECT_TRUE(train.hasAvailableSeats());
}

// ============================================================================
// SET SEATS TESTS
// ============================================================================

TEST_F(TrainTest, SetSeatsIncreasesCapacity) {
    Train train(1, "Express Train", 20);
    train.setSeats(30);
    EXPECT_EQ(train.getTotalSeats(), 30);
}

TEST_F(TrainTest, SetSeatsDecreasesCapacity) {
    Train train(1, "Express Train", 20);
    train.setSeats(15);
    EXPECT_EQ(train.getTotalSeats(), 15);
}

TEST_F(TrainTest, SetSeatsToSameValue) {
    Train train(1, "Express Train", 20);
    train.setSeats(20);
    EXPECT_EQ(train.getTotalSeats(), 20);
}

TEST_F(TrainTest, SetInvalidSeatsZeroThrows) {
    Train train(1, "Express Train", 20);
    EXPECT_THROW(train.setSeats(0), std::runtime_error);
}

TEST_F(TrainTest, SetInvalidSeatsNegativeThrows) {
    Train train(1, "Express Train", 20);
    EXPECT_THROW(train.setSeats(-10), std::runtime_error);
}

TEST_F(TrainTest, SetSeatsUpdatesAllocator) {
    Train train(1, "Express Train", 20);
    train.setSeats(25);

    SeatAllocator* allocator = train.getSeatAllocator();
    EXPECT_EQ(allocator->getTotalSeats(), 25);
}

TEST_F(TrainTest, SetSeatsBelowAllocatedThrows) {
    Train train(1, "Express Train", 10);
    train.getSeatAllocator()->allocateSeat(101);
    train.getSeatAllocator()->allocateSeat(102);
    train.getSeatAllocator()->allocateSeat(103);

    EXPECT_THROW(train.setSeats(2), std::runtime_error);
}

// ============================================================================
// AVAILABLE SEATS TESTS
// ============================================================================

TEST_F(TrainTest, HasAvailableSeatsInitially) {
    Train train(1, "Express Train", 20);
    EXPECT_TRUE(train.hasAvailableSeats());
}

TEST_F(TrainTest, HasAvailableSeatsAfterPartialAllocation) {
    Train train(1, "Express Train", 5);
    train.getSeatAllocator()->allocateSeat(101);
    train.getSeatAllocator()->allocateSeat(102);
    EXPECT_TRUE(train.hasAvailableSeats());
}

TEST_F(TrainTest, NoAvailableSeatsWhenFull) {
    Train train(1, "Express Train", 2);
    train.getSeatAllocator()->allocateSeat(101);
    train.getSeatAllocator()->allocateSeat(102);
    EXPECT_FALSE(train.hasAvailableSeats());
}

TEST_F(TrainTest, HasAvailableSeatsAfterFreeing) {
    Train train(1, "Express Train", 2);
    train.getSeatAllocator()->allocateSeat(101);
    train.getSeatAllocator()->allocateSeat(102);
    train.getSeatAllocator()->freeSeat(1);
    EXPECT_TRUE(train.hasAvailableSeats());
}

// ============================================================================
// COPY CONSTRUCTOR TESTS
// ============================================================================

TEST_F(TrainTest, CopyConstructorCopiesAllFields) {
    Train train(1, "Express Train", 20);
    train.getSeatAllocator()->allocateSeat(101);
    train.getSeatAllocator()->allocateSeat(102);

    Train copy(train);
    EXPECT_EQ(copy.getTrainId(), train.getTrainId());
    EXPECT_EQ(copy.getTrainName(), train.getTrainName());
    EXPECT_EQ(copy.getTotalSeats(), train.getTotalSeats());
}

TEST_F(TrainTest, CopyConstructorCreatesIndependentCopy) {
    Train train(1, "Express Train", 20);
    train.getSeatAllocator()->allocateSeat(101);

    Train copy(train);
    copy.getSeatAllocator()->allocateSeat(102);

    EXPECT_NE(train.getSeatAllocator(), copy.getSeatAllocator());
}

TEST_F(TrainTest, CopyConstructorCopiesSeatAllocator) {
    Train train(1, "Express Train", 5);
    train.getSeatAllocator()->allocateSeat(101);
    train.getSeatAllocator()->allocateSeat(102);

    Train copy(train);
    SeatAllocator* origAllocator = train.getSeatAllocator();
    SeatAllocator* copyAllocator = copy.getSeatAllocator();

    EXPECT_EQ(origAllocator->getAllocatedSeatCount(),
              copyAllocator->getAllocatedSeatCount());
}

// ============================================================================
// ASSIGNMENT OPERATOR TESTS
// ============================================================================

TEST_F(TrainTest, AssignmentOperatorCopiesAllFields) {
    Train train(1, "Express Train", 20);
    train.getSeatAllocator()->allocateSeat(101);

    Train other(2, "Local Train", 10);
    other = train;

    EXPECT_EQ(other.getTrainId(), 1);
    EXPECT_EQ(other.getTrainName(), "Express Train");
    EXPECT_EQ(other.getTotalSeats(), 20);
}

TEST_F(TrainTest, SelfAssignmentHandled) {
    Train train(1, "Express Train", 20);
    train.getSeatAllocator()->allocateSeat(101);

    train = train;

    EXPECT_EQ(train.getTrainId(), 1);
    EXPECT_EQ(train.getTrainName(), "Express Train");
    EXPECT_EQ(train.getTotalSeats(), 20);
}

TEST_F(TrainTest, AssignmentOperatorCreatesIndependentCopy) {
    Train train(1, "Express Train", 20);
    train.getSeatAllocator()->allocateSeat(101);

    Train other(2, "Local Train", 10);
    other = train;

    other.getSeatAllocator()->allocateSeat(102);

    EXPECT_EQ(train.getSeatAllocator()->getAllocatedSeatCount(), 1);
    EXPECT_EQ(other.getSeatAllocator()->getAllocatedSeatCount(), 2);
}

// ============================================================================
// CLONE METHOD TESTS
// ============================================================================

TEST_F(TrainTest, CloneCreatesExactCopy) {
    Train train(1, "Express Train", 20);
    train.getSeatAllocator()->allocateSeat(101);
    train.getSeatAllocator()->allocateSeat(102);

    auto cloned = train.clone();
    EXPECT_EQ(cloned->getTrainId(), train.getTrainId());
    EXPECT_EQ(cloned->getTrainName(), train.getTrainName());
    EXPECT_EQ(cloned->getTotalSeats(), train.getTotalSeats());
}

TEST_F(TrainTest, CloneCreatesIndependentObject) {
    Train train(1, "Express Train", 20);
    train.getSeatAllocator()->allocateSeat(101);

    auto cloned = train.clone();
    cloned->getSeatAllocator()->allocateSeat(102);

    EXPECT_EQ(train.getSeatAllocator()->getAllocatedSeatCount(), 1);
    EXPECT_EQ(cloned->getSeatAllocator()->getAllocatedSeatCount(), 2);
}

TEST_F(TrainTest, ClonePreservesSeatAllocatorState) {
    Train train(1, "Express Train", 5);
    train.getSeatAllocator()->allocateSeat(101);
    train.getSeatAllocator()->allocateSeat(102);
    train.getSeatAllocator()->allocateSeat(103);

    auto cloned = train.clone();

    EXPECT_EQ(cloned->getSeatAllocator()->getAllocatedSeatCount(), 3);
    EXPECT_EQ(cloned->getSeatAllocator()->getAvailableSeatCount(), 2);
}

// ============================================================================
// INTEGRATION WITH SEAT ALLOCATOR TESTS
// ============================================================================

TEST_F(TrainTest, AllocateSeatThroughTrain) {
    Train train(1, "Express Train", 5);
    SeatAllocator* allocator = train.getSeatAllocator();

    int seat = allocator->allocateSeat(101);
    EXPECT_EQ(seat, 1);
    EXPECT_TRUE(train.hasAvailableSeats());
}

TEST_F(TrainTest, FillTrainCompletely) {
    Train train(1, "Express Train", 3);
    SeatAllocator* allocator = train.getSeatAllocator();

    allocator->allocateSeat(101);
    allocator->allocateSeat(102);
    allocator->allocateSeat(103);

    EXPECT_FALSE(train.hasAvailableSeats());
}

TEST_F(TrainTest, AddSeatsAfterFull) {
    Train train(1, "Express Train", 2);
    SeatAllocator* allocator = train.getSeatAllocator();

    allocator->allocateSeat(101);
    allocator->allocateSeat(102);
    EXPECT_FALSE(train.hasAvailableSeats());

    train.addSeats(3);
    EXPECT_TRUE(train.hasAvailableSeats());
}

TEST_F(TrainTest, FreeSeatRestoresAvailability) {
    Train train(1, "Express Train", 2);
    SeatAllocator* allocator = train.getSeatAllocator();

    allocator->allocateSeat(101);
    allocator->allocateSeat(102);
    allocator->freeSeat(1);

    EXPECT_TRUE(train.hasAvailableSeats());
}

// ============================================================================
// EDGE CASE TESTS
// ============================================================================

TEST_F(TrainTest, SingleSeatTrain) {
    Train train(1, "Mini Train", 1);
    train.getSeatAllocator()->allocateSeat(101);
    EXPECT_FALSE(train.hasAvailableSeats());
}

TEST_F(TrainTest, LargeCapacityTrain) {
    Train train(1, "Mega Train", 10000);
    EXPECT_EQ(train.getTotalSeats(), 10000);
    EXPECT_TRUE(train.hasAvailableSeats());
}

TEST_F(TrainTest, TrainNameWithNumbers) {
    Train train(1, "Train123", 20);
    EXPECT_EQ(train.getTrainName(), "Train123");
}

TEST_F(TrainTest, TrainNameWithSpaces) {
    Train train(1, "High Speed Rail", 20);
    EXPECT_EQ(train.getTrainName(), "High Speed Rail");
}

TEST_F(TrainTest, MaximumTrainId) {
    Train train(999999, "Express Train", 20);
    EXPECT_EQ(train.getTrainId(), 999999);
}

// ============================================================================
// STRESS TESTS
// ============================================================================

TEST_F(TrainTest, AllocateAndFreeManySeats) {
    Train train(1, "Express Train", 100);
    SeatAllocator* allocator = train.getSeatAllocator();

    // Allocate 50 seats
    for (int i = 1; i <= 50; i++) {
        allocator->allocateSeat(100 + i);
    }

    // Free first 25 seats
    for (int i = 1; i <= 25; i++) {
        allocator->freeSeat(i);
    }

    EXPECT_TRUE(train.hasAvailableSeats());
    EXPECT_EQ(allocator->getAllocatedSeatCount(), 25);
}

TEST_F(TrainTest, MultipleOperationsSequence) {
    Train train(1, "Express Train", 10);

    train.addSeats(5);
    EXPECT_EQ(train.getTotalSeats(), 15);

    train.setSeats(20);
    EXPECT_EQ(train.getTotalSeats(), 20);

    train.getSeatAllocator()->allocateSeat(101);
    EXPECT_TRUE(train.hasAvailableSeats());

    train.setTrainName("Updated Express");
    EXPECT_EQ(train.getTrainName(), "Updated Express");
}



==================================================
FILE PATH: .\tests\test_trainRepo.cpp
==================================================

#include <gtest/gtest.h>
#include "Repo/InMemoryTrainRepository.h"
#include <memory>
#include <algorithm>
#include <stdexcept>
#include <optional>

class InMemoryTrainRepositoryTest : public ::testing::Test {
protected:
    InMemoryTrainRepository repo;

    void SetUp() override {
        repo.clear();
    }

    void TearDown() override {
        repo.clear();
    }
};

// ===================== Basic Save Tests =====================

TEST_F(InMemoryTrainRepositoryTest, SaveAndGetTrainById) {
    Train t1(0, "Express", 20);
    repo.save(t1);

    EXPECT_EQ(t1.getTrainName(), "Express");
    EXPECT_EQ(t1.getTotalSeats(), 20);
    EXPECT_GT(t1.getTrainId(), 0);

    auto fetched = repo.getTrainById(t1.getTrainId());
    ASSERT_TRUE(fetched.has_value());
    EXPECT_EQ(fetched->getTrainName(), "Express");
    EXPECT_EQ(fetched->getTrainId(), t1.getTrainId());
}

TEST_F(InMemoryTrainRepositoryTest, SaveModifiesOriginalTrainId) {
    Train t(0, "Test", 10);
    EXPECT_EQ(t.getTrainId(), 0);

    repo.save(t);

    // After save, the original train should have its ID updated
    EXPECT_GT(t.getTrainId(), 0);
}

// ===================== Auto-Increment ID Tests =====================

TEST_F(InMemoryTrainRepositoryTest, AutoIncrementId) {
    Train t1(0, "Express", 20);
    repo.save(t1);

    Train t2(0, "Regional", 15);
    repo.save(t2);

    EXPECT_EQ(t1.getTrainId(), 1);
    EXPECT_EQ(t2.getTrainId(), 2);
}

TEST_F(InMemoryTrainRepositoryTest, AutoIncrementSequential) {
    std::vector<int> ids;

    for (int i = 0; i < 10; ++i) {
        Train t(0, "Train" + std::to_string(i), 10);
        repo.save(t);
        ids.push_back(t.getTrainId());
    }

    // Verify sequential IDs: 1, 2, 3, ..., 10
    for (size_t i = 0; i < ids.size(); ++i) {
        EXPECT_EQ(ids[i], i + 1);
    }
}

TEST_F(InMemoryTrainRepositoryTest, AutoIncrementAfterDelete) {
    Train t1(0, "Train1", 10);
    repo.save(t1);
    EXPECT_EQ(t1.getTrainId(), 1);

    Train t2(0, "Train2", 10);
    repo.save(t2);
    EXPECT_EQ(t2.getTrainId(), 2);

    // Delete first train
    repo.deleteTrain(t1.getTrainId());

    // Next train should get ID 3, not reuse ID 1
    Train t3(0, "Train3", 10);
    repo.save(t3);
    EXPECT_EQ(t3.getTrainId(), 3);
}

// ===================== Explicit ID Tests =====================

TEST_F(InMemoryTrainRepositoryTest, SaveWithExplicitId) {
    Train t(42, "Explicit", 10);
    repo.save(t);

    EXPECT_EQ(t.getTrainId(), 42);
}

TEST_F(InMemoryTrainRepositoryTest, ExplicitIdDoesNotChangeNextId_IfLower) {
    Train t1(0, "Auto1", 10);
    repo.save(t1); // Gets ID 1, next_id becomes 2

    Train t2(0, "Auto2", 10);
    repo.save(t2); // Gets ID 2, next_id becomes 3

    Train t3(1, "Explicit", 10);
    repo.save(t3); // Should update train with ID 1

    Train t4(0, "Auto3", 10);
    repo.save(t4);
    EXPECT_EQ(t4.getTrainId(), 3);
}

TEST_F(InMemoryTrainRepositoryTest, ExplicitIdUpdatesNextId_IfHigher) {
    Train t1(0, "Auto", 10);
    repo.save(t1);
    EXPECT_EQ(t1.getTrainId(), 1);

    Train t2(100, "High", 10);
    repo.save(t2);
    EXPECT_EQ(t2.getTrainId(), 100);

    Train t3(0, "Auto2", 10);
    repo.save(t3);
    EXPECT_EQ(t3.getTrainId(), 101);
}

TEST_F(InMemoryTrainRepositoryTest, ExplicitIdEqualToNextId) {
    Train t1(0, "Auto", 10);
    repo.save(t1); // ID 1, next_id = 2

    Train t2(2, "Explicit", 10);
    repo.save(t2);
    EXPECT_EQ(t2.getTrainId(), 2);

    Train t3(0, "Auto2", 10);
    repo.save(t3);
    EXPECT_EQ(t3.getTrainId(), 3);
}

TEST_F(InMemoryTrainRepositoryTest, MultipleExplicitHighIds) {
    Train t1(50, "Train50", 10);
    repo.save(t1);

    Train t2(100, "Train100", 10);
    repo.save(t2);

    Train t3(75, "Train75", 10);
    repo.save(t3);

    Train t4(0, "Auto", 10);
    repo.save(t4);
    EXPECT_EQ(t4.getTrainId(), 101);
}



TEST_F(InMemoryTrainRepositoryTest, VeryLargeExplicitId) {
    Train t(999999, "Large", 10);
    repo.save(t);

    EXPECT_EQ(t.getTrainId(), 999999);

    Train t2(0, "Auto", 10);
    repo.save(t2);
    EXPECT_EQ(t2.getTrainId(), 1000000);
}

// ===================== Update Tests =====================

TEST_F(InMemoryTrainRepositoryTest, UpdateExistingTrain) {
    Train t1(0, "Express", 20);
    repo.save(t1);
    int originalId = t1.getTrainId();

    Train updatedTrain(originalId, "Super Express", 30);
    repo.save(updatedTrain);

    EXPECT_EQ(updatedTrain.getTrainId(), originalId);
    EXPECT_EQ(updatedTrain.getTrainName(), "Super Express");
    EXPECT_EQ(updatedTrain.getTotalSeats(), 30);

    auto all = repo.getAllTrains();
    EXPECT_EQ(all.size(), 1);
}

TEST_F(InMemoryTrainRepositoryTest, UpdatePreservesId) {
    Train t1(0, "Original", 10);
    repo.save(t1);
    int originalId = t1.getTrainId();

    Train updated(originalId, "Updated", 20);
    repo.save(updated);

    EXPECT_EQ(updated.getTrainId(), originalId);
    EXPECT_EQ(updated.getTrainName(), "Updated");
    EXPECT_EQ(updated.getTotalSeats(), 20);
}

TEST_F(InMemoryTrainRepositoryTest, UpdateDoesNotChangeNextId) {
    Train t1(0, "Train1", 10);
    repo.save(t1); // ID 1

    Train t2(0, "Train2", 10);
    repo.save(t2); // ID 2

    Train updated(t1.getTrainId(), "Updated", 20);
    repo.save(updated);

    Train t3(0, "Train3", 10);
    repo.save(t3);
    EXPECT_EQ(t3.getTrainId(), 3);
}

TEST_F(InMemoryTrainRepositoryTest, UpdateWithSeatAllocatorState) {
    Train t(0, "Test", 5);
    auto allocator = t.getSeatAllocator();
    allocator->allocateSeat(101);
    allocator->allocateSeat(102);

    repo.save(t);
    int trainId = t.getTrainId();

    EXPECT_EQ(t.getSeatAllocator()->getAvailableSeatCount(), 3);

    auto fetchedOpt = repo.getTrainById(trainId);
    ASSERT_TRUE(fetchedOpt.has_value());
    Train fetched = fetchedOpt.value();
    fetched.getSeatAllocator()->allocateSeat(103);

    repo.save(fetched);

    auto updatedOpt = repo.getTrainById(trainId);
    ASSERT_TRUE(updatedOpt.has_value());
    EXPECT_EQ(updatedOpt->getSeatAllocator()->getAvailableSeatCount(), 2);
}

TEST_F(InMemoryTrainRepositoryTest, UpdateMultipleTimes) {
    Train t(0, "Original", 10);
    repo.save(t);
    int id = t.getTrainId();

    for (int i = 1; i <= 5; ++i) {
        Train update(id, "Version" + std::to_string(i), 10 + i);
        repo.save(update);
    }

    auto finalOpt = repo.getTrainById(id);
    ASSERT_TRUE(finalOpt.has_value());
    EXPECT_EQ(finalOpt->getTrainName(), "Version5");
    EXPECT_EQ(finalOpt->getTotalSeats(), 15);

    auto all = repo.getAllTrains();
    EXPECT_EQ(all.size(), 1);
}

// ===================== Delete Tests =====================

TEST_F(InMemoryTrainRepositoryTest, DeleteTrain) {
    Train t(0, "Express", 20);
    repo.save(t);
    int id = t.getTrainId();

    bool deleted = repo.deleteTrain(id);
    EXPECT_TRUE(deleted);

    // Repo implementation throws std::runtime_error if ID not found
    EXPECT_THROW(repo.getTrainById(id), std::runtime_error);
}

TEST_F(InMemoryTrainRepositoryTest, DeleteNonExistentTrain) {
    bool result = repo.deleteTrain(999);
    EXPECT_FALSE(result);
}

TEST_F(InMemoryTrainRepositoryTest, DeleteAllTrains) {
    Train t1(0, "Train1", 10);
    Train t2(0, "Train2", 10);
    Train t3(0, "Train3", 10);

    repo.save(t1);
    repo.save(t2);
    repo.save(t3);

    EXPECT_TRUE(repo.deleteTrain(t1.getTrainId()));
    EXPECT_TRUE(repo.deleteTrain(t2.getTrainId()));
    EXPECT_TRUE(repo.deleteTrain(t3.getTrainId()));

    auto all = repo.getAllTrains();
    EXPECT_TRUE(all.empty());
}

TEST_F(InMemoryTrainRepositoryTest, DeleteSameTrainTwice) {
    Train t(0, "Test", 10);
    repo.save(t);
    int id = t.getTrainId();

    EXPECT_TRUE(repo.deleteTrain(id));
    EXPECT_FALSE(repo.deleteTrain(id));
}

TEST_F(InMemoryTrainRepositoryTest, DeleteWithExplicitId) {
    Train t(42, "Explicit", 10);
    repo.save(t);

    EXPECT_TRUE(repo.deleteTrain(42));
    EXPECT_THROW(repo.getTrainById(42), std::runtime_error);
}

// ===================== GetTrainById Tests =====================

TEST_F(InMemoryTrainRepositoryTest, GetNonExistentTrain) {
    EXPECT_THROW(repo.getTrainById(999), std::runtime_error);
}

TEST_F(InMemoryTrainRepositoryTest, GetTrainByIdReturnsCorrectTrain) {
    Train t1(0, "Train1", 10);
    Train t2(0, "Train2", 20);
    Train t3(0, "Train3", 30);

    repo.save(t1);
    repo.save(t2);
    repo.save(t3);

    auto fetched2 = repo.getTrainById(t2.getTrainId());
    ASSERT_TRUE(fetched2.has_value());
    EXPECT_EQ(fetched2->getTrainName(), "Train2");
    EXPECT_EQ(fetched2->getTotalSeats(), 20);
}

TEST_F(InMemoryTrainRepositoryTest, GetTrainByIdReturnsCopy) {
    Train t(0, "Original", 10);
    repo.save(t);
    int id = t.getTrainId();

    auto fetchedOpt = repo.getTrainById(id);
    ASSERT_TRUE(fetchedOpt.has_value());
    Train fetched = fetchedOpt.value();
    fetched.setTrainName("Modified");

    auto original = repo.getTrainById(id);
    ASSERT_TRUE(original.has_value());
    EXPECT_EQ(original->getTrainName(), "Original");
}


TEST_F(InMemoryTrainRepositoryTest, GetTrainByZeroId) {
    EXPECT_THROW(repo.getTrainById(0), std::runtime_error);
}

// ===================== GetAllTrains Tests =====================

TEST_F(InMemoryTrainRepositoryTest, GetAllTrains) {
    Train t1(0, "Express", 20);
    Train t2(0, "Regional", 15);

    repo.save(t1);
    repo.save(t2);

    auto all = repo.getAllTrains();
    EXPECT_EQ(all.size(), 2);

    std::vector<std::string> names;
    for (const auto& train : all) {
        names.push_back(train.getTrainName());
    }

    EXPECT_NE(std::find(names.begin(), names.end(), "Express"), names.end());
    EXPECT_NE(std::find(names.begin(), names.end(), "Regional"), names.end());
}

TEST_F(InMemoryTrainRepositoryTest, GetAllTrainsEmpty) {
    auto all = repo.getAllTrains();
    EXPECT_TRUE(all.empty());
}

TEST_F(InMemoryTrainRepositoryTest, GetAllTrainsAfterDelete) {
    Train t1(0, "Train1", 10);
    Train t2(0, "Train2", 15);
    Train t3(0, "Train3", 20);

    repo.save(t1);
    repo.save(t2);
    repo.save(t3);

    repo.deleteTrain(t1.getTrainId());

    auto all = repo.getAllTrains();
    EXPECT_EQ(all.size(), 2);
}

// ===================== Clear Tests =====================

TEST_F(InMemoryTrainRepositoryTest, ClearRepository) {
    Train t1(0, "Express", 20);
    Train t2(0, "Regional", 15);

    repo.save(t1);
    repo.save(t2);

    repo.clear();
    auto all = repo.getAllTrains();
    EXPECT_TRUE(all.empty());
}

TEST_F(InMemoryTrainRepositoryTest, ClearEmptyRepository) {
    repo.clear();
    auto all = repo.getAllTrains();
    EXPECT_TRUE(all.empty());
}

TEST_F(InMemoryTrainRepositoryTest, ClearResetsNextId) {
    Train t1(0, "Train1", 10);
    repo.save(t1);
    EXPECT_EQ(t1.getTrainId(), 1);

    repo.clear();

    Train t2(0, "Train2", 15);
    repo.save(t2);
    EXPECT_EQ(t2.getTrainId(), 1);

    auto all = repo.getAllTrains();
    EXPECT_EQ(all.size(), 1);
}

// ===================== Seat Allocator Tests =====================

TEST_F(InMemoryTrainRepositoryTest, SeatAllocatorWorks) {
    Train t(0, "Express", 5);
    repo.save(t);

    EXPECT_TRUE(t.hasAvailableSeats());
    EXPECT_EQ(t.getSeatAllocator()->getAvailableSeatCount(), 5);

    auto allocator = t.getSeatAllocator();
    for (int i = 1; i <= 5; ++i) {
        int seatNumber = allocator->allocateSeat(100 + i);
        EXPECT_GT(seatNumber, 0);
    }

    EXPECT_FALSE(t.hasAvailableSeats());
    EXPECT_EQ(allocator->getAvailableSeatCount(), 0);
}

TEST_F(InMemoryTrainRepositoryTest, SeatAllocationAndFreeing) {
    Train t(0, "Test Train", 3);
    repo.save(t);
    int trainId = t.getTrainId();

    auto seatAllocator = t.getSeatAllocator();
    int seat1 = seatAllocator->allocateSeat(101);
    int seat2 = seatAllocator->allocateSeat(102);

    EXPECT_EQ(seatAllocator->getAvailableSeatCount(), 1);

    repo.save(t);

    auto fetched = repo.getTrainById(trainId);
    ASSERT_TRUE(fetched.has_value());
    EXPECT_EQ(fetched->getSeatAllocator()->getAvailableSeatCount(), 1);
}

TEST_F(InMemoryTrainRepositoryTest, PreservesSeatAllocatorState) {
    Train t(0, "State Test", 3);
    auto allocator = t.getSeatAllocator();
    allocator->allocateSeat(101);
    allocator->allocateSeat(102);

    repo.save(t);

    EXPECT_EQ(t.getSeatAllocator()->getAvailableSeatCount(), 1);

    auto fetched = repo.getTrainById(t.getTrainId());
    ASSERT_TRUE(fetched.has_value());
    EXPECT_EQ(fetched->getSeatAllocator()->getAvailableSeatCount(), 1);
}

// ===================== Edge Cases and Boundary Tests =====================

TEST_F(InMemoryTrainRepositoryTest, DuplicateTrainNames) {
    Train t1(0, "Express", 10);
    Train t2(0, "Express", 15);

    repo.save(t1);
    repo.save(t2);

    EXPECT_NE(t1.getTrainId(), t2.getTrainId());

    auto all = repo.getAllTrains();
    EXPECT_EQ(all.size(), 2);
}

TEST_F(InMemoryTrainRepositoryTest, SaveEmptyNameTrainThrows) {
    // Cannot create a train with empty name
    EXPECT_THROW(Train t(5, "", 10), std::runtime_error);
}

TEST_F(InMemoryTrainRepositoryTest, SaveValidTrain) {
    Train t(1, "Valid Train", 10);
    repo.save(t);

    auto fetched = repo.getTrainById(t.getTrainId());
    ASSERT_TRUE(fetched.has_value());
    EXPECT_EQ(fetched->getTrainName(), "Valid Train");
}
TEST_F(InMemoryTrainRepositoryTest, NegativeExplicitIdThrows) {
    // Cannot create a train with negative ID; should throw
    EXPECT_THROW(Train t(-5, "Negative", 10), std::runtime_error);

    // Next auto-increment train works fine
    Train t2(0, "Auto", 10);
    repo.save(t2);
    EXPECT_EQ(t2.getTrainId(), 1);

    auto fetched = repo.getTrainById(t2.getTrainId());
    ASSERT_TRUE(fetched.has_value());
    EXPECT_EQ(fetched->getTrainName(), "Auto");
}





TEST_F(InMemoryTrainRepositoryTest, MultipleOperations) {
    Train t1(0, "Train A", 10);
    Train t2(0, "Train B", 15);
    Train t3(0, "Train C", 20);

    repo.save(t1);
    repo.save(t2);
    repo.save(t3);

    auto all = repo.getAllTrains();
    EXPECT_EQ(all.size(), 3);

    bool deleted = repo.deleteTrain(t2.getTrainId());
    EXPECT_TRUE(deleted);

    all = repo.getAllTrains();
    EXPECT_EQ(all.size(), 2);

    std::vector<std::string> names;
    for (const auto& train : all) {
        names.push_back(train.getTrainName());
    }
    EXPECT_NE(std::find(names.begin(), names.end(), "Train A"), names.end());
    EXPECT_NE(std::find(names.begin(), names.end(), "Train C"), names.end());
    EXPECT_EQ(std::find(names.begin(), names.end(), "Train B"), names.end());
}

TEST_F(InMemoryTrainRepositoryTest, SaveManyTrains) {
    const int COUNT = 100;
    std::vector<int> ids;

    for (int i = 0; i < COUNT; ++i) {
        Train t(0, "Train" + std::to_string(i), i + 1);
        repo.save(t);
        ids.push_back(t.getTrainId());
    }

    auto all = repo.getAllTrains();
    EXPECT_EQ(all.size(), COUNT);

    for (int i = 0; i < COUNT; ++i) {
        EXPECT_EQ(ids[i], i + 1);
    }
}

TEST_F(InMemoryTrainRepositoryTest, MixedExplicitAndAutoIds) {
    Train t1(0, "Auto1", 10);
    repo.save(t1); // ID 1
    EXPECT_EQ(t1.getTrainId(), 1);

    Train t2(50, "Explicit50", 10);
    repo.save(t2); // ID 50

    Train t3(0, "Auto2", 10);
    repo.save(t3); // ID 51
    EXPECT_EQ(t3.getTrainId(), 51);

    Train t4(25, "Explicit25", 10);
    repo.save(t4); // ID 25

    Train t5(0, "Auto3", 10);
    repo.save(t5); // ID 52
    EXPECT_EQ(t5.getTrainId(), 52);

    auto all = repo.getAllTrains();
    EXPECT_EQ(all.size(), 5);
}
TEST_F(InMemoryTrainRepositoryTest, SaveWithZeroSeats) {
    Train t(0, "ZeroSeats", 0);
    repo.save(t);

    EXPECT_EQ(t.getTotalSeats(), 0);                     // Reflects the actual Train value
    EXPECT_EQ(t.getSeatAllocator()->getAvailableSeatCount(), 10); // SeatAllocator defaults to 10
}


TEST_F(InMemoryTrainRepositoryTest, SaveWithNegativeIdThrows) {
    // Trying to create a train with a negative ID should throw
    EXPECT_THROW({
                     Train t(-10, "Negative", 10);
                     repo.save(t);
                 }, std::runtime_error);
}

TEST_F(InMemoryTrainRepositoryTest, GetTrainWithNegativeIdThrows) {
    // Trying to fetch a train with a negative ID should throw
    EXPECT_THROW(repo.getTrainById(-10), std::runtime_error);
}

TEST_F(InMemoryTrainRepositoryTest, SaveEmptyNameTrain) {
    // Cannot create a train with empty name; should throw
    EXPECT_THROW(Train emptyNameTrain(5, "", 10), std::runtime_error);

    // For a valid train
    Train t(1, "Valid Train", 10);
    repo.save(t);

    auto fetched = repo.getTrainById(t.getTrainId());
    ASSERT_TRUE(fetched.has_value());
    EXPECT_EQ(fetched->getTrainName(), "Valid Train");
}

==================================================
FILE PATH: .\tests\test_trainSevice.cpp
==================================================

#include <gtest/gtest.h>
#include "Services/TrainService.h"
#include "Repo/InMemoryTrainRepository.h"

class TrainServiceTest : public ::testing::Test {
protected:
    std::unique_ptr<InMemoryTrainRepository> repo;
    std::unique_ptr<TrainService> service;

    void SetUp() override {
        repo = std::make_unique<InMemoryTrainRepository>();
        service = std::make_unique<TrainService>(repo.get());
    }
};

TEST_F(TrainServiceTest, CreateTrain_Success) {
    Train train = service->createTrain("Test Train", 30);
    EXPECT_GT(train.getTrainId(), 0);
    EXPECT_EQ(train.getTrainName(), "Test Train");
    EXPECT_EQ(train.getTotalSeats(), 30);
}

TEST_F(TrainServiceTest, GetTrain_Exists) {
    Train created = service->createTrain("Test Train", 30);
    auto retrieved = service->getTrain(created.getTrainId());
    ASSERT_TRUE(retrieved.has_value());
    EXPECT_EQ(retrieved->getTrainName(), "Test Train");
}

TEST_F(TrainServiceTest, GetTrain_NotExists) {
    EXPECT_THROW(service->getTrain(999), std::runtime_error);
}

TEST_F(TrainServiceTest, GetAllTrains_Empty) {
    auto trains = service->getAllTrains();
    EXPECT_TRUE(trains.empty());
}

TEST_F(TrainServiceTest, GetAllTrains_Multiple) {
    service->createTrain("Train 1", 20);
    service->createTrain("Train 2", 30);
    service->createTrain("Train 3", 40);

    auto trains = service->getAllTrains();
    EXPECT_EQ(trains.size(), 3);
}

TEST_F(TrainServiceTest, UpdateTrain_Success) {
    Train created = service->createTrain("Old Name", 20);
    Train updated = service->updateTrain(created.getTrainId(), "New Name", 30);

    EXPECT_EQ(updated.getTrainName(), "New Name");
    EXPECT_EQ(updated.getTotalSeats(), 30);
}

TEST_F(TrainServiceTest, UpdateTrain_NotExists) {
    EXPECT_THROW(service->updateTrain(999, "Test", 30), std::runtime_error);
}

TEST_F(TrainServiceTest, DeleteTrain_Success) {
    Train created = service->createTrain("Test", 20);
    bool deleted = service->deleteTrain(created.getTrainId());
    EXPECT_TRUE(deleted);
}

TEST_F(TrainServiceTest, DeleteTrain_NotExists) {
    bool deleted = service->deleteTrain(999);
    EXPECT_FALSE(deleted);
}

TEST_F(TrainServiceTest, AddSeats_ById_Success) {
    Train created = service->createTrain("Test", 20);
    Train updated = service->addSeats(created.getTrainId(), 10);
    EXPECT_EQ(updated.getTotalSeats(), 30);
}

TEST_F(TrainServiceTest, AddSeats_ByName_Success) {
    service->createTrain("Test Train", 20);
    Train updated = service->addSeats("Test Train", 10);
    EXPECT_EQ(updated.getTotalSeats(), 30);
}

TEST_F(TrainServiceTest, AddSeats_ByName_NotExists) {
    EXPECT_THROW(service->addSeats("NonExistent", 10), std::runtime_error);
}

TEST_F(TrainServiceTest, IsAvailableSeat_True) {
    Train created = service->createTrain("Test", 20);
    EXPECT_TRUE(service->isAvailbleSeat(created.getTrainId()));
}

TEST_F(TrainServiceTest, IsAvailableSeat_NotExists) {
    EXPECT_THROW(service->isAvailbleSeat(999), std::runtime_error);
}

==================================================
FILE PATH: .\tests\structures\test_stack.cpp
==================================================

#include <gtest/gtest.h>
#include "structures/stack.h"

// Test fixture (optional, but useful if you want multiple tests)
class StackTest : public ::testing::Test {
protected:
    stack<int> s;
};

// Test that new stack is empty
TEST_F(StackTest, IsEmptyInitially) {
EXPECT_TRUE(s.empty());
EXPECT_EQ(s.size(), 0);
}

// Test push operation
TEST_F(StackTest, PushIncreasesSize) {
s.push(10);
EXPECT_FALSE(s.empty());
EXPECT_EQ(s.size(), 1);
EXPECT_EQ(s.top(), 10);

s.push(20);
EXPECT_EQ(s.size(), 2);
EXPECT_EQ(s.top(), 20);
}

// Test pop operation
TEST_F(StackTest, PopDecreasesSize) {
s.push(5);
s.push(15);

EXPECT_EQ(s.top(), 15);
s.pop();
EXPECT_EQ(s.top(), 5);
EXPECT_EQ(s.size(), 1);

s.pop();
EXPECT_TRUE(s.empty());
EXPECT_EQ(s.size(), 0);
}

// Test popping from empty stack throws
TEST_F(StackTest, PopOnEmptyThrows) {
EXPECT_THROW(s.pop(), std::runtime_error);
}

// Test top on empty stack throws
TEST_F(StackTest, TopOnEmptyThrows) {
EXPECT_THROW(s.top(), std::runtime_error);
}

// Test multiple push/pop
TEST_F(StackTest, PushPopSequence) {
for (int i = 0; i < 5; ++i) {
s.push(i * 10);
EXPECT_EQ(s.top(), i * 10);
}

for (int i = 4; i >= 0; --i) {
EXPECT_EQ(s.top(), i * 10);
s.pop();
}

EXPECT_TRUE(s.empty());
}

