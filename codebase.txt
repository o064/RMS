
==================================================
FILE PATH: .\include\CLIController.h
==================================================

//
// Created by Omar on 11/19/2025.
//

#ifndef RMS_CLICONTROLLER_H
#define RMS_CLICONTROLLER_H

#include "RMSFacade.h"
#include <string>
#include <iostream>
using namespace std;

class CLIController {
private:
    RMSFacade* facade;

public:
    CLIController(RMSFacade* facade);
    //helpers to manipulate text
    static vector<string> tokenize(const string &args) ;
    static string readLine();
    static  void waitUser();
    // run
     void run();
     static void clear();
     // help
     static void show_help();

    // train commands
    void list_trains();
    void add_train(const vector<string>& args);
    void get_train_availability(const vector<string>& args);
    void update_train(const vector<string>& args);
    void add_seats(const vector<string>& args);
    void delete_train(const vector<string>& args);
    void get_train_status(const vector<string>& args);

    // passenger commands

    void add_passenger(const vector<string>& args);
    void update_passenger(const vector<string>& args);
    void delete_passenger(const vector<string>& args);
    void list_passengers();

    // ticket commands
    void list_tickets();

    void cancel_ticket(const vector<string>& args);
    void book_ticket(const vector<string>& args);


};
#endif //RMS_CLICONTROLLER_H


==================================================
FILE PATH: .\include\RMSApp.h
==================================================

//
// Created by Omar on 11/18/2025.
//

#ifndef RMS_RMSAPP_H
#define RMS_RMSAPP_H

#include "StartupManager.h"
#include "CLIController.h"

class RMSApp {
    unique_ptr<StartupManager> startupManager;
    unique_ptr<CLIController> cli;
public:
    RMSApp();
    ~RMSApp()= default;
    void run();
};
#endif //RMS_RMSAPP_H


==================================================
FILE PATH: .\include\RMSCommand.h
==================================================

// Created by Omar on 12/1/2025.

#ifndef RMS_RMSCOMMAND_H
#define RMS_RMSCOMMAND_H

#include <string>
#include <unordered_map>

using   std::unordered_map;
using   std::string;
    class RMSCommand {
    public:
        // enums to select the needed command
        enum class MainCmd { TRAIN, PASSENGER, TICKET, SYSTEM, UNKNOWN };
        enum class TrainCmd { LIST, ADD, DELETE, UPDATE, SEATS_ADD,STATUS, AVAILABILITY, UNKNOWN };
        enum class PassengerCmd { LIST, ADD, DELETE, UPDATE, UNKNOWN };
        enum class TicketCmd { LIST, BOOK, CANCEL, UNKNOWN };
        enum class SystemCmd { HELP, EXIT ,CLEAR, UNKNOWN };
        // lookup trees - static to use it without making objects
        static MainCmd getMainCmd(const string& cmd) ;

        static TrainCmd getTrainCmd(const string& sub) ;

        static PassengerCmd getPassengerCmd(const string& sub) ;

        static TicketCmd getTicketCmd(const string& sub) ;

        static SystemCmd getSystemCmd(const string& cmd) ;
    };





#endif //RMS_RMSCOMMAND_H


==================================================
FILE PATH: .\include\RMSFacade.h
==================================================

//
// Created by Omar on 11/19/2025.
//

#ifndef RMS_RMSFACADE_H
#define RMS_RMSFACADE_H

#include <vector>
#include <optional>
#include "Services/TicketService.h"
#include "Services/PassengerService.h"
#include "Services/TrainService.h"

class RMSFacade
{
private:
    TrainService *trainService;
    TicketService *ticketService;
    PassengerService *passengerService;

public:
    RMSFacade(TrainService *ts, TicketService *tks, PassengerService *ps);

    // train features
    std::vector<Train> listTrains();
    Train addTrain(std::string name,  int totalSeats);
    std::optional<Train> getTrain(int trainId);
    bool getTrainAvailability(int trainId);
    Train updateTrain(int trainId, const std::string& name  ,int seats=0);
    Train addSeats(int trainId,int seats=0);
    Train addSeats(const std::string& name,int seats=0);
    void deleteTrain(int trainId);
    void trainStatus(int trainId);

    // passenger features
    std::vector<Passenger> listPassengers();
    std::optional<Passenger> getPassenger(int totalSeats);
    Passenger addPassenger( const std::string& name);
    Passenger updatePassenger(int passengerId, const std::string &name);
    void deletePassenger(int passengerId);


    // ticket features
    std::vector<Ticket> listTickets();
    std::optional<Ticket> bookTicket(int trainId, const std::string& passengerName);
    void cancelTicket(int ticketId);


};
#endif // RMS_RMSFACADE_H


==================================================
FILE PATH: .\include\StartupManager.h
==================================================

//
// Created by Omar on 11/19/2025.
//

#ifndef RMS_STARTUPMANAGER_H
#define RMS_STARTUPMANAGER_H

#include "RMSFacade.h"
#include <memory>

class StartupManager {
private:
    std::unique_ptr<ITrainRepository> trainRepository;
    std::unique_ptr<ITicketRepository> ticketRepository;
    std::unique_ptr<IPassengerRepository> passengerRepository;
    std::unique_ptr<TrainService> trainService;
    std::unique_ptr<PassengerService> passengerService;
    std::unique_ptr<TicketService> ticketService;

    std::unique_ptr<RMSFacade> facade;
public:
    RMSFacade * buildFacade() ;

};
#endif //RMS_STARTUPMANAGER_H


==================================================
FILE PATH: .\include\models\Passenger.h
==================================================

//
// Created by Omar on 11/19/2025.
//

#ifndef RMS_PASSENGER_H
#define RMS_PASSENGER_H
#include <string>
class Passenger{
    std::string name;
    int id;
public:
    Passenger() = default;
    Passenger(const int id, const std::string& name);
    int getId() const;
    std::string getName() const;
    void setName(const std::string& name);

    void setId(const int & passengerId) ;

    void print(const std::string& msg) const ;

};
#endif //RMS_PASSENGER_H


==================================================
FILE PATH: .\include\models\SeatAllocator.h
==================================================

//
// Created by Omar on 11/19/2025.
//


#ifndef RMS_SEATALLOCATOR_H
#define RMS_SEATALLOCATOR_H

#include <unordered_map>
#include <vector>
#include <queue>
#include <set>
#include "../structures/stack.h"
#include <string>
#include<memory>
#include <functional>

class SeatAllocator{
    std::set<int> availableSeats;
    std::queue<int> waitingList;
    std::set<int> waitingSet;              // prevent duplicate waiting entries
    std::unordered_map<int, int> allocatedSeats;
    stack<int> cancelledSeats;
    int totalSeats ;
public:

    SeatAllocator( int totalSeats = 10);
    // for copying
    std::unique_ptr<SeatAllocator> clone() const;
    SeatAllocator(const SeatAllocator& other);
    SeatAllocator& operator=(const SeatAllocator& other);

    void addSeats(int seats);
    void changeTotalSeats(int newTotalSeats);

    int freeSeat( int seatNumber);
    int allocateSeat( int passengerId);
    int processWaitingList(int seatsToAdd, std::function<void(int)> bookCallback)  ;


    int getAvailableSeatCount() const;
    int getAllocatedSeatCount() const;
    int getTotalSeats() const;
    int getWaitingListSize()const;

    std::queue<int> getWaitingList()const;

    bool hasAvailableSeats() const;

    void printStatus() const;

};
#endif //RMS_SEATALLOCATOR_H


==================================================
FILE PATH: .\include\models\Ticket.h
==================================================

//
// Created by Omar on 11/19/2025.
//

#ifndef RMS_TICKET_H
#define RMS_TICKET_H

#include "Passenger.h"

enum Status
{
    booked,
    cancelled
};
class Ticket
{
    int id;
    int ticketSeat;
    int trainId;
    Passenger passenger;
    Status status;

public:
public:
    Ticket() = default;
    Ticket(const int id,const int seat, const int trainId, Passenger p);
    int getId() const;
    int getSeat() const;
    Status getStatus() const;
    void setStatus(const Status& s);
    int getTrainId() const;
    Passenger getPassenger() const;
    void setId(const int newId);
    void print(const std::string& msg) const ;

};
#endif // RMS_TICKET_H


==================================================
FILE PATH: .\include\models\Train.h
==================================================

#ifndef RMS_TRAIN_H
#define RMS_TRAIN_H

#include "SeatAllocator.h"
#include <string>

class Train {
private:
    int id;
    std::string name;
    int totalSeats;
    std::unique_ptr<SeatAllocator> seatAllocator;

public:
    // Constructor
    Train() = default;
    Train(const int id, const std::string& name, const int totalSeats = 10);
    ~Train() = default;


    //  copy operations for unique ptr
    std::unique_ptr<Train> clone() const ;
    Train(const Train& other);
    Train& operator=(const Train& other);

    // move operations
    Train(Train&&) = default;
    Train& operator=(Train&&) = default;

    int getTrainId() const;
    std::string getTrainName() const;
    SeatAllocator* getSeatAllocator() const;

    void setTrainName(const std::string& name);
    void setTrainId(int trainId);
    void setSeats(int seats);
    void addSeats(int seats);

    bool hasAvailableSeats() const;

    int getTotalSeats() const;
    void trainStatus() const ;
    void print(const std::string& msg) const ;

};

#endif //RMS_TRAIN_H

==================================================
FILE PATH: .\include\Repo\InMemoryPassengerRepository.h
==================================================

//
// Created by Omar on 11/19/2025.
//

#ifndef RMS_INMEMORYPASSENGERREPOSITORY_H
#define RMS_INMEMORYPASSENGERREPOSITORY_H

#include <vector>
#include <optional>

#include "../models/Passenger.h"
#include "../structures/map.h"
#include "IPassengerRepository.h"

class InMemoryPassengerRepository : public IPassengerRepository
{
private:
    Map<int, Passenger> passengers;
    int next_id = 1;
public:
    std::optional<Passenger> getPassenger(const int& passengerId) override;
    bool deletePassenger(const int& passengerId) override;
    void save( Passenger& passenger) override;
    std::vector<Passenger> getAllPassengers() override;
    void clear() override;
};
#endif // RMS_INMEMORYPASSENGERREPOSITORY_H


==================================================
FILE PATH: .\include\Repo\InMemoryTicketRepository.h
==================================================

//
// Created by Omar on 11/19/2025.
//

#ifndef RMS_INMEMORYTICKETREPOSITORY_H
#define RMS_INMEMORYTICKETREPOSITORY_H

#include <vector>
#include <optional>

#include "../structures/map.h"
#include "ITicketRepository.h"
#include "../models/Ticket.h"

class InMemoryTicketRepository : public ITicketRepository
{
private:
    Map<int, Ticket> tickets;
    int next_id = 1;

public:
    InMemoryTicketRepository() = default;
    ~InMemoryTicketRepository() override = default;
    std::optional<Ticket> getTicketByTrainAndPassenger(int trainId, int passengerId) override;
    bool deleteTicket(int ticketId) override;
    void save(Ticket& ticket) override;
    std::vector<Ticket> getAllTickets() override;
    std::optional<Ticket> getTicketById(int ticketId) override;
    void clear() override;
};
#endif // RMS_INMEMORYTICKETREPOSITORY_H


==================================================
FILE PATH: .\include\Repo\InMemoryTrainRepository.h
==================================================

#ifndef RMS_INMEMORYTRAINREPOSITORY_H
#define RMS_INMEMORYTRAINREPOSITORY_H

#include "../models/Train.h"
#include "ITrainRepository.h"
#include <optional>
#include <map>
 #include "../structures/map.h"


class InMemoryTrainRepository : public ITrainRepository {
private:
    Map<int, Train> trains;
    int next_id = 1;

public:
    InMemoryTrainRepository() = default;
    ~InMemoryTrainRepository() override = default;

    std::vector<Train> getAllTrains() const override;
    bool deleteTrain(int trainId) override;
    void  save( Train& newTrain) override;
    std::optional<Train> getTrainById(const int& trainId) const  override;
    void clear() override;
};

#endif

==================================================
FILE PATH: .\include\Repo\IPassengerRepository.h
==================================================

//
// Created by Omar on 11/19/2025.
//

#ifndef RMS_IPASSENGERREPOSITORY_H
#define RMS_IPASSENGERREPOSITORY_H

#include <vector>
#include "../models/Passenger.h"
#include <optional>

class IPassengerRepository
{
public:
    virtual std::optional<Passenger> getPassenger(const int& passengerId) = 0;
    virtual bool deletePassenger(const int& passengerId) = 0;
    virtual void save( Passenger& passenger) = 0;
    virtual std::vector<Passenger> getAllPassengers() = 0;
    virtual void clear() = 0;

    virtual ~IPassengerRepository() = default;
};
#endif // RMS_IPASSENGERREPOSITORY_H


==================================================
FILE PATH: .\include\Repo\ITicketRepository.h
==================================================

//
// Created by Omar on 11/19/2025.
//

#ifndef RMS_ITICKETREPOSITORY_H
#define RMS_ITICKETREPOSITORY_H

#include <vector>
#include <optional>

#include "../models/Ticket.h"

class ITicketRepository
{
public:
    virtual std::optional<Ticket> getTicketByTrainAndPassenger(int trainId, int passengerId) = 0;
    virtual bool deleteTicket(int ticketId) = 0;
    virtual void save(Ticket& ticket) = 0;
    virtual std::vector<Ticket> getAllTickets() = 0;
    virtual std::optional<Ticket> getTicketById(int) = 0;
    virtual void clear() = 0;

    virtual ~ITicketRepository() = default;
};
#endif // RMS_ITICKETREPOSITORY_H


==================================================
FILE PATH: .\include\Repo\ITrainRepository.h
==================================================

#ifndef RMS_ITRAINREPOSITORY_H
#define RMS_ITRAINREPOSITORY_H

#include "../models/Train.h"
#include <vector>
#include <optional>

class ITrainRepository {
public:
    virtual std::vector<Train> getAllTrains() const = 0;
    virtual bool deleteTrain(int) = 0;
    virtual void save(Train&) = 0;
    virtual std::optional<Train> getTrainById(const int& trainId) const   = 0;
    virtual void clear() = 0;
    virtual ~ITrainRepository() = default;
};

#endif

==================================================
FILE PATH: .\include\Services\PassengerService.h
==================================================

//
// Created by Omar on 11/19/2025.
//

#ifndef RMS_PASSENGERSERVICE_H
#define RMS_PASSENGERSERVICE_H

#include <vector>
#include "../models/Passenger.h"
#include "../Repo/IPassengerRepository.h"

class PassengerService
{
private:
    IPassengerRepository *passengerRepository;

public:
    PassengerService(IPassengerRepository *repo);
    std::optional<Passenger> getPassenger(const int& passengerId);
    std::vector<Passenger> getAllPassengers();
    Passenger createPassenger(const std::string& name);
    Passenger updatePassenger(const int passengerId , const std::string& name);
    bool deletePassenger(const int& passengerId);
    Passenger find_or_create_passenger(const std::string& name);
};
#endif // RMS_PASSENGERSERVICE_H


==================================================
FILE PATH: .\include\Services\TicketService.h
==================================================

//
// Created by Omar on 11/19/2025.
//

#ifndef RMS_TICKETSERVICE_H
#define RMS_TICKETSERVICE_H

#include "../Repo/ITicketRepository.h"
#include "TrainService.h"
#include "PassengerService.h"

class TicketService
{
private:
    ITicketRepository *ticketRepository;
    TrainService *trainService;
    PassengerService *passengerService;


public:
    TicketService(ITicketRepository *repo , TrainService* ts,PassengerService* ps);
    std::optional<Ticket> getTicket(const int& ticketId);
    std::vector<Ticket> getAllTickets();
    Ticket updateTicket(Ticket &t);

    std::optional<Ticket> getTicketByTrainAndPassenger(const int& trainId, const int& passengerId);
    std::optional<Ticket> bookTicket(const int& trainId, const int& passengerId);
    void cancelTicket(const int& ticketId);
};
#endif // RMS_TICKETSERVICE_H


==================================================
FILE PATH: .\include\Services\TrainService.h
==================================================

//
// Created by Omar on 11/19/2025.
//

#ifndef RMS_TRAINSERVICE_H
#define RMS_TRAINSERVICE_H

#include "../Repo/ITrainRepository.h"
#include <optional>

class TrainService{
private:
    ITrainRepository* trainRepository;
public:
    TrainService(ITrainRepository* repo) ;
    ~TrainService();
    //crud
    std::optional<Train> getTrain(const int&);
    std::vector<Train> getAllTrains();
    Train createTrain(const std::string& name,int seats);
    Train updateTrain(const int& id , const std::string& name,int seats = 0);
    bool deleteTrain(int trainId);

    //seats
    Train addSeats(const int trainId , const int seats);
    Train addSeats(const std::string name  , const int seats);
    // status
    void printStatus(int trainId);
    bool isAvailbleSeat(int trainId);
    void save(Train & train);
};
#endif //RMS_TRAINSERVICE_H


==================================================
FILE PATH: .\include\structures\map.h
==================================================

#ifndef MAP_HPP_
#define MAP_HPP_
#include <iostream>
#include <stdexcept>
#include <utility>
#include <algorithm>

template<typename Key, typename Value> class Map; // Forward declration 

template<typename Key, typename Value>
class MapNode{
public:
    std::pair<Key, Value> data;
    MapNode* left;
    MapNode* right;
    MapNode* parent;
    int height;

    MapNode(const std::pair<Key, Value>& data): data{data}, left{nullptr}, right{nullptr}, parent{nullptr}, height{}{ }
    MapNode(const std::pair<Key, Value>& data, MapNode* left, MapNode* right, int height = 0)
    :data{data}, left{left}, right{right}, parent{nullptr}, height{height}{ }
    MapNode(std::pair<Key, Value>&& data): data{std::move(data)}, left{nullptr}, right{nullptr}, parent{nullptr}, height{}{ }
    MapNode(std::pair<Key, Value>&& data, MapNode* left, MapNode* right, int height = 0)
    :data{std::move(data)}, left{left}, right{right}, parent{nullptr}, height{height}{ }

};

template<typename Key, typename Value>
class MapIterator{
private:
    MapNode<Key, Value>* node;

    // return the next node in a sorted order
    MapNode<Key, Value>* successor(MapNode<Key, Value>* nodePtr){
        if(nodePtr == nullptr) return nullptr;
        // If right subtree isn't empty
        // Go right then down to far left
        if(nodePtr->right != nullptr){
            nodePtr = nodePtr->right;
            while(nodePtr->left != nullptr) nodePtr = nodePtr->left; // Keep going down and to the left
            return nodePtr;
        }

        // If right subtreee is empty
        // Keep goind up until we approach from a left suptree
        MapNode<Key, Value>* p = nodePtr->parent;
        while(p != nullptr && nodePtr == p->right){ 
            nodePtr = p;
            p = nodePtr->parent;
        }
        // We either reached the top of the tree (no bigger value),
        // Or we approached the parent from the left
        return p;
    }

    MapNode<Key, Value>* predecessor(MapNode<Key, Value>* nodePtr){
        if(nodePtr == nullptr) return nullptr;

        // If left subtree isn't empty
        // Go left then down to far right
        if(nodePtr->left != nullptr){
            nodePtr = nodePtr->left;
            while(nodePtr->right != nullptr) nodePtr = nodePtr->right; // Keep going down and to the right
            return nodePtr;
        }    

        // If left subtreee is empty
        // Keep goind up until we approach from a right suptree
        MapNode<Key, Value>* p = nodePtr->parent;
        while(p != nullptr && nodePtr == p->left){ 
            nodePtr = p;
            p = nodePtr->parent;
        }
        // We either reached the top of the tree (no bigger value),
        // Or we approached the parent from the right
        return p;
    }
public:
    Key first;
    Value second;
    MapIterator(MapNode<Key, Value>* node): node{node} {
        if(node!= nullptr){
            first = node->data.first;
            second = node->data.second;
        }
    }

    // Dereference
    std::pair<Key, Value>& operator*() const{
        if(node == nullptr)
            throw std::out_of_range("Can't dereference iterator");
        return node->data;
    }
    std::pair<Key, Value>* operator->() const{
        if(node == nullptr)
            throw std::out_of_range("Can't dereference iterator");
        return &(node->data);
    }

    // ++ opeartor
    MapIterator<Key, Value>& operator++(){
        // Update the node pointer
        node = successor(node);
        return *this;
    }

    // -- operator
    MapIterator<Key, Value>& operator--(){
        // Update the node pointer
        node = predecessor(node);
        return *this;
    }

    bool operator==(const MapIterator<Key, Value>& rhs)const{
        return node == rhs.node;
    }
    
    bool operator!=(const MapIterator<Key, Value>& rhs)const{
        return node != rhs.node;
    }
    friend class Map<Key, Value>;
};

template<typename Key, typename Value>
class Map{
private:
    MapNode<Key, Value>* root;
    int s{}; // Size
    static const int ALLOWED_IMBALANCE = 1;

    int height(MapNode<Key, Value>* nodePtr){
        // Used to get the heights of the nodes
        return (nodePtr == nullptr?-1:nodePtr->height);    
    }

    void insert(const std::pair<Key, Value>& item, MapNode<Key, Value>*& nodePtr){
        if(nodePtr == nullptr) {// We reached a leaf, insert the node
            nodePtr = new MapNode{item};
            ++s;
        } 

        else if (item.first < nodePtr->data.first)// Move left
            insert(item, nodePtr->left);

        else if (item.first > nodePtr->data.first) // Move right 
            insert(item, nodePtr->right);

        else { // Duplicate was found
               // Update the value
            nodePtr->data.second = item.second;
        }; 
        // Update children's parent pointer
        updateParentPointer(nodePtr);
        // Rebalace the tree
        balance(nodePtr);
    }

    void updateParentPointer(MapNode<Key, Value>* nodePtr){
        if (nodePtr == nullptr) return;
        if(nodePtr->right != nullptr) nodePtr->right->parent = nodePtr;
        if(nodePtr->left != nullptr) nodePtr->left->parent = nodePtr;
    }

    void insert(std::pair<Key, Value>&& item, MapNode<Key, Value>*& nodePtr){
        if(nodePtr == nullptr) {// We reached a leaf, insert the node
            nodePtr = new MapNode{item};
            ++s;
        }      

        else if (item.first < nodePtr->data.first) // Move left
            insert(std::move(item), nodePtr->left);

        else if (item.first > nodePtr->data.first) // Move right 
            insert(std::move(item), nodePtr->right);

        else { // Duplicate was found
               // Update the value
            nodePtr->data.second = item.second;
        }; 
        // Update children's parent pointer
        updateParentPointer(nodePtr);
        // Rebalance the tree
        balance(nodePtr);
    }

    void balance(MapNode<Key, Value>*& nodePtr){
        if(nodePtr == nullptr) return;

        if(height(nodePtr->left) - height(nodePtr->right) > ALLOWED_IMBALANCE){
            // Left side causes imbalance
            if(height(nodePtr->left->left)>= height(nodePtr->left->right))
                // left side of the left child casuse imbalance, case 1
                rotateWithLeftChild(nodePtr); // Single rotation
            else
                // right side of the left child casuse imbalance, case 2
                doubleWithLeftChild(nodePtr); // Double rotation
        }
        else if(height(nodePtr->right) - height(nodePtr->left) > ALLOWED_IMBALANCE){
            // Right side causes imbalance
            if(height(nodePtr->right->right) >= height(nodePtr->right->left))
                // right side of the child casuse imbalance, case 4
                rotateWithRightChild(nodePtr);
            else 
                // left side of the right child casuse imbalance, case 3
                doubleWithRightChild(nodePtr);
        }
        // Update the height of the node
        nodePtr->height = std::max(height(nodePtr->left), height(nodePtr->right)) +1;
    }
    void rotateWithLeftChild(MapNode<Key, Value>*& parent){
        // Hold the child node with a pointer
        MapNode<Key, Value>* child = parent->left; 
        // Repoint the parent's left pointer with the child's right's child
        parent->left = child->right;
        // Repoint the child's right pointer to its parent, rotation is done
        child->right = parent;
        // Update grandchildren's parent pointers
        updateParentPointer(parent);
        // Update the heights of parent & child
        parent->height = std::max(height(parent->left), height(parent->right))+1;
        child->height = std::max(height(child->right), height(child->left))+1;

        // Repoint the passed-by-reference pointer to the new parent
        parent = child;
        // Update the parent of the new parent
        parent->parent = parent->right->parent;
        // Update parent pointer of the children of the new parent
        updateParentPointer(parent);

    }
    void doubleWithLeftChild(MapNode<Key, Value>*& nodePtr){
        rotateWithRightChild(nodePtr->left);
        rotateWithLeftChild(nodePtr);
    }
    void rotateWithRightChild(MapNode<Key, Value>*& parent){
        // Hold the child node with a pointer
        MapNode<Key, Value>* child = parent->right;
        // Repoint the the parent's left pointer to the right child of its child
        parent->right = child->left;
        // Repoint the child's left pointer to its parent, rotaion is done
        child->left = parent;
        // Update grandchildren's parent pointers
        updateParentPointer(parent);
        // Update the heights of parent & child
        parent->height = std::max(height(parent->left), height(parent->right)) + 1;
        child->height = std::max(height(child->left), height(child->right)) + 1;

        // Repoint the passed-by-reference pointer to the new parent
        parent = child; 
        // Update the parent of the new parent
        parent->parent = parent->left->parent;
        // Update parent pointer of the children of the new parent
        updateParentPointer(parent);
    }
    void doubleWithRightChild(MapNode<Key, Value>*& nodePtr){
        rotateWithLeftChild(nodePtr->right);
        rotateWithRightChild(nodePtr);
    }

    MapNode<Key, Value>* findMin(MapNode<Key, Value>* nodePtr) const{
        if(nodePtr == nullptr) return nullptr;
        if(nodePtr->left == nullptr) return nodePtr; // Reached a leaf, return its pointer
        else return findMin(nodePtr->left); // Keep moving down the tree
    }

    MapNode<Key, Value>* findMax(MapNode<Key, Value>* nodePtr) const{
        if(nodePtr == nullptr) return nullptr;
        if(nodePtr->right == nullptr) return nodePtr; // Reached a leaf, return its pointer
        else return findMax(nodePtr->right); // Keep moving down the tree
    }

    void clear(MapNode<Key, Value>* nodePtr){
        if(nodePtr == nullptr) return; // Base case
        
        clear(nodePtr->right); // Clear nodes on the right
        clear(nodePtr->left);  // Clear nodes on the left
        delete nodePtr; // Delete the current node
    }

    void erase(const Key& item,MapNode<Key, Value>*& nodePtr){
        if(nodePtr == nullptr) return; // Item not found, return

        if(item < nodePtr->data.first) // Move left
            erase(item, nodePtr->left);

        else if (item > nodePtr->data.first) // Move right
            erase (item, nodePtr->right);

        else if (nodePtr->left != nullptr && nodePtr->right != nullptr){ 
            // Wanted node has two children
            // Replace the wanted node with the Minumum node on its right
            nodePtr->data = findMin(nodePtr->right)->data;
            // Erase the reaplced node
            erase(nodePtr->data.first, nodePtr->right);
        }

        else{ // Single child or no children
            // Hold the wanted node with a pointer
            MapNode<Key, Value>* oldNode = nodePtr;
            // Repoint the parent's pointer to the child of the wanted node
            nodePtr = (nodePtr->right == nullptr)? nodePtr->left : nodePtr->right; 
            // Erase the wanted node
            delete oldNode;
            // Decrement the size
            --s;
        }
        // Update children parent pointers
        updateParentPointer(nodePtr);
        // Rebalance the tree
        balance(nodePtr);
    }

    void erase(Key&& item, MapNode<Key, Value>*& nodePtr){
        if(nodePtr == nullptr) return; // Item not found, return

        if(item < nodePtr->data.first) // Move left 
            erase(std::move(item), nodePtr->left);

        else if (item > nodePtr->data.first) // Move right
            erase (std::move(item), nodePtr->right);

        else if (nodePtr->left != nullptr && nodePtr->right != nullptr){ 
            // Wanted node has two children
            // Replace the wanted node with the Minumum node on its right
            nodePtr->data = findMin(nodePtr->right)->data;
            // Erase the reaplced node
            erase(nodePtr->data.first, nodePtr->right);
        }

        else{ // Single child or no children
            // Hold the wanted node with a pointer
            MapNode<Key, Value>* oldNode = nodePtr;
            // Repoint the parent's pointer to the child of the wanted node
            nodePtr = (nodePtr->right == nullptr)? nodePtr->left : nodePtr->right; 
            // Erase the wanted node
            delete oldNode;
            // Decrement the size
            --s;
        }
        // Update children parent pointers
        updateParentPointer(nodePtr);
        // Rebalance the tree
        balance(nodePtr);
    }

    bool count(const Key& item, MapNode<Key, Value>* nodePtr) const{
        if(nodePtr == nullptr) 
            return false; // Item not found, return false

        else if (item < nodePtr->data.first) // Move left
            return count(item, nodePtr->left); 

        else if (item > nodePtr->data.first) // Move right
            return count(item, nodePtr->right); 

        else return true; // Item found, return true
    }

    bool count(Key&& item, MapNode<Key, Value>* nodePtr)const {
        if(nodePtr == nullptr) return false; // Item not found, return false

        else if (item < nodePtr->data.first) // Move left
            return count(std::move(item), nodePtr->left); 

        else if (item > nodePtr->data.first) // Move right
            return count(std::move(item), nodePtr->right);

        else return true; // Item found, return true
    }
    void __clone__setParents(MapNode<Key, Value>* nodePtr){
        if(nodePtr == nullptr) return; // Base case
        __clone__setParents(nodePtr->left);
        __clone__setParents(nodePtr->right);
        updateParentPointer(nodePtr);
    }

    void print(MapNode<Key, Value>* nodePtr){
        if (nodePtr == nullptr) return; // Base case

        print(nodePtr->left); // Print left subtree
        std::cout << nodePtr->data.first << ':' << nodePtr->data.second << " "; // Print current node
        print(nodePtr->right); // Print right subtree
    }

    MapNode<Key, Value>* clone(MapNode<Key, Value>* rhsNodePtr){
        if(rhsNodePtr == nullptr) return nullptr; // Base case
        return new MapNode{rhsNodePtr->data, clone(rhsNodePtr->left), clone(rhsNodePtr->right)};
    }

    MapNode<Key, Value>* find(const Key& item, MapNode<Key, Value>* nodePtr) const{
        if(nodePtr == nullptr) return nullptr;
        if(item < nodePtr->data.first) // Move left
            return find(item, nodePtr->left);
        else if(item > nodePtr->data.first) // Move right
            return find(item, nodePtr->right);
        else // Found item, return its pointer
            return nodePtr;
    }


public:


    // Default constructor
    Map():root{nullptr}, s{}{ }

    // Copy constructor
    Map(const Map<Key, Value>& rhs):s{rhs.size()}{
        root = clone (rhs.root);
        __clone__setParents(root);
    }

    // Destructor
    ~Map(){
        clear(root);
    }

    int size() const{
        return s;
    }

    // Copy assignment operator
    void operator=(const Map<Key, Value>& rhs){
        clear(root); // Empty the tree
        root = clone(rhs.root);
        __clone__setParents(root);
        s = rhs.s;
    }

    MapIterator<Key, Value> begin() const{
        return MapIterator<Key, Value>(findMin(root));
    }
    MapIterator<Key, Value> end() const{
        return MapIterator<Key, Value>(nullptr);
    }

    void insert(const std::pair<Key, Value>& item){
        insert(item, root);
    }

    void insert(std::pair<Key, Value>&& item){
        insert(std::move(item), root);
    }

    [[nodiscard]]std::pair<Key, Value>& findMin() const{
        if(root == nullptr){
            throw std::out_of_range("Can't find minimum in an empty map");
        }
        return findMin(root)->data;
    }

    [[nodiscard]]std::pair<Key, Value>& findMax() const{
        if(root == nullptr){
            throw std::out_of_range("Can't find maximum in an empty map");
        }
        return findMax(root)->data;
    }

    std::pair<MapIterator<Key, Value>, bool> emplace(const Key& key, const Value& value){
        insert(std::make_pair(key, value), root);
        return std::make_pair(find(key), true);
    }
    

    void clear(){
        clear(root);
        root = nullptr;
        s = 0;
    }

    void erase(const Key& item){
        erase(item, root);
    }

    void erase(Key&& item){
        erase(std::move(item), root);
    }

    void erase(MapIterator<Key, Value> iterator){
        if(iterator.node == nullptr) return;
        erase(iterator->first);
    }

    [[nodiscard]]bool count(const Key& item) const{
        return count(item, root);
    }

    [[nodiscard]]bool count(Key&& item) const{
        return count(std::move(item), root);
    }

    [[nodiscard]]MapIterator<Key, Value> find(const Key& item) const{
        return MapIterator<Key, Value>{find(item,root)};
    }

    [[nodiscard]]bool empty() const{
        return root == nullptr;
    }

    void print(){
        if (root == nullptr) return; // Tree is empty
        print(root);
        std::cout << std::endl;
    }

    Value& operator[](const Key& item){
        MapNode<Key, Value>* temp = root;
        while(temp != nullptr){
            if(item < temp->data.first) // Move left
                temp = temp->left;
            else if (item > temp->data.first) // Move right
                temp = temp->right;
            else 
                // Key was found return a reference to its value
                return temp->data.second; 
        }
        // Key not found, insert it
        insert(std::make_pair(item, Value{}), root);

        // Research for the inserted node and return a reference to its value
        temp = root;
        while (temp != nullptr){
            if (item < temp->data.first) // Move left
                temp = temp->left; 
            else if (item > temp->data.first) // Move right
                temp = temp->right;
            else
                // Key was found return a frerence to its value
                return temp->data.second;
        }

        throw std::logic_error("Couldn't find the key after insertion");
    }
};



#endif

==================================================
FILE PATH: .\include\structures\stack.h
==================================================

#ifndef RMS_STACK_H
#define RMS_STACK_H

#include <stdexcept>

template <class T>
struct Node {
    T data;
    Node<T>* link;
    Node(const T& val =-99999, Node<T>* link_ptr= nullptr) : data(val), link(link_ptr) {}
};

template <class T>
class stack {
private:
    Node<T>* topPtr;
    int counter;

public:
    stack() : topPtr(nullptr), counter(0) {}

    ~stack() {
        while (!empty()) pop();
    }

    void push(const T& value) {
        topPtr = new Node<T>(value, topPtr);
        ++counter;
    }
    //copy constructor
    stack(const stack& other);
    // assignment overloading
    stack& operator=(stack other);
    friend void swap(stack<T>& first, stack<T>& second)  {
        using std::swap;
        swap(first.topPtr, second.topPtr);
        swap(first.counter, second.counter);
    }
    void pop() {
        if (empty())
            throw std::runtime_error("Stack underflow: pop() on empty stack");

        Node<T>* temp = topPtr;
        topPtr = topPtr->link;
        delete temp;
        --counter;
    }

    T& top() {
        if (empty())
            throw std::runtime_error("Stack underflow: top() on empty stack");

        return topPtr->data;
    }
    const T& top() const {
        if (empty())
            throw std::runtime_error("Stack underflow: top() on empty stack");
        return topPtr->data;
    }
    bool empty() const {
        return topPtr == nullptr;
    }

    int size() const {
        return counter;
    }
};
// --- Implementation of Copy Constructor ---
template <class T>
stack<T>::stack(const stack& other) : topPtr(nullptr), counter(0) {
    if (other.empty()) {
        return; //empty stack
    }

    Node<T>* otherCurrent = other.topPtr;
    Node<T>* lastNewNode = nullptr;

    Node<T>* newNode = new Node<T>();

    newNode->data = otherCurrent->data;
    newNode->link = nullptr;

    this->topPtr = newNode;
    lastNewNode = newNode;

    otherCurrent = otherCurrent->link;
    this->counter = 1;

    // Copy the rest of the nodes
    while (otherCurrent != nullptr) {
        Node<T>* newNode = new Node<T>();
        newNode->data = otherCurrent->data;
        newNode->link = nullptr;

        lastNewNode->link = newNode;
        lastNewNode = newNode;

        otherCurrent = otherCurrent->link;
        this->counter++;
    }

}

template <class T>
stack<T>& stack<T>::operator=(stack<T> other) {
    swap(*this, other);
    return *this;
}

#endif // RMS_STACK_H


==================================================
FILE PATH: .\include\utils\helpers.h
==================================================

//
// Created by Omar on 11/24/2025.
//

#ifndef RMS_HELPERS_H
#define RMS_HELPERS_H
#include <string>
#include <vector>
#include "models/Train.h"
#include "models/Passenger.h"
#include "models/Ticket.h"

// string validation
std::string toLowerCase(std::string word);
std::string trim(const std::string &str);
bool isValidName(const std::string& name);
// string concat
std::string combineString(const std::vector<std::string>& args, int start);
std::string combineString(const std::vector<std::string>& args, int start , int end);
bool compareString(const std::string& str1 , const std::string& str2);
// integer helpers
bool isInteger(const std::string& str);
int parseInt(const std::string& arg , const std::string& argName);

// print msg

void printCurrentDate();

#endif //RMS_HELPERS_H


==================================================
FILE PATH: .\src\CLIController.cpp
==================================================

//
// Created by Omar on 11/25/2025.
//

#include <sstream>
#include <iomanip> // required for setw()
#include <limits> // for numeric_limits
#include <cstdlib> // Required for system()

#include "CLIController.h"
#include "utils/helpers.h" // parseInt , trim
#include "RMSCommand.h"

using std::cout ;
using std::endl;
using std::string;
using std::cin;

//enums [MainCmd instead of RMSCommand::MainCmd
using MainCmd = RMSCommand::MainCmd;
using TrainCmd = RMSCommand::TrainCmd;
using PassengerCmd = RMSCommand::PassengerCmd;
using TicketCmd = RMSCommand::TicketCmd;
using SystemCmd = RMSCommand::SystemCmd;
// getters
// pointer fo functions
auto getMainCmd =  RMSCommand::getMainCmd;
auto getTrainCmd =  RMSCommand::getTrainCmd;
auto getPassengerCmd=  RMSCommand::getPassengerCmd;
auto getTicketCmd = RMSCommand::getTicketCmd;
auto getSystemCmd =RMSCommand::getSystemCmd;


vector<string> CLIController::tokenize(const string &args) { // split the sentence to args
    stringstream ss(args);
    vector<string> tokens ;
    string token;
    while(ss >> token){
        tokens.push_back(token);
    }
    return tokens;
}
void CLIController::waitUser(){
//    cin.ignore(numeric_limits<streamsize>::max(), '\n'); //  clear buffer to ingnore '\n'
    cout << "Press Enter to exit...";
    cin.get(); // wait for Enter
}
string CLIController::readLine() {
    string line;
    getline(cin ,line);
    return line;
}

void CLIController::show_help() {
    cout << "\n=================================================\n";
    cout << "        RMS - Railway Management System          \n";
    cout << "=================================================\n\n";

    cout << "Usage: <command> [arguments]\n\n";

    cout << "---------------------- Commands ----------------------\n\n";


    // ======================== TRAIN ========================
    cout << "train:\n";
    cout << "   train list                                     - Show all trains\n";
    cout << "   train add <name> <seats>                       - Add a new train\n";
    cout << "   train delete <id>                              - Remove a train\n";
    cout << "   train update <id> <seats> <name>               - Update a train\n";
    cout << "   train seats add <id> <count>                   - Increase seat count\n";
    cout << "   train availability <id>                        - Show seat status\n\n";
    cout << "   train status <id>                              - Show full train status\n\n";

    // ====================== PASSENGER ======================
    cout << "passenger:\n";
    cout << "   passenger list                                 - Show all passengers\n";
    cout << "   passenger add <name>                           - Add a passenger\n";
    cout << "   passenger delete <id>                          - Remove a passenger\n";
    cout << "   passenger update <id> <newName>                - Rename passenger\n\n";

    // ======================== TICKET ========================
    cout << "ticket:\n";
    cout << "   ticket list                                    - Show all tickets\n";
    cout << "   ticket book <trainId> <passengerId|name>       - Book a ticket\n";
    cout << "   ticket cancel <ticketId>                       - Cancel a ticket\n\n";

    // ========================= SYSTEM ========================
    cout << "system:\n";
    cout << "   help | h | ?                                   - Show help menu\n";
    cout << "   exit | quit | q                                - Exit program\n";
    cout << "   clear                                          - Clear Screen\n";

    cout << "--------------------------------------------------------\n\n";
}



void CLIController::list_trains() {
    const auto trains = facade->listTrains();
    if(trains.empty())
        cout << "No trains avialble \n";
    cout << "\n======== Trains ==========\n";
    cout << left << setw(6) << "ID"
         << left << setw(20) << "Name"
         << left << setw(20) << "Status"
         << "\n";

    for (auto &train : trains) {

        int seats = train.getSeatAllocator()->getAvailableSeatCount();

        string status = (seats == 0)
                        ? "Full"
                        : to_string(seats) + " seats available";

        cout << left << setw(6)  << train.getTrainId()
             << left << setw(20) << train.getTrainName()
             << left << setw(20) << status
             << "\n";
    }

}

void CLIController::list_passengers() {
    const auto passengers = facade->listPassengers();
    if(passengers.empty())
        cout << "No passengers avialble \n";
    cout << "\n======== Passengers ==========\n\n";
    cout << left << setw(6) << "ID"
         << left << setw(20) << "Name" << "\n";

    for (auto &passenger : passengers) {
        cout << left << setw(6) << passenger.getId()
             << left << setw(20) << passenger.getName()
             << "\n";
    }
}

void CLIController::list_tickets() {
    const auto tickets = facade->listTickets();
    if(tickets.empty())
        cout << "No tickets available \n";
    cout << "\n====================================== Tickets =======================================\n";

    cout << left
         << setw(8)  << "id"
         << setw(12) << "trainId"
         << setw(15) << "ticket_seat"
         << setw(15) << "passengerId"
         << setw(20) << "passenger_name"
         << setw(15) << "status"
         << endl;

    for (auto &ticket : tickets) {
        cout << left
             << setw(8)  << ticket.getId()
             << setw(12) << ticket.getTrainId()
             << setw(15) << ticket.getSeat()
             << setw(15) << ticket.getPassenger().getId()
             << setw(20) << ticket.getPassenger().getName()
             << setw(15) << ((ticket.getStatus() == booked) ? "Booked" : "Cancelled")
             << endl;
    }
}





CLIController::CLIController(RMSFacade *facade) :facade(facade){

}
void sayWelcome(){
    cout << "===============================================\n";
    cout << "  Welcome to the Railway Reservation System  \n";
    cout << "===============================================\n";
    cout << "Type 'help' to show the list of commands.\n";
    cout << "-----------------------------------------------\n";
    printCurrentDate();
    cout << "-----------------------------------------------\n";
    cout << "Author : Dangerous Team .\n";
    cout << "Under the supervision of Dr.Iman and Eng/Mariem Abdelrahman.\n\n";
}
void CLIController::run() {
    clear();
    sayWelcome();
//lambad function
    auto printUsage = [](MainCmd cmd) {
        switch(cmd) {
            case MainCmd::TRAIN:      cout << "Usage: train <list|add|delete|update|seats|availability>\n"; break;
            case MainCmd::PASSENGER:  cout << "Usage: passenger <list|add|delete|update>\n"; break;
            case MainCmd::TICKET:     cout << "Usage: ticket <list|book|cancel>\n"; break;
            default:                  cout << "Unknown command. Type 'help' for available commands.\n";
        }
    };

    while (true) {
        cout << "\ncmd > ";
        string line = readLine();
        vector<string> args = tokenize(line);

        if (args.empty()) {
            cout << "Please enter a command. Type 'help' for available commands.\n";
            continue;
        }

        MainCmd mainCmd = getMainCmd(args[0]);

        switch (mainCmd) {

            // ===================== TRAIN =====================
            case MainCmd::TRAIN: {
                if (args.size() < 2) { printUsage(mainCmd); break; }
                TrainCmd tCmd = getTrainCmd(args[1]);
                switch (tCmd) {
                    case TrainCmd::LIST:         list_trains(); break;
                    case TrainCmd::ADD:          add_train(args); break;
                    case TrainCmd::DELETE:       delete_train(args); break;
                    case TrainCmd::UPDATE:       update_train(args); break;
                    case TrainCmd::SEATS_ADD:    add_seats(args); break;
                    case TrainCmd::AVAILABILITY: get_train_availability(args); break;
                    case TrainCmd::STATUS: get_train_status(args); break;

                    default: cout << "Invalid train command.\n";
                }
                break;
            }

                // ===================== PASSENGER =====================
            case MainCmd::PASSENGER: {
                if (args.size() < 2) { printUsage(mainCmd); break; }
                PassengerCmd pCmd = getPassengerCmd(args[1]);
                switch (pCmd) {
                    case PassengerCmd::LIST:   list_passengers(); break;
                    case PassengerCmd::ADD:    add_passenger(args); break;
                    case PassengerCmd::DELETE: delete_passenger(args); break;
                    case PassengerCmd::UPDATE: update_passenger(args); break;
                    default: cout << "Invalid passenger command.\n";
                }
                break;
            }

                // ===================== TICKET =====================
            case MainCmd::TICKET: {
                if (args.size() < 2) { printUsage(mainCmd); break; }
                TicketCmd tkCmd = getTicketCmd(args[1]);
                switch (tkCmd) {
                    case TicketCmd::LIST:   list_tickets(); break;
                    case TicketCmd::BOOK:   book_ticket(args); break;
                    case TicketCmd::CANCEL: cancel_ticket(args); break;
                    default: cout << "Invalid ticket command.\n";
                }
                break;
            }

                // ===================== SYSTEM =====================
            case MainCmd::SYSTEM: {
                SystemCmd sCmd = getSystemCmd(args[0]);
                switch (sCmd) {
                    case SystemCmd::HELP: show_help(); break;
                    case SystemCmd::CLEAR :
                        clear();
                        sayWelcome();
                        break;
                    case SystemCmd::EXIT:
                        cout << "Goodbye!\n";
                        waitUser();
                        return;
                    default: cout << "Invalid system command.\n";
                }
                break;
            }

                // ===================== UNKNOWN =====================
            default:
                cout << "Unknown command. Type 'help' for available commands.\n";
        }
    }
}

void CLIController::add_passenger(const vector<string> &args) {
//add passenger <name>
    if(args.size() < 3) {
        cout << "Usage: passenger add  <name>\n";

        return;
    }
     string name;
    try{
        name = combineString(args,2);
        auto p = facade->addPassenger(name);
        p.print("--- Passenger Added Successfully ---\n");

    } catch(const exception& e) {
        cout << "ERROR: Could not add passenger " << name << ". " << "\n";
        cout << "Details: " << e.what() << "\n";

    }
}

void CLIController::get_train_availability(const vector<string> &args) {
//    train availability <train_id>
    if(args.size() < 3) {
        cout << "Usage: train availability <train_id>\n";
        return;
    }
    int id ;
    try{
        id = parseInt(args[2],"id");
        bool isAvailable = facade->getTrainAvailability(id);
        if(!isAvailable)
            cout << "This train is full \n";
        else
            cout << "This train is available \n";

    }catch(const exception& e){
        cout << "Error while get_train_availability : " << e.what() << endl;
        return;
    }



}
void CLIController::clear(){
    system("cls");
}

void CLIController::add_train(const vector<string> &args) {
    if(args.size() < 4) {
        cout << "Usage: train add  <name> <seats> \n";
        return;
    }
    const string& seatArgs = args[3];
    string name;
    try {
        const int &seats = parseInt(seatArgs,"seats");
        name = combineString(args,2,-1);

        auto t = facade->addTrain(name,seats);
        t.print("--- Train Added Successfully ---\n");

    }
    catch (const exception& e) {
        cout << "ERROR: Could not add train " << name << ". " << e.what() << "\n";
    }
}
void CLIController::book_ticket(const vector<string> &args) {
    if(args.size() < 4) { // book ticket <train_id> <passenger_name>
        cout << "Usage: ticket book  <train_id> <passenger_name>\n";
        return;
    }

    const string& trainIdArg = args[2];
     string passengerName ;

    try {
        int trainId = parseInt(trainIdArg, "train ID");
        passengerName = combineString(args,3);

        auto t = facade->bookTicket(trainId, passengerName);
        if(t.has_value())
            t->print("--- Ticket Booked Successfully ---\n");
        else
            cout << "train is full so the passenger added to the waiting list \n";

    } catch (const exception& e) {
        cout << "ERROR: Could not book ticket for " << passengerName << " on Train ID " << trainIdArg << ".\n";
        cout << "Details: " << e.what() << "\n";
    }
}

void CLIController::cancel_ticket(const vector<string> &args) {
    if(args.size() < 3) { // cancel ticket <ticket_id>
        cout << "Usage: ticket cancel  <ticket_id>\n";
        return;
    }

    const string& ticketIdArg = args[2];

    try {
        int ticketId = parseInt(ticketIdArg, "ticket ID");
        facade->cancelTicket(ticketId);

        cout << "--- Ticket Cancelled Successfully ---\n";
        cout << "Ticket ID: " << ticketId << " has been cancelled.\n";
        cout << "-------------------------------------\n";

    } catch (const exception& e) {
        // Error Message
        cout << "ERROR: Could not cancel ticket " << ticketIdArg << ".\n";
        cout << "Details: " << e.what() << "\n";
    }
}

void CLIController::update_train(const vector<string> &args) {

    if(args.size() < 5) {
        cout << "Usage: train update  <train_id> <name> <seats>\n";
        return;
    }

    const string& tarinIdArg = args[2];
    const string& seatArg = args[4];
    try {
        int trainId = parseInt(tarinIdArg , "train id");
        int seats = parseInt(seatArg, "seat number");
        string name = combineString(args,3,-1);
        auto t =facade->updateTrain(trainId , name , seats);

        t.print( "------ Train updated successfully ------ \n");


    } catch (const exception& e) {
        cout << "ERROR: Could not updateTrain " << tarinIdArg << ".\n";
        cout << "Details: " << e.what() << "\n";
    }
}

void CLIController::add_seats(const vector<string> &args) {
    if(args.size() < 5) {
        cout << "Usage: train seats  <trainId|trainName> <seats>\n";
        return;
    }

    const string& trainArg = args[2];
    const string& seatArg = args[3];
    try {
        int seats = parseInt(seatArg, "seat number");
        // add seats trainId
        if(isInteger(trainArg)){
            int trainId = parseInt(trainArg , "train id");
            const auto &t = facade->addSeats(trainId, seats);
            t.print( "--- Train updated successfully. --- \n");

        }else{  // add seats trainName
            string name = combineString(args,2,-1); // until last field
            const auto &t =facade->addSeats(name, seats);
            t.print( "Train updated successfully.\n");

        }



    } catch (const exception& e) {
        cout << "ERROR: Could not update Train " << trainArg << ".\n";
        cout << "Details: " << e.what() << "\n";
    }
}

void CLIController::update_passenger(const vector<string> &args) {
    if(args.size() < 5) {
        cout << "Usage: passenger update <passengerId> <newName>\n";
        return;
    }

    const string& passengerArg = args[2];
    try {
        int passengerId = parseInt(passengerArg , "passenger Id");
        string name = combineString(args,3);
        auto p = facade->updatePassenger(passengerId, name);
        p.print( "------ Passenger updated successfully ------ \n");

    } catch (const exception& e) {
        cout << "ERROR: Could not update passenger " << passengerArg<< ".\n";
        cout << "Details: " << e.what() << "\n";
    }
}

void CLIController::delete_train(const vector<string> &args) {
    if(args.size() < 3) {
        cout << "Usage: train delete  <trainId>\n";
        return;
    }
    const string& trainArg = args[2];
    try {
        int trainId = parseInt(trainArg,"train Id");
        facade->deleteTrain(trainId);
        cout << "train with id " << trainId << " deleted successfully \n";
    }catch (const exception& e) {
        cout << "ERROR: Could not delete train" << ".\n";
        cout << "Details: " << e.what() << "\n";
    }
}

void CLIController::delete_passenger(const vector<string> &args) {
    if(args.size() < 3) {
        cout << "Usage: passenger delete  <passengerId>\n";
        return;
    }
    const string& passengerArg = args[2];
    try {
        int passengerId = parseInt(passengerArg,"train Id");
        facade->deletePassenger(passengerId);
        cout << "passenger with id " << passengerId << " deleted successfully \n";
    }catch (const exception& e) {
        cout << "ERROR: Could not delete passenger" << ".\n";
        cout << "Details: " << e.what() << "\n";
    }
}

void CLIController::get_train_status(const vector<string> &args) {
    if(args.size() < 3) {
        cout << "Usage: train status  <trainId>\n";
        return;
    }
    const string& trainArg = args[2];
    try {
        int trainId = parseInt(trainArg,"train Id");
        facade->trainStatus(trainId);
    }catch (const exception& e) {
        cout << "ERROR: could not print train data with id : " << trainArg << ".\n";
        cout << "Details: " << e.what() << "\n";
    }
}




==================================================
FILE PATH: .\src\main.cpp
==================================================

#include "models/SeatAllocator.h"
#include <iostream>
#include "RMSApp.h"



int main(int argc, char **argv)
{
    RMSApp app;
    app.run();
    return 0;
}

==================================================
FILE PATH: .\src\RMSApp.cpp
==================================================

//
// Created by Omar on 12/1/2025.
//

#include "RMSApp.h"

RMSApp::RMSApp() {
    startupManager = std::make_unique<StartupManager>();

    auto facade = startupManager->buildFacade(); // build the app with startup manager

    cli = std::make_unique<CLIController>(facade);// pass facade to startup manager
}

void RMSApp::run() {
    cli->run();
}


==================================================
FILE PATH: .\src\RMSCommand.cpp
==================================================

//
// Created by Omar on 12/1/2025.
//
#include "RMSCommand.h"

RMSCommand::MainCmd RMSCommand::getMainCmd(const string &cmd){
    static const unordered_map<string, MainCmd> table = {
            {"train", MainCmd::TRAIN},
            {"passenger", MainCmd::PASSENGER},
            {"ticket", MainCmd::TICKET},
            {"help", MainCmd::SYSTEM},
            {"h", MainCmd::SYSTEM},
            {"?", MainCmd::SYSTEM},
            {"exit", MainCmd::SYSTEM},
            {"quit", MainCmd::SYSTEM},
            {"q", MainCmd::SYSTEM},
            {"clear", MainCmd::SYSTEM},


    };
    auto it = table.find(cmd);
    return (it != table.end()) ? it->second : MainCmd::UNKNOWN;
}

RMSCommand::TrainCmd RMSCommand::getTrainCmd(const string &sub) {
    static const unordered_map<string, TrainCmd> table = { // static map to initializing only once
            {"list", TrainCmd::LIST},
            {"add", TrainCmd::ADD},
            {"delete", TrainCmd::DELETE},
            {"update", TrainCmd::UPDATE},
            {"seats", TrainCmd::SEATS_ADD},
            {"availability", TrainCmd::AVAILABILITY},
            {"status" , TrainCmd::STATUS}
    };
    auto it = table.find(sub);
    return (it != table.end()) ? it->second : TrainCmd::UNKNOWN;
}
RMSCommand::PassengerCmd RMSCommand::getPassengerCmd(const string &sub)  {
    static const unordered_map<string, PassengerCmd> table = {
            {"list", PassengerCmd::LIST},
            {"add", PassengerCmd::ADD},
            {"delete", PassengerCmd::DELETE},
            {"update", PassengerCmd::UPDATE}
    };
    auto it = table.find(sub);
    return (it != table.end()) ? it->second : PassengerCmd::UNKNOWN;
}
RMSCommand::TicketCmd RMSCommand::getTicketCmd(const string &sub) {
    static const unordered_map<string, TicketCmd> table = {
            {"list", TicketCmd::LIST},
            {"book", TicketCmd::BOOK},
            {"cancel", TicketCmd::CANCEL}
    };
    auto it = table.find(sub);
    return (it != table.end()) ? it->second : TicketCmd::UNKNOWN;
}


RMSCommand::SystemCmd RMSCommand::getSystemCmd(const string &cmd) {
    if(cmd == "help" || cmd == "h" || cmd == "?") return SystemCmd::HELP;
    if(cmd == "exit" || cmd == "quit" || cmd == "q") return SystemCmd::EXIT;
    if(cmd == "clear") return SystemCmd::CLEAR;

    return SystemCmd::UNKNOWN;
}


==================================================
FILE PATH: .\src\RMSFacade.cpp
==================================================

//
// Created by Omar on 11/21/2025.
//
#include "RMSFacade.h"
#include <stdexcept> //for run time exception
#include <iostream>
#include "utils/helpers.h"

RMSFacade::RMSFacade(TrainService *ts, TicketService *tks, PassengerService *ps)
{
    this->trainService = ts;
    this->ticketService = tks;
    this->passengerService = ps;
}

// ============ Trains =============
std::vector<Train> RMSFacade::listTrains()
{
    return trainService->getAllTrains();
}

Train RMSFacade::addTrain(std::string name, int totalSeats)
{
    name = trim(name);
    if (name.empty())
    {
        throw std::invalid_argument("Train name cannot be empty");
    }

    if (totalSeats <= 0)
    {
        throw std::invalid_argument("Total seats must be greater than 0");
    }

    return trainService->createTrain(name, totalSeats);
}

std::optional<Train> RMSFacade::getTrain(int trainId)
{
    return trainService->getTrain(trainId);
}
// ============ Passengers =============

std::optional<Passenger> RMSFacade::getPassenger(int passengerId)
{
    return passengerService->getPassenger(passengerId);
}

Passenger RMSFacade::addPassenger(const std::string& name)
{
    if (!isValidName(name))
        throw std::invalid_argument("Passenger name cannot be empty");
    std::string trimmedName = trim(name);
    
    return passengerService->createPassenger(trimmedName);
}

std::vector<Ticket> RMSFacade::listTickets()
{
    return ticketService->getAllTickets();
}

std::vector<Passenger> RMSFacade::listPassengers()
{
    return passengerService->getAllPassengers();
}

// ============ Tickets =============
std::optional<Ticket> RMSFacade::bookTicket(int trainId, const std::string &passengerName)
{
    // input validation
    if (trainId <= 0)
        throw std::invalid_argument("Train ID must be greater than 0");

    if (!isValidName(passengerName))
        throw std::invalid_argument("Passenger name cannot be empty");
    std::string trimmedName = trim(passengerName);


    Passenger ps = passengerService->find_or_create_passenger(passengerName);
    return ticketService->bookTicket(trainId, ps.getId());

}

void RMSFacade::cancelTicket(int ticketId)
{
    // input validation

    if (ticketId <= 0)
        throw std::invalid_argument("Ticket ID must be greater than 0");

    ticketService->cancelTicket(ticketId);


}

bool RMSFacade::getTrainAvailability(int trainId)
{
    return  trainService->isAvailbleSeat(trainId);

}

Train RMSFacade::updateTrain(int trainId, const std::string& name, int seats) {
    // validation
    if (trainId <= 0) throw std::invalid_argument("Train ID must be > 0");
    std::string trimmedName = trim(name);
    if (!isValidName(trimmedName)) throw std::invalid_argument("Train name cannot be empty");
    if (seats < 0) throw std::invalid_argument("Seats cannot be negative");

    // current Train
    auto currentTrainOpt = trainService->getTrain(trainId);
    if (!currentTrainOpt.has_value())
        throw std::out_of_range("Train with id " + std::to_string(trainId) + " does not exist");

    Train currentTrain = currentTrainOpt.value();
    int currentSeats = currentTrain.getTotalSeats();

    // update train
    Train updatedTrain = trainService->updateTrain(trainId, trimmedName, seats);

    // process waiting
    int seatsAdded = seats - currentSeats;
    if (seatsAdded > 0) {
        auto cb =[this, trainId](int passengerId){ // access to this object& trainId + passengerId as argument
            ticketService->bookTicket(trainId, passengerId);
        };
        updatedTrain.getSeatAllocator()->processWaitingList(seatsAdded,cb);

        // Save updated train after processing waiting list
        trainService->save(updatedTrain);
    }

    return updatedTrain;
}

Train RMSFacade::addSeats(int trainId, int seats)
{
    return trainService->addSeats(trainId, seats);
}

Train RMSFacade::addSeats(const std::string &name, int seats)
{
    return trainService->addSeats(name, seats);
}

Passenger RMSFacade::updatePassenger(int passengerId, const std::string &name)
{
    auto passenger = passengerService->getPassenger(passengerId);
    if (!passenger.has_value())
        throw std::out_of_range("passenger with id : " + std::to_string(passengerId) + " does not exist ");
    // update passenger
    auto newPassenger = passengerService->updatePassenger(passengerId, name);
    // update tickets with this id
    auto tickets = ticketService->getAllTickets();
    for (auto &t : tickets)
    {
        if (compareString(t.getPassenger().getName(), passenger->getName()))
        {
            t.getPassenger().setName(name);
            ticketService->updateTicket(t);
        }
    }

    return newPassenger;
}

void RMSFacade::deleteTrain(int trainId)
{
    bool deleted = trainService->deleteTrain(trainId);
    if (!deleted)
        throw std::out_of_range("failed to delete train with id : " + std::to_string(trainId));
}

void RMSFacade::deletePassenger(int passengerId)
{
    bool deleted = passengerService->deletePassenger(passengerId);
    if (!deleted)
        throw std::out_of_range("failed to delete passenger with id : " + std::to_string(passengerId));
}

void RMSFacade::trainStatus(int trainId) {
    trainService->printStatus(trainId);
}


==================================================
FILE PATH: .\src\StartupManager.cpp
==================================================

//
// Created by Omar on 11/25/2025.
//
#include "StartupManager.h"
#include "Repo/InMemoryTrainRepository.h"
#include "Repo/InMemoryTicketRepository.h"
#include "Repo/InMemoryPassengerRepository.h"
void loadMockData(RMSFacade* facade) {
    // ---- Add Trains ----
    facade->addTrain("Alex NightLine", 30);
    facade->addTrain("Luxor Premium", 40);
    facade->addTrain("Cairo Express", 25);
    facade->addTrain("Aswan Sleeper", 20);
    facade->addTrain("Mediterranean Star", 35);

    // ---- Add Passengers ----
    facade->addPassenger("Omar");
    facade->addPassenger("Sara");
    facade->addPassenger("Mohamed");
    facade->addPassenger("Nour");
    facade->addPassenger("Ali");
    facade->addPassenger("Mona");
    facade->addPassenger("Youssef");
    facade->addPassenger("Laila");
    facade->addPassenger("Karim");
    facade->addPassenger("Dina");

    // ---- Book Tickets ----
    facade->bookTicket(1, "Omar");
    facade->bookTicket(1, "Sara");
    facade->bookTicket(1, "Ali");
    facade->bookTicket(2, "Mohamed");
    facade->bookTicket(2, "Nour");
    facade->bookTicket(3, "Mona");
    facade->bookTicket(3, "Youssef");
    facade->bookTicket(4, "Karim");
    facade->bookTicket(4, "Laila");
    facade->bookTicket(5, "Dina");
    facade->bookTicket(5, "Omar");
}

RMSFacade *StartupManager::buildFacade() {
    // all services and repos only deleted when startup manger deleted (unique)

    // build repos
    // liskov principle
    this->trainRepository= std::make_unique<InMemoryTrainRepository>();
    this->ticketRepository= std::make_unique<InMemoryTicketRepository>();
    this->passengerRepository= std::make_unique<InMemoryPassengerRepository>();

    // build services
    //dependancy injection  + giving access (only not the ownership) to the services
    this->trainService = std::make_unique<TrainService>(trainRepository.get());
    this->passengerService = std::make_unique<PassengerService>(passengerRepository.get());
    this->ticketService = std::make_unique<TicketService>(ticketRepository.get(),trainService.get(),passengerService.get());

    // build facade + dependancy injection
    // give facade access to the services
    this->facade = std::make_unique<RMSFacade>(trainService.get(),ticketService.get(),passengerService.get());
    loadMockData(facade.get());

    // allow acces to facade
    return facade.get();
}


==================================================
FILE PATH: .\src\models\Passenger.cpp
==================================================

//
// Created by Omar on 11/19/2025.
//
#include <stdexcept>
#include "models/Passenger.h"
#include "utils/helpers.h"

#include <iostream>
using std::cout;
using std::endl;




Passenger::Passenger(const int id, const std::string &name) {
    if(!isValidName(name)) throw std::invalid_argument("Invalid input name");
    if(id <0) throw std::invalid_argument("Invalid id");
    this->id = id;
    this->name = trim(name);
}

int Passenger::getId() const {
    return this->id;
}

std::string Passenger::getName() const {
    return this->name;
}

void Passenger::setId(const int &passengerId) {
    if(passengerId <=0) throw std::invalid_argument("Invalid id");
    this->id = passengerId;
}

void Passenger::setName(const std::string& name) {
    if(!isValidName(name)) throw std::invalid_argument("Invalid input name");
    this->name = trim(name);
}

void Passenger::print(const std::string &msg) const {
    cout << "--------------------------------------------------\n";
    cout << msg << endl;
    cout << "Passenger ID   : " << id << "\n";
    cout << "Name   : " << name << "\n";
    cout << "--------------------------------------------------\n";
}





==================================================
FILE PATH: .\src\models\SeatAllocator.cpp
==================================================

//
// Created by Omar on 11/20/2025.
//

#include "models/SeatAllocator.h"
#include <iostream>
#include <functional>

SeatAllocator::SeatAllocator(int totalSeats){
    if(totalSeats <= 0 )
        this->totalSeats = 10 ;
    else
        this->totalSeats = totalSeats;
//    add the seats to the set
    for(int seat = 1 ; seat <= this->totalSeats; seat++ )
        availableSeats.insert(seat);
}




int SeatAllocator::allocateSeat(int passengerId) {
    // prevent duplicate passenger allocation
    for (const auto& p : allocatedSeats) {
        if (p.second == passengerId)
            throw std::runtime_error("Passenger " + std::to_string(passengerId) + " already has a seat.\n");
    }

    // prevent duplicate waiting list insertion
    if (waitingSet.count(passengerId))
        throw std::runtime_error("Passenger " + std::to_string(passengerId) + " already in waiting list.\n");

    // No available seats , push to waiting list
    if (!hasAvailableSeats()) {
        waitingList.push(passengerId);
        waitingSet.insert(passengerId);
        std::cout << "Train full, passenger added to waiting list.\n";
        return -1;
    }

    int seatNumber;

    // prefer reusing cancelled seats first
    if (!cancelledSeats.empty()) {
        seatNumber = cancelledSeats.top();
        cancelledSeats.pop();
    } else {
        // smallest seat in the set
        seatNumber = *availableSeats.begin();
        availableSeats.erase(availableSeats.begin());
        std::cout <<"seat : " <<seatNumber;
    }

    allocatedSeats[seatNumber] = passengerId;
    return seatNumber;
}


int SeatAllocator::freeSeat(int seatNumber) {
    if (seatNumber <= 0 || seatNumber > totalSeats)
        throw std::invalid_argument("Invalid seat number.\n");

    auto it = allocatedSeats.find(seatNumber);
    if (it == allocatedSeats.end())
        throw std::out_of_range("Invalid seat number.\n");

    // delete from the hash map and add to the stack
    allocatedSeats.erase(seatNumber);
    cancelledSeats.push(seatNumber);

    // assign to waiting passenger if any
    if (!waitingList.empty()) {
        int firstPassenger = waitingList.front();
        waitingList.pop();
        waitingSet.erase(firstPassenger);
        std::queue<int> temp = waitingList;
        while (!temp.empty()) {
            std::cout << temp.front() << " ";
            temp.pop();
        }
        std::cout << "\n";
        std::cout << "Seat " << seatNumber
                  << " freed and assigned to waiting passenger "
                  << firstPassenger << "\n";

        return firstPassenger;
    }

    return 0;  // no waiting passengers
}

void SeatAllocator::addSeats(int seats) {
    if (seats <= 0)
        throw std::invalid_argument("Seats must be greater than zero.\n");

    int oldTotal = totalSeats;
    totalSeats += seats;

    for (int i = oldTotal + 1; i <= totalSeats; i++)
        availableSeats.insert(i);
}


void SeatAllocator::changeTotalSeats(int newTotalSeats) {
    if (newTotalSeats < getAllocatedSeatCount())
        throw std::out_of_range("Cannot shrink below allocated count.\n");

    if (newTotalSeats > totalSeats) {
        // expand
        for (int i = totalSeats + 1; i <= newTotalSeats; i++)
            availableSeats.insert(i);
    } else {
        // shrink
        int seatsToRemove = totalSeats - newTotalSeats;

        if ( availableSeats.size() < seatsToRemove)
            throw std::runtime_error("Cannot shrink: not enough free seats.\n");

        while (seatsToRemove-- > 0) {
            auto it = std::prev(availableSeats.end());
            availableSeats.erase(it);
        }
    }

    totalSeats = newTotalSeats;
}


void SeatAllocator::printStatus() const {
    std::cout << "\n========== Seat Allocation Status ==========\n";

    std::cout << "Total Seats          : " << totalSeats << "\n";
    std::cout << "Allocated Seat Count : " << getAllocatedSeatCount() << "\n";
    std::cout << "Available Seat Count : " << getAvailableSeatCount() << "\n\n";

    // ---- Allocated Seats ----
    std::cout << "--- Allocated Seats (Seat -> Passenger ID) ---\n";
    if (allocatedSeats.empty()) {
        std::cout << "No seats allocated.\n";
    } else {
        for (const auto &p : allocatedSeats) {
            if (p.second != -1)
                std::cout << "Seat " << p.first << " -> Passenger " << p.second << "\n";
        }
    }
    std::cout << "\n";

    // ---- Available Seats ----
    std::cout << "--- Available Seats ---\n";
    if (availableSeats.empty()) {
        std::cout << "No free seats.\n";
    } else {
        for (int s : availableSeats)
            std::cout << s << " ";
        std::cout << "\n";
    }
    std::cout << "\n";

    // ---- Cancelled Seats Stack ----
    std::cout << "--- Cancelled Seats Stack (top to bottom) ---\n";
    if (cancelledSeats.empty()) {
        std::cout << "Empty\n";
    } else {
        stack<int> temp = cancelledSeats;
        while (!temp.empty()) {
            std::cout << temp.top() << " ";
            temp.pop();
        }
        std::cout << "\n";
    }
    std::cout << "\n";

    // ---- Waiting List ----
    std::cout << "--- Waiting List (front -> back) ---\n";
    if (waitingList.empty()) {
        std::cout << "No passengers in waiting list.\n";
    } else {
        std::queue<int> temp = waitingList;
        while (!temp.empty()) {
            std::cout << temp.front() << " ";
            temp.pop();
        }
        std::cout << "\n";
    }

    std::cout << "=============================================\n\n";
}



bool SeatAllocator::hasAvailableSeats() const {
    // if the is seat in cancelled tickets or minHeap
//   return avaiable(true) if availableSeats or cancelledSeats is not  empty
    return !availableSeats.empty() || !cancelledSeats.empty();
}
int SeatAllocator::getAvailableSeatCount() const {
//    return the numbers of seats in the heap and the cancelled seats
    return availableSeats.size() + cancelledSeats.size() ;
}
std::unique_ptr<SeatAllocator> SeatAllocator::clone() const {
    return std::make_unique<SeatAllocator>(*this);
}

SeatAllocator::SeatAllocator(const SeatAllocator& other)
        : availableSeats(other.availableSeats),
          waitingList(other.waitingList),
          allocatedSeats(other.allocatedSeats),
          cancelledSeats(other.cancelledSeats),
          waitingSet(other.waitingSet),
          totalSeats(other.totalSeats) {}

SeatAllocator& SeatAllocator::operator=(const SeatAllocator& other) {
    if (this != &other) {
        availableSeats = other.availableSeats;
        waitingList = other.waitingList;
        allocatedSeats = other.allocatedSeats;
        cancelledSeats = other.cancelledSeats;
        waitingSet = other.waitingSet;
        totalSeats = other.totalSeats;
    }
    return *this;
}


int SeatAllocator::getAllocatedSeatCount() const {
    return allocatedSeats.size();
}

std::queue<int> SeatAllocator::getWaitingList() const {
    return waitingList;
}

int SeatAllocator::getTotalSeats() const {
    return totalSeats;
}

int SeatAllocator::getWaitingListSize() const {
    return waitingList.size();
}

int SeatAllocator::processWaitingList(int seatsToAdd, std::function<void(int)> bookCallback)  {
    int processed = 0;
    std::queue<int> waitingCopy = getWaitingList(); // get copy of waiting list

    while (!waitingCopy.empty() && seatsToAdd > 0) {
        int passengerId = waitingCopy.front();
        waitingCopy.pop();
        try {
            bookCallback(passengerId);
            seatsToAdd--;
            processed++;
            waitingSet.erase(passengerId);
        }
        catch (const std::exception& e) {
            std::cerr << "Failed to book ticket for waiting passenger "
                      << passengerId << ": " << e.what() << "\n";
        }
    }
    waitingList = waitingCopy;
    return processed;
}


==================================================
FILE PATH: .\src\models\Ticket.cpp
==================================================

#include <stdexcept>
#include <iostream>
#include <utility>
#include "models/Ticket.h"
using std::cout;
using std::endl;

Ticket::Ticket(const int id, const int seat, const int trainId, Passenger  p)
        :passenger(std::move(p)), status(booked){
    if(id <0 || trainId <= 0 ) throw std::invalid_argument("Invalid id");
    if(seat<=0) throw std::invalid_argument("Invalid seat");
    this->id = id;
    this->ticketSeat = seat;
    this->trainId = trainId;
}
int Ticket::getId() const
{
    return id;
}

int Ticket::getSeat() const
{
    return this->ticketSeat;
}

Status Ticket::getStatus() const
{
    return status;
}

void Ticket::setStatus(const Status& s)
{
    this->status = s;
}

int Ticket::getTrainId() const
{
    return trainId;
}

Passenger Ticket::getPassenger() const
{
    return passenger;
}

void Ticket::setId(const int newId)
{
    if(newId <=0 )throw std::invalid_argument("Invalid id");
    this->id = newId;
}

void Ticket::print(const std::string &msg) const {
    cout << "--------------------------------------------------\n";
    cout << msg << endl;
    cout << "Ticket ID: " << id << "\n";
    cout << "Seat: " << ticketSeat<< "\n";
    cout << "Train ID: " << trainId << "\n";
    cout << "Passenger: " << passenger.getName() << "\n";
    cout << "Status : " << ((status == Status::booked) ? "Booked" : "Cancelled") << "\n";
    cout << "--------------------------------------------------\n";
}



==================================================
FILE PATH: .\src\models\Train.cpp
==================================================

#include "models/Train.h"
#include "utils/helpers.h"

#include <iostream>
using std::cout;
using std::endl;

Train::Train(const int id, const std::string& name, const int totalSeats ){
    if(id < 0 ) throw std::invalid_argument("Invalid  negative id");
    if(!isValidName(name)) throw std::invalid_argument("Invalid input name");
    if(totalSeats < 0) throw std::invalid_argument("total seat must be greater than 0");
    this->id = id;
    this->name = trim(name);
    this->totalSeats = totalSeats;
    this->seatAllocator = std::make_unique<SeatAllocator>(totalSeats);

}

int Train::getTrainId() const {
    return id;
}

std::string Train::getTrainName() const {
    return name;
}

void Train::setTrainName(const std::string& name) {
    if(!isValidName(name) )
        throw std::invalid_argument("Invalid input name");
    this->name = trim(name);
}

void Train::setTrainId(int trainId) {
    if(trainId <= 0 ) throw std::runtime_error("Invalid id");
    this->id = trainId;
}

SeatAllocator* Train::getSeatAllocator() const {
    return seatAllocator.get();
}

bool Train::hasAvailableSeats() const {
    return seatAllocator->hasAvailableSeats();
}

int Train::getTotalSeats() const {
    return totalSeats;
}

std::unique_ptr<Train> Train::clone() const {

        auto newTrain = std::make_unique<Train>(id, name, totalSeats);
        if (seatAllocator) {
            newTrain->seatAllocator = seatAllocator->clone();
        }
        return newTrain;

}

Train::Train(const Train &other)
        : id(other.id), name(other.name), totalSeats(other.totalSeats),
          seatAllocator(other.seatAllocator ? other.seatAllocator->clone() : nullptr) {}

Train &Train::operator=(const Train &other) {

        if (this != &other) {
            id = other.id;
            name = other.name;
            totalSeats = other.totalSeats;
            seatAllocator = other.seatAllocator ? other.seatAllocator->clone() : nullptr;
        }
        return *this;

}

void Train::addSeats(int seats) {
    if(seats <= 0 )
        throw std::invalid_argument("Seats must be greater than zero");
    seatAllocator->addSeats(seats);

    this->totalSeats = seatAllocator->getTotalSeats();
}

void Train::setSeats(int seats) {
    if(seats <= 0)
        throw std::invalid_argument("Seats must be greater than zero");
    seatAllocator->changeTotalSeats(seats);

    totalSeats =seatAllocator->getTotalSeats();
}

void Train::trainStatus()const {
    if (!seatAllocator) {
        cout << "Train " << name << " has no seat allocator initialized.\n";
        return;
    }

    int waitingSize = seatAllocator->getWaitingListSize();
    cout << "\n=========== Train Status ===========\n";
    cout << "Train ID      : " << id << "\n";
    cout << "Train Name    : " << name << "\n";
    cout << "Total Seats   : " << totalSeats << "\n";
    cout << "Waiting List  : " << waitingSize << "\n";
    cout << "====================================\n\n";

    seatAllocator->printStatus();

}

void Train::print(const std::string& msg) const{
    cout << "--------------------------------------------------\n";
    cout << msg << endl;
    cout << "Train ID   : " << id<< "\n";
    cout << "Name   : " << name << "\n";
    cout << "Seats  : " << totalSeats << "\n";
    cout << "Availability: " << (hasAvailableSeats() ? "Available" : "full") << "\n";
    cout << "--------------------------------------------------\n";
}



==================================================
FILE PATH: .\src\Repo\InMemoryPassengerRepository.cpp
==================================================

//
// Created by Omar on 11/24/2025.
//


#include <iostream>
#include <optional>
#include "Repo/InMemoryPassengerRepository.h"

std::optional<Passenger> InMemoryPassengerRepository::getPassenger(const int &passengerId) {
    auto  result = passengers.find(passengerId);
    if(result != passengers.end()){
        return result->second;
    }
    return std::nullopt; // not found
}

std::vector<Passenger> InMemoryPassengerRepository::getAllPassengers() {
    std::vector<Passenger> results ;
    for(const auto & ps : passengers){
        results.push_back(ps.second);
    }
    return results;
}

void InMemoryPassengerRepository::save(Passenger &passenger) {
    if(passenger.getId() == 0 ){
        passenger.setId(next_id++);
    }else if(passenger.getId() >= next_id){
        next_id =passenger.getId() + 1;
    }
    const int id =passenger.getId();
    auto res = passengers.emplace(id,passenger);

    // If the key is found it's already updated
    // if(!res.second){ //update
    //     res.first->second = passenger;
    // }


}

bool InMemoryPassengerRepository::deletePassenger(const int &passengerId) {
    auto it = passengers.find(passengerId);
    if (it != passengers.end()) {
        passengers.erase(it);
        return true;
    }
    return false;
}

void InMemoryPassengerRepository::clear() {
    passengers.clear();
    next_id= 1;
    std::cout << "All passengers destroyed\n";
}



==================================================
FILE PATH: .\src\Repo\InMemoryTicketRepository.cpp
==================================================

#include "Repo/InMemoryTicketRepository.h"
#include <stdexcept>
#include <iostream>

std::optional<Ticket> InMemoryTicketRepository::getTicketByTrainAndPassenger(int trainId, int passengerId)
{
    for (const auto &p : tickets)
    {
        const Ticket &t = p.second;
        if (t.getTrainId() == trainId && t.getPassenger().getId() == passengerId)
        {
            return t;
        }
    }
    return std::nullopt;//not found
}

bool InMemoryTicketRepository::deleteTicket(int ticketId)
{
    auto it = tickets.find(ticketId);
    if (it != tickets.end())
    {
        tickets.erase(it);
        return true;
    }
    return false;
}

void InMemoryTicketRepository::save( Ticket& ticket)
{
    // later
    if (ticket.getId() == 0)
    {
        ticket.setId(next_id++);
    }
    else if (ticket.getId() >= next_id)
    {
        next_id = ticket.getId() + 1;
    }

    int id = ticket.getId();
    auto result = tickets.emplace(id, ticket);
    if (!result.second)
    {
        result.first->second = ticket; // update existing
    }

}

std::vector<Ticket> InMemoryTicketRepository::getAllTickets()
{
    std::vector<Ticket> results;
    for (const auto &p : tickets)
    {
        results.push_back(p.second);
    }
    return results;
}

std::optional<Ticket> InMemoryTicketRepository::getTicketById(int ticketId)
{
    auto it = tickets.find(ticketId);
    if (it != tickets.end())
    {
        return it->second;
    }
    throw std::runtime_error("Ticket not found");
}

void InMemoryTicketRepository::clear()
{
    tickets.clear();
    next_id= 1;
    std::cout << "All tickets destroyed\n";

}


==================================================
FILE PATH: .\src\Repo\InMemoryTrainRepository.cpp
==================================================

#include "Repo/InMemoryTrainRepository.h"
#include <iostream>
#include <stdexcept>

std::vector<Train> InMemoryTrainRepository::getAllTrains() const {
    std::vector<Train> result;
    for (const auto& train : trains) {
        result.push_back(train.second);
    }
    return result;
}

void InMemoryTrainRepository::save(Train & newTrain) {
    // assign id if needed
    if (newTrain.getTrainId() == 0) {
        newTrain.setTrainId(next_id++);
    }else if(newTrain.getTrainId() >= next_id){
        next_id = newTrain.getTrainId() + 1;
    }

    int trainId = newTrain.getTrainId();

    auto result = trains.emplace(trainId, newTrain);

    // If trainId already existed, update it
    if (!result.second) {
        result.first->second = newTrain;
    }

}

bool InMemoryTrainRepository::deleteTrain(int trainId) {
    auto it = trains.find(trainId);
    if (it != trains.end()) {
        trains.erase(it);
        return true;
    }
    return false;
}

std::optional<Train>   InMemoryTrainRepository::getTrainById(const int& trainId) const {
    auto it = trains.find(trainId);
    if (it != trains.end()) {
        return it->second;
    }
    throw std::runtime_error("Train not found");
}

void InMemoryTrainRepository::clear() {
    trains.clear();
    next_id= 1;
    std::cout << "All trains destroyed\n";
}


==================================================
FILE PATH: .\src\Services\PassengerService.cpp
==================================================

//
// Created by Omar on 11/24/2025.
//
#include <stdexcept>
#include "Services/PassengerService.h"
#include "utils/helpers.h"
PassengerService::PassengerService(IPassengerRepository *repo) {
    this->passengerRepository =repo;
}

std::optional<Passenger> PassengerService::getPassenger(const int &passengerId) {

    return  passengerRepository->getPassenger(passengerId);
}

std::vector<Passenger> PassengerService::getAllPassengers() {
    return passengerRepository->getAllPassengers();
}

bool PassengerService::deletePassenger(const int &passengerId) {
    return passengerRepository->deletePassenger(passengerId);
}

Passenger PassengerService::createPassenger(const std::string& name) {
    Passenger p(0,trim(name));
    passengerRepository->save(p);
    return p;
}
Passenger PassengerService::updatePassenger(const int passengerId , const std::string& name) {
    auto passenger = passengerRepository->getPassenger(passengerId);
    if(!passenger.has_value())
        throw std::runtime_error("passenger with id: "+ std::to_string(passengerId) + " does not exit \n");
    passenger->setName(name); //update name
    passengerRepository->save(passenger.value());
    return passenger.value();
}

Passenger PassengerService::find_or_create_passenger(const std::string &name) {
    const std::vector<Passenger> passengers = passengerRepository->getAllPassengers();

    for(const auto & p : passengers)
        if(toLowerCase(p.getName()) == toLowerCase(name)){
            return   passengerRepository->getPassenger(p.getId()).value();
        }
    Passenger p(0,name);
    passengerRepository->save(p);
    return p;
}



==================================================
FILE PATH: .\src\Services\TicketService.cpp
==================================================

#include "Services/TicketService.h"
#include <stdexcept> //for run time exception
#include <iostream>

TicketService::TicketService(ITicketRepository *repo, TrainService *ts, PassengerService *ps):ticketRepository(repo),trainService(ts),passengerService(ps) {

}


std::optional<Ticket> TicketService::getTicket(const int& ticketId)
{
    return ticketRepository->getTicketById(ticketId);
}

std::vector<Ticket> TicketService::getAllTickets()
{
    return ticketRepository->getAllTickets();
}

std::optional<Ticket> TicketService::getTicketByTrainAndPassenger(const int& trainId, const int& passengerId)
{

    return ticketRepository->getTicketByTrainAndPassenger(trainId, passengerId);
}

std::optional<Ticket> TicketService::bookTicket(const int& trainId, const int& passengerId)
{

    // 1) get train by id if exist
    auto train = trainService->getTrain(trainId);
    if(!train.has_value()){// not found
        throw std::runtime_error("train with id : " +  std::to_string(trainId) + "does not exit");
    }

    // 2) get passenger by id if exist
    auto  passenger = passengerService->getPassenger(passengerId);
    if(!passenger.has_value()){// not found
        throw std::runtime_error("passenger with id : " +  std::to_string(passengerId) + "does not exit");
    }

    // 3) check if passenger has already ticket for this train
    auto  existTicket = ticketRepository->getTicketByTrainAndPassenger(trainId,passengerId);
    if(existTicket.has_value()){//  found
        throw std::runtime_error("cannot allocate more than one ticket for the same passenger in the same train\n");
    }

    // 4) assign seat to passenger if avialble
    int seat_number;
    if(train->getSeatAllocator() != nullptr){ // if train have seat allocator and seats
        seat_number=train->getSeatAllocator()->allocateSeat(passengerId);
        trainService->save(train.value());
    }
    if(seat_number == -1) // added to waiting list
        return std::nullopt;
    // 5)  create ticket if available
    Ticket t(0,seat_number,trainId , passenger.value());
    ticketRepository->save(t);
    return t;
}

void TicketService::cancelTicket(const int& ticketId)
{

    // get train
    auto ticket =ticketRepository->getTicketById(ticketId);
    if(!ticket.has_value()){ //not found
        throw std::runtime_error("ticket with id : " +  std::to_string(ticketId) + " does not exit");
    }

    // return error if it is already cancelled
    if(ticket->getStatus() == cancelled){
        throw std::runtime_error("ticket with id : " +  std::to_string(ticketId) + " is already cancelled");
    }

    //find train
    auto train = trainService->getTrain(ticket->getTrainId());
    if(!train.has_value() || train->getSeatAllocator() == nullptr){
        throw std::runtime_error("train is not exist or not has seat allocator");
    }

    // pass seat to waiting list
    auto waitingPassengerId  = train->getSeatAllocator()->freeSeat(ticket->getSeat());
    if(waitingPassengerId  == -1)
        throw std::runtime_error("fail to free the seat \n");
    trainService->save(train.value());
    // book seat to another passenger from waiting list if available
    if (waitingPassengerId > 0)   // >0 means there was a waiting passenger
        try {
            auto t = bookTicket(train->getTrainId(), waitingPassengerId);
            if(t.has_value())
                t->print("======Ticket booked to passenger " + std::to_string(waitingPassengerId) + " Successfully ========== \n" );
        } catch (const std::exception &e) {
            // Log error and continue with cancellation
            std::cerr << "Failed to book ticket for waiting passenger "
                      << waitingPassengerId << ": " << e.what() << "\n";
        }


    // cancel ticket
    ticket->setStatus(cancelled);
    ticketRepository->save(ticket.value());
}

Ticket TicketService::updateTicket(Ticket &t) {
    ticketRepository->save(t);
    return t;

}



==================================================
FILE PATH: .\src\Services\TrainService.cpp
==================================================

//
// Created by Omar on 11/21/2025.
//

#include "Services/TrainService.h"
#include "utils/helpers.h"
#include <stdexcept> //for run time exception

std::optional<Train> TrainService::getTrain(const int& trainId) {
    return trainRepository->getTrainById(trainId);
}

TrainService::TrainService(ITrainRepository *repo) {
    this->trainRepository = repo;
}

TrainService::~TrainService() {
    // do not delete repo because service is not owning the  repo it just use it
}

std::vector<Train> TrainService::getAllTrains() {
    return trainRepository->getAllTrains();
}

Train TrainService::createTrain(const std::string& name,int seats) {
    Train t(0,name ,seats);
    trainRepository->save(t); // save the train  and give id by the repo
    return t;
}

bool TrainService::deleteTrain(int trainId) {
    return trainRepository->deleteTrain(trainId);
}

bool TrainService::isAvailbleSeat(int trainId) {
    auto train = trainRepository->getTrainById(trainId);
    if(!train.has_value())
        throw std::runtime_error("train with id : " +  std::to_string(trainId) + "does not exit");

    return train->hasAvailableSeats() ;
}

void TrainService::save(Train &train) {
    trainRepository->save(train);
}

Train TrainService::updateTrain(const int &trainId, const std::string &name, int seats) {
    auto train = trainRepository->getTrainById(trainId);
    if(!train.has_value())  // not exist
        throw std::runtime_error("cannot update train because train with id : " +  std::to_string(trainId) + "does not exit") ;
    // update name
    if(!name.empty())
        train->setTrainName(name);
    // update seats
    if(seats != 0)
        train->setSeats(seats);
    trainRepository->save(train.value());
    return train.value();
}

Train TrainService::addSeats(const int trainId, const int seats) {
    auto train =trainRepository->getTrainById(trainId);
    if(!train.has_value())
        throw std::runtime_error("train with id : " +  std::to_string(trainId) + "does not exit");
    train->addSeats(seats);
    trainRepository->save(train.value());
    return train.value();
}

Train TrainService::addSeats(const std::string name, const int seats) {
    if(name.empty())
        throw std::runtime_error("invalid name (empty string)");

    auto trains = trainRepository->getAllTrains();
    if(trains.empty())
        throw std::runtime_error("train with name : " + name +" does not exit");
    for(auto &train : trains){ // search train
        // if match update
        if(compareString(train.getTrainName() ,name))
            return  addSeats(train.getTrainId(),seats);
    }
    throw std::runtime_error("train with name : " + name +" does not exit");

}

void TrainService::printStatus(int trainId) {
    auto train = trainRepository->getTrainById(trainId);
    if(!train.has_value())
        throw std::runtime_error("train with id : " +  std::to_string(trainId) + "does not exit");
    train->trainStatus();
}


==================================================
FILE PATH: .\src\utils\helpers.cpp
==================================================



#include "utils/helpers.h"
#include <cctype> // for toLower
#include <stdexcept>
#include <regex>
#include <iostream>
#include <chrono>
#include <iomanip>

using std::string;
using std::cout;
using std::endl;

std::string toLowerCase(std::string word){
    for(char & ch : word){
        ch = (char)tolower(ch);
    }
    return word;
}
// Function to trim leading and trailing whitespace
std::string trim(const std::string &str) {
    if (str.empty()) return "";

    auto start = 0;
    auto end = str.length() - 1;

    // find first char from the left
    while (start < str.size() && str[start] == ' ') {
        start++;
    }

    // all string is space
    if (start == str.size()) return "";

    // find first char from the right
    while (end > start && str[end] == ' ') {
        end--;
    }

    // return actual string
    return str.substr(start, end - start + 1);
}

int parseInt(const std::string& arg , const std::string& argName){
    try{
        std::size_t pos; // have the index of non int char
       int res = stoi(arg,&pos);
       if(pos == 0 || pos != arg.size()) // to pass 12a and abc
           throw std::invalid_argument("");

       return res;

    }catch (std::invalid_argument& e) {
        throw std::invalid_argument( argName +" must be a number");
    }
    catch ( std::out_of_range& e) {
        throw std::out_of_range( argName +" value is too large");
    }
}

bool isValidName(const std::string& name) {
    static const std::regex pattern("^[A-Za-z0-9]+([' -][A-Za-z0-9]+)*$"); // a-z - '
    return std::regex_match(name, pattern);
}

std::string combineString(const std::vector<std::string>& args, int start) {
   return combineString(args , start ,args.size()); // not including the end
}

std::string combineString(const std::vector<std::string>& args, int start, int end) {
    if (start < 0 || start >= args.size())
        throw std::runtime_error("Start index out of range");

    if (end == -1)
        end = args.size() - 1;

    if (end < start || end > args.size())
        throw std::runtime_error("Invalid end index");

    std::string text;
    for (int i = start; i < end; i++) {  // inclusive
        if (!isValidName(args[i]) || isInteger(args[i]))
            throw std::runtime_error("invalid name");
        text += args[i] + " ";
    }

    if (!text.empty())
        text.pop_back(); // remove last space

    return text;
}
bool compareString(const std::string& str1 , const std::string& str2){
    return toLowerCase(trim(str1)) ==toLowerCase(trim(str2));
}
bool isInteger(const std::string& str) {
    try{
        std::size_t pos; // have the index of non int char

        stoi(trim(str),&pos);
        if(pos == 0 || pos != trim(str).size()) // to pass 12a and abc
            throw std::invalid_argument("");

        return true;

    }catch (std::invalid_argument& e) {
        return false;
    }
    catch ( std::out_of_range& e) {
        throw std::out_of_range( str +" value is too large");
    }
}


void printCurrentDate(){
    auto now = std::chrono::system_clock::now();
    auto time = std::chrono::system_clock::to_time_t(now);

    std::cout << "Current Date & Time: "
              << std::put_time(std::localtime(&time), "%Y-%m-%d %H:%M:%S")
              << "\n";
}


==================================================
FILE PATH: .\tests\test_helpers.cpp
==================================================

#include <gtest/gtest.h>
#include "utils/helpers.h"
#include <regex>

TEST(HelpersTest, TrimFunction) {
    EXPECT_EQ("hello", trim("hello"));
    EXPECT_EQ("hello", trim("  hello"));
    EXPECT_EQ("hello", trim("hello  "));
    EXPECT_EQ("hello", trim("  hello  "));
    EXPECT_EQ("", trim(""));
    EXPECT_EQ("", trim("   "));
    EXPECT_EQ("hello world", trim("  hello world  "));
}

TEST(HelpersTest, ToLowerCaseFunction) {
    EXPECT_EQ("hello", toLowerCase("HELLO"));
    EXPECT_EQ("hello", toLowerCase("Hello"));
    EXPECT_EQ("123", toLowerCase("123"));
    EXPECT_EQ("", toLowerCase(""));
    EXPECT_EQ("hello world", toLowerCase("HELLO WORLD"));
}

TEST(HelpersTest, ParseIntFunction) {
    EXPECT_EQ(123, parseInt("123", "ID"));
    EXPECT_EQ(-50, parseInt("-50", "Balance"));
    EXPECT_THROW(parseInt("12a", "ID"), std::invalid_argument);
    EXPECT_THROW(parseInt("abc", "ID"), std::invalid_argument);
    EXPECT_THROW(parseInt("", "ID"), std::invalid_argument);
    EXPECT_THROW(parseInt("   ", "ID"), std::invalid_argument);
    EXPECT_THROW(parseInt("12.5", "ID"), std::invalid_argument);
    EXPECT_THROW(parseInt("9999999999999999999", "ID"), std::out_of_range);
}

TEST(HelpersTest, IsValidNameFunction) {
    EXPECT_TRUE(isValidName("John"));
    EXPECT_TRUE(isValidName("Sarah Connor"));
    EXPECT_TRUE(isValidName("Jean-Luc"));
    EXPECT_TRUE(isValidName("O'Neil"));
//    EXPECT_FALSE(isValidName("John123"));
    EXPECT_FALSE(isValidName(" John"));
    EXPECT_FALSE(isValidName("John "));
    EXPECT_FALSE(isValidName(""));
    EXPECT_FALSE(isValidName("-John"));
    EXPECT_FALSE(isValidName("John--Doe"));
}

TEST(HelpersTest, CombineStringFunction) {
    const std::vector<std::string> args = {"cmd", "John", "Doe", "Smith"};
    const std::vector<std::string> invalidArgs = {"cmd", "John", "123"};

    EXPECT_EQ("John Doe Smith", combineString(args, 1));
    EXPECT_EQ("Doe Smith", combineString(args, 2));
    EXPECT_THROW(combineString(invalidArgs, 1), std::runtime_error);
    EXPECT_EQ("John Doe", combineString(args, 1, 3));
    EXPECT_THROW(combineString(args, 10, 12), std::runtime_error);
    EXPECT_THROW(combineString(args, 2, 1), std::runtime_error);
}

TEST(HelpersTest, CompareStringFunction) {
    EXPECT_TRUE(compareString("Hello", "hello"));
    EXPECT_TRUE(compareString("  JoHn  ", "john"));
    EXPECT_FALSE(compareString("Apple", "Banana"));
}

TEST(HelpersTest, IsIntegerFunction) {
    EXPECT_TRUE(isInteger("123"));
    EXPECT_TRUE(isInteger("-123"));
    EXPECT_FALSE(isInteger("12a"));
    EXPECT_FALSE(isInteger("abc"));
    EXPECT_TRUE(isInteger(" 123 "));
}

==================================================
FILE PATH: .\tests\test_models.cpp
==================================================

#include <gtest/gtest.h>
#include "models/Passenger.h"
#include "models/Train.h"
#include "models/SeatAllocator.h"
#include "models/Ticket.h"
#include <vector>

class IntegrationTest : public ::testing::Test {
protected:
    void SetUp() override {}
    void TearDown() override {}
};

TEST_F(IntegrationTest, CompleteBookingFlow) {
    Train train(1, "Express", 5);
    Passenger passenger(101, "John Doe");

    int seatNumber = train.getSeatAllocator()->allocateSeat(passenger.getId());
    EXPECT_GT(seatNumber, 0);

    Ticket ticket(1, seatNumber, train.getTrainId(), passenger);
    EXPECT_EQ(ticket.getSeat(), seatNumber);
    EXPECT_EQ(ticket.getTrainId(), train.getTrainId());
    EXPECT_EQ(ticket.getPassenger().getId(), passenger.getId());
    EXPECT_EQ(ticket.getStatus(), booked);
}

TEST_F(IntegrationTest, MultiplePassengersBooking) {
    Train train(1, "Express", 10);
    std::vector<Passenger> passengers;
    std::vector<Ticket> tickets;

    for (int i = 1; i <= 5; i++) {
        Passenger p(100 + i, "Passenger " + std::to_string(i));
        passengers.push_back(p);
        int seat = train.getSeatAllocator()->allocateSeat(p.getId());
        EXPECT_EQ(seat, i);
        Ticket ticket(i, seat, train.getTrainId(), p);
        tickets.push_back(ticket);
    }

    EXPECT_EQ(tickets.size(), 5);
    EXPECT_EQ(train.getSeatAllocator()->getAllocatedSeatCount(), 5);
    EXPECT_TRUE(train.hasAvailableSeats());
}

TEST_F(IntegrationTest, BookingUntilFull) {
    Train train(1, "Express", 3);

    Passenger p1(101, "John");
    Passenger p2(102, "Jane");
    Passenger p3(103, "Bob");

    int seat1 = train.getSeatAllocator()->allocateSeat(p1.getId());
    int seat2 = train.getSeatAllocator()->allocateSeat(p2.getId());
    int seat3 = train.getSeatAllocator()->allocateSeat(p3.getId());

    EXPECT_EQ(seat1, 1);
    EXPECT_EQ(seat2, 2);
    EXPECT_EQ(seat3, 3);
    EXPECT_FALSE(train.hasAvailableSeats());
}

TEST_F(IntegrationTest, BookingCancellationFlow) {
    Train train(1, "Express", 5);
    Passenger passenger(101, "John Doe");

    int seatNumber = train.getSeatAllocator()->allocateSeat(passenger.getId());
    Ticket ticket(1, seatNumber, train.getTrainId(), passenger);

    ticket.setStatus(cancelled);
    int result = train.getSeatAllocator()->freeSeat(seatNumber);

    EXPECT_EQ(ticket.getStatus(), cancelled);
    EXPECT_EQ(result, 0);
    EXPECT_TRUE(train.hasAvailableSeats());
}

TEST_F(IntegrationTest, CancellationWithReallocation) {
    Train train(1, "Express", 2);

    Passenger p1(101, "John");
    Passenger p2(102, "Jane");

    int seat1 = train.getSeatAllocator()->allocateSeat(p1.getId());
    int seat2 = train.getSeatAllocator()->allocateSeat(p2.getId());

    Ticket ticket1(1, seat1, train.getTrainId(), p1);
    Ticket ticket2(2, seat2, train.getTrainId(), p2);

    ticket1.setStatus(cancelled);
    train.getSeatAllocator()->freeSeat(seat1);

    Passenger p3(103, "Bob");
    int seat3 = train.getSeatAllocator()->allocateSeat(p3.getId());
    EXPECT_EQ(seat3, seat1);
}

TEST_F(IntegrationTest, WaitingListBasicFlow) {
    Train train(1, "Express", 2);

    Passenger p1(101, "John");
    Passenger p2(102, "Jane");
    Passenger p3(103, "Bob");

    train.getSeatAllocator()->allocateSeat(p1.getId());
    train.getSeatAllocator()->allocateSeat(p2.getId());
    int seat3 = train.getSeatAllocator()->allocateSeat(p3.getId());

    EXPECT_EQ(seat3, -1);
    EXPECT_FALSE(train.getSeatAllocator()->getWaitingList().empty());
}

TEST_F(IntegrationTest, WaitingListAutoAllocation) {
    Train train(1, "Express", 2);

    Passenger p1(101, "John");
    Passenger p2(102, "Jane");
    Passenger p3(103, "Bob");

    int seat1 = train.getSeatAllocator()->allocateSeat(p1.getId());
    int seat2 = train.getSeatAllocator()->allocateSeat(p2.getId());
    train.getSeatAllocator()->allocateSeat(p3.getId());

    int newPassenger = train.getSeatAllocator()->freeSeat(seat1);
    EXPECT_EQ(newPassenger, p3.getId());
    EXPECT_TRUE(train.getSeatAllocator()->getWaitingList().empty());
}

TEST_F(IntegrationTest, AddSeatsWithActiveBookings) {
    Train train(1, "Express", 5);

    train.getSeatAllocator()->allocateSeat(101);
    train.getSeatAllocator()->allocateSeat(102);
    train.getSeatAllocator()->allocateSeat(103);

    train.addSeats(5);

    EXPECT_EQ(train.getTotalSeats(), 10);
    EXPECT_EQ(train.getSeatAllocator()->getAllocatedSeatCount(), 3);
    EXPECT_EQ(train.getSeatAllocator()->getAvailableSeatCount(), 7);
}

TEST_F(IntegrationTest, FullOperationalDay) {
    Train train(1, "Morning Express", 5);
    std::vector<Ticket> activeTickets;

    for (int i = 1; i <= 5; i++) {
        Passenger p(100 + i, "Passenger " + std::to_string(i));
        int seat = train.getSeatAllocator()->allocateSeat(p.getId());
        activeTickets.push_back(Ticket(i, seat, train.getTrainId(), p));
    }

    EXPECT_FALSE(train.hasAvailableSeats());

    activeTickets[0].setStatus(cancelled);
    activeTickets[2].setStatus(cancelled);
    train.getSeatAllocator()->freeSeat(activeTickets[0].getSeat());
    train.getSeatAllocator()->freeSeat(activeTickets[2].getSeat());

    EXPECT_TRUE(train.hasAvailableSeats());

    Passenger p6(106, "Late Passenger 1");
    Passenger p7(107, "Late Passenger 2");
    int seat6 = train.getSeatAllocator()->allocateSeat(p6.getId());
    int seat7 = train.getSeatAllocator()->allocateSeat(p7.getId());

    EXPECT_GT(seat6, 0);
    EXPECT_GT(seat7, 0);
    EXPECT_FALSE(train.hasAvailableSeats());
}

TEST_F(IntegrationTest, SingleSeatTrainOperations) {
    Train train(1, "Mini Train", 1);
    Passenger p1(101, "John");

    int seat = train.getSeatAllocator()->allocateSeat(p1.getId());
    EXPECT_EQ(seat, 1);
    EXPECT_FALSE(train.hasAvailableSeats());

    Passenger p2(102, "Jane");
    int seat2 = train.getSeatAllocator()->allocateSeat(p2.getId());
    EXPECT_EQ(seat2, -1);

    train.getSeatAllocator()->freeSeat(1);
    EXPECT_TRUE(train.getSeatAllocator()->getWaitingList().empty());
}

==================================================
FILE PATH: .\tests\test_passenger.cpp
==================================================

#include <gtest/gtest.h>
#include "models/Passenger.h"

class PassengerTest : public ::testing::Test {
protected:
    void SetUp() override {}
    void TearDown() override {}
};

TEST_F(PassengerTest, ValidConstruction) {
    Passenger p(1, "John Doe");
    EXPECT_EQ(p.getId(), 1);
    EXPECT_EQ(p.getName(), "John Doe");
}

TEST_F(PassengerTest, InvalidIdThrowsException) {
    EXPECT_THROW(Passenger(-1, "John Doe"), std::invalid_argument);
}

TEST_F(PassengerTest, EmptyNameThrowsException) {
    EXPECT_THROW(Passenger(1, ""), std::invalid_argument);
}

TEST_F(PassengerTest, SetValidId) {
    Passenger p(1, "John Doe");
    p.setId(2);
    EXPECT_EQ(p.getId(), 2);
}

TEST_F(PassengerTest, SetInvalidIdThrowsException) {
    Passenger p(1, "John Doe");
    EXPECT_THROW(p.setId(-1), std::invalid_argument);
}

TEST_F(PassengerTest, SetValidName) {
    Passenger p(1, "John Doe");
    p.setName("Jane Smith");
    EXPECT_EQ(p.getName(), "Jane Smith");
}

TEST_F(PassengerTest, SetEmptyNameThrowsException) {
    Passenger p(1, "John Doe");
    EXPECT_THROW(p.setName(""), std::invalid_argument);
}

==================================================
FILE PATH: .\tests\test_passengerRepoMemo.cpp
==================================================

#include <gtest/gtest.h>
#include "models/Passenger.h"
#include "Repo/InMemoryPassengerRepository.h"
#include <optional>

class InMemoryPassengerRepositoryTest : public ::testing::Test {
protected:
    InMemoryPassengerRepository repo;

    void SetUp() override {
        repo.clear();
    }

    void TearDown() override {
        repo.clear();
    }
};

TEST_F(InMemoryPassengerRepositoryTest, SavePassengerWithZeroIdGeneratesNewId) {
    Passenger p(0, "Alice");
    repo.save(p);
    EXPECT_GT(p.getId(), 0);
}

TEST_F(InMemoryPassengerRepositoryTest, SaveGeneratesSequentialIds) {
    Passenger p1(0, "Alice");
    Passenger p2(0, "Bob");
    repo.save(p1);
    repo.save(p2);
    EXPECT_EQ(1, p1.getId());
    EXPECT_EQ(2, p2.getId());
}

TEST_F(InMemoryPassengerRepositoryTest, SavePassengerWithExistingIdPreservesId) {
    Passenger p(42, "Charlie");
    repo.save(p);
    EXPECT_EQ(42, p.getId());
}

TEST_F(InMemoryPassengerRepositoryTest, SaveUpdatesExistingPassenger) {
    Passenger p(0, "David");
    repo.save(p);
    int originalId = p.getId();
    Passenger updated(originalId, "David Updated");
    repo.save(updated);
    auto retrieved = repo.getPassenger(originalId);
    ASSERT_TRUE(retrieved.has_value());
    EXPECT_EQ(originalId, retrieved->getId());
    EXPECT_EQ("David Updated", retrieved->getName());
}

TEST_F(InMemoryPassengerRepositoryTest, SaveMultipleTimesWithSameId) {
    Passenger p1(5, "Eve");
    repo.save(p1);
    Passenger p2(5, "Eve Updated");
    repo.save(p2);
    auto retrieved = repo.getPassenger(5);
    ASSERT_TRUE(retrieved.has_value());
    EXPECT_EQ("Eve Updated", retrieved->getName());
    EXPECT_EQ(1, repo.getAllPassengers().size());
}

TEST_F(InMemoryPassengerRepositoryTest, GetPassengerReturnsCorrectPassenger) {
    Passenger p(0, "Frank");
    repo.save(p);
    auto retrieved = repo.getPassenger(p.getId());
    ASSERT_TRUE(retrieved.has_value());
    EXPECT_EQ(p.getId(), retrieved->getId());
    EXPECT_EQ("Frank", retrieved->getName());
}

TEST_F(InMemoryPassengerRepositoryTest, GetPassengerReturnsNulloptWhenNotFound) {
    auto result = repo.getPassenger(999);
    EXPECT_FALSE(result.has_value());
}

TEST_F(InMemoryPassengerRepositoryTest, GetAllPassengersReturnsEmptyWhenEmpty) {
    std::vector<Passenger> passengers = repo.getAllPassengers();
    EXPECT_TRUE(passengers.empty());
}

TEST_F(InMemoryPassengerRepositoryTest, GetAllPassengersReturnsAllSavedPassengers) {
    Passenger p1(0, "Jack");
    Passenger p2(0, "Kate");
    Passenger p3(0, "Liam");
    repo.save(p1);
    repo.save(p2);
    repo.save(p3);
    std::vector<Passenger> passengers = repo.getAllPassengers();
    EXPECT_EQ(3, passengers.size());
}

TEST_F(InMemoryPassengerRepositoryTest, DeletePassengerRemovesPassenger) {
    Passenger p(0, "Olivia");
    repo.save(p);
    int id = p.getId();
    bool deleted = repo.deletePassenger(id);
    EXPECT_TRUE(deleted);
    auto result = repo.getPassenger(id);
    EXPECT_FALSE(result.has_value());
}

TEST_F(InMemoryPassengerRepositoryTest, DeletePassengerReturnsFalseWhenNotFound) {
    bool deleted = repo.deletePassenger(999);
    EXPECT_FALSE(deleted);
}

TEST_F(InMemoryPassengerRepositoryTest, DeletePassengerReducesCount) {
    Passenger p1(0, "Paul");
    Passenger p2(0, "Quinn");
    repo.save(p1);
    repo.save(p2);
    EXPECT_EQ(2, repo.getAllPassengers().size());
    repo.deletePassenger(p1.getId());
    EXPECT_EQ(1, repo.getAllPassengers().size());
}

TEST_F(InMemoryPassengerRepositoryTest, ClearRemovesAllPassengers) {
    Passenger p1(0, "Uma");
    Passenger p2(0, "Victor");
    repo.save(p1);
    repo.save(p2);
    repo.clear();
    std::vector<Passenger> passengers = repo.getAllPassengers();
    EXPECT_TRUE(passengers.empty());
}

TEST_F(InMemoryPassengerRepositoryTest, ClearResetsNextId) {
    Passenger p1(0, "Wendy");
    repo.save(p1);
    repo.clear();
    Passenger p2(0, "Xavier");
    repo.save(p2);
    EXPECT_EQ(1, p2.getId());
}

==================================================
FILE PATH: .\tests\test_passengerService.cpp
==================================================

#include <gtest/gtest.h>
#include "models/Passenger.h"
#include "Repo/InMemoryPassengerRepository.h"
#include "Services/PassengerService.h"
#include "utils/helpers.h"
#include <optional>

class PassengerServiceTest : public ::testing::Test {
protected:
    InMemoryPassengerRepository repo;
    PassengerService* service;

    void SetUp() override {
        repo.clear();
        service = new PassengerService(&repo);
    }

    void TearDown() override {
        delete service;
        repo.clear();
    }
};

TEST_F(PassengerServiceTest, CreatePassenger_AssignsUniqueIds) {
    Passenger a = service->createPassenger("A");
    Passenger b = service->createPassenger("B");
    EXPECT_NE(a.getId(), b.getId());
}

TEST_F(PassengerServiceTest, CreatePassenger_TrimsName) {
    Passenger p = service->createPassenger("  Omar  ");
    EXPECT_EQ("Omar", p.getName());
}

TEST_F(PassengerServiceTest, CreatePassenger_ValidatesName) {
    EXPECT_THROW(service->createPassenger(""), std::invalid_argument);
}

TEST_F(PassengerServiceTest, GetPassenger_ReturnsNulloptForNegativeId) {
    EXPECT_FALSE(service->getPassenger(-1).has_value());
}

TEST_F(PassengerServiceTest, GetPassenger_AfterMultipleCreates) {
    Passenger a = service->createPassenger("A");
    Passenger b = service->createPassenger("B");
    auto retrieved = service->getPassenger(b.getId());
    ASSERT_TRUE(retrieved.has_value());
    EXPECT_EQ("B", retrieved->getName());
}

TEST_F(PassengerServiceTest, GetPassenger_ReturnsNulloptForNonExistent) {
    service->createPassenger("A");
    EXPECT_FALSE(service->getPassenger(999).has_value());
}

TEST_F(PassengerServiceTest, GetAllPassengers_OrderIsConsistent) {
    service->createPassenger("A");
    service->createPassenger("B");
    service->createPassenger("C");
    std::vector<Passenger> all = service->getAllPassengers();
    EXPECT_EQ(3, all.size());
}

TEST_F(PassengerServiceTest, DeletePassenger_DoesNotAffectOtherPassengers) {
    Passenger p1 = service->createPassenger("A");
    Passenger p2 = service->createPassenger("B");
    service->deletePassenger(p1.getId());
    EXPECT_EQ(1, service->getAllPassengers().size());
}

TEST_F(PassengerServiceTest, DeletePassenger_ReturnsFalseForNonExistent) {
    bool result = service->deletePassenger(999);
    EXPECT_FALSE(result);
}

TEST_F(PassengerServiceTest, DeletePassenger_ReturnsTrueForSuccess) {
    Passenger p = service->createPassenger("A");
    bool result = service->deletePassenger(p.getId());
    EXPECT_TRUE(result);
}

TEST_F(PassengerServiceTest, UpdatePassenger_Success) {
    Passenger p = service->createPassenger("Original");
    int id = p.getId();
    Passenger updated = service->updatePassenger(id, "Updated");
    EXPECT_EQ(updated.getId(), id);
    EXPECT_EQ(updated.getName(), "Updated");
}

TEST_F(PassengerServiceTest, UpdatePassenger_ThrowsForNonExistent) {
    EXPECT_THROW(service->updatePassenger(999, "NewName"), std::runtime_error);
}

TEST_F(PassengerServiceTest, FindOrCreate_CaseInsensitiveComparison) {
    service->createPassenger("Omar");
    Passenger found = service->find_or_create_passenger("oMaR");
    EXPECT_EQ("Omar", found.getName());
    EXPECT_EQ(1, service->getAllPassengers().size());
}

TEST_F(PassengerServiceTest, FindOrCreate_ReturnsExistingEvenIfExactNameDifferentCase) {
    Passenger p = service->createPassenger("HELLO");
    Passenger found = service->find_or_create_passenger("hello");
    EXPECT_EQ(p.getId(), found.getId());
    EXPECT_EQ("HELLO", found.getName());
}

TEST_F(PassengerServiceTest, FindOrCreate_DoesNotMatchSimilarNames) {
    service->createPassenger("John");
    Passenger p = service->find_or_create_passenger("Johnny");
    EXPECT_EQ("Johnny", p.getName());
    EXPECT_EQ(2, service->getAllPassengers().size());
}

TEST_F(PassengerServiceTest, Create100Passengers_HaveUniqueIds) {
    std::set<int> ids;
    for (int i = 0; i < 100; i++) {
        Passenger p = service->createPassenger("P" + std::to_string(i));
        ids.insert(p.getId());
    }
    EXPECT_EQ(100, ids.size());
}

==================================================
FILE PATH: .\tests\test_SeatAllocator.cpp
==================================================

#include <gtest/gtest.h>
#include "models/SeatAllocator.h"

class SeatAllocatorTest : public ::testing::Test {
protected:
    void SetUp() override {}
    void TearDown() override {}
};

TEST_F(SeatAllocatorTest, DefaultConstruction) {
    SeatAllocator allocator;
    EXPECT_EQ(allocator.getTotalSeats(), 10);
    EXPECT_EQ(allocator.getAvailableSeatCount(), 10);
    EXPECT_TRUE(allocator.hasAvailableSeats());
}

TEST_F(SeatAllocatorTest, CustomSeatCount) {
    SeatAllocator allocator(20);
    EXPECT_EQ(allocator.getTotalSeats(), 20);
    EXPECT_EQ(allocator.getAvailableSeatCount(), 20);
}

TEST_F(SeatAllocatorTest, AllocateSingleSeat) {
    SeatAllocator allocator(5);
    int seat = allocator.allocateSeat(101);
    EXPECT_EQ(seat, 1);
    EXPECT_EQ(allocator.getAvailableSeatCount(), 4);
    EXPECT_EQ(allocator.getAllocatedSeatCount(), 1);
}

TEST_F(SeatAllocatorTest, AllocateMultipleSeats) {
    SeatAllocator allocator(5);
    EXPECT_EQ(allocator.allocateSeat(101), 1);
    EXPECT_EQ(allocator.allocateSeat(102), 2);
    EXPECT_EQ(allocator.allocateSeat(103), 3);
    EXPECT_EQ(allocator.getAvailableSeatCount(), 2);
    EXPECT_EQ(allocator.getAllocatedSeatCount(), 3);
}

TEST_F(SeatAllocatorTest, DuplicatePassengerIdThrows) {
    SeatAllocator allocator(5);
    allocator.allocateSeat(101);
    EXPECT_THROW(allocator.allocateSeat(101), std::runtime_error);
}

TEST_F(SeatAllocatorTest, DuplicatePassengerInWaitingListThrows) {
    SeatAllocator allocator(2);
    allocator.allocateSeat(101);
    allocator.allocateSeat(102);
    allocator.allocateSeat(103);
    EXPECT_THROW(allocator.allocateSeat(103), std::runtime_error);
}

TEST_F(SeatAllocatorTest, FullTrainAddsToWaitingList) {
    SeatAllocator allocator(2);
    allocator.allocateSeat(101);
    allocator.allocateSeat(102);
    int result = allocator.allocateSeat(103);
    EXPECT_EQ(result, -1);
    EXPECT_FALSE(allocator.getWaitingList().empty());
    EXPECT_FALSE(allocator.hasAvailableSeats());
}

TEST_F(SeatAllocatorTest, FreeSeatValid) {
    SeatAllocator allocator(5);
    allocator.allocateSeat(101);
    EXPECT_EQ(allocator.freeSeat(1), 0);
    EXPECT_EQ(allocator.getAvailableSeatCount(), 5);
}

TEST_F(SeatAllocatorTest, FreeSeatInvalidSeatNumberZero) {
    SeatAllocator allocator(5);
    EXPECT_THROW(allocator.freeSeat(0), std::invalid_argument);
}

TEST_F(SeatAllocatorTest, FreeSeatInvalidSeatNumberNegative) {
    SeatAllocator allocator(5);
    EXPECT_THROW(allocator.freeSeat(-1), std::invalid_argument);
}

TEST_F(SeatAllocatorTest, FreeSeatInvalidSeatNumberTooLarge) {
    SeatAllocator allocator(5);
    EXPECT_THROW(allocator.freeSeat(10), std::invalid_argument);
}

TEST_F(SeatAllocatorTest, FreeSeatNotAllocated) {
    SeatAllocator allocator(5);
    EXPECT_THROW(allocator.freeSeat(1), std::out_of_range);
}

TEST_F(SeatAllocatorTest, FreeAlreadyFreedSeat) {
    SeatAllocator allocator(5);
    allocator.allocateSeat(101);
    allocator.freeSeat(1);
    EXPECT_THROW(allocator.freeSeat(1), std::out_of_range);
}

TEST_F(SeatAllocatorTest, CancelledSeatReusedBeforeNewSeats) {
    SeatAllocator allocator(5);
    allocator.allocateSeat(101);
    allocator.allocateSeat(102);
    allocator.freeSeat(1);
    int newSeat = allocator.allocateSeat(103);
    EXPECT_EQ(newSeat, 1);
}

TEST_F(SeatAllocatorTest, MultipleCancelledSeatsReusedLIFO) {
    SeatAllocator allocator(5);
    allocator.allocateSeat(101);
    allocator.allocateSeat(102);
    allocator.allocateSeat(103);
    allocator.freeSeat(1);
    allocator.freeSeat(2);
    EXPECT_EQ(allocator.allocateSeat(104), 2);
    EXPECT_EQ(allocator.allocateSeat(105), 1);
}

TEST_F(SeatAllocatorTest, AddSeats) {
    SeatAllocator allocator(5);
    allocator.addSeats(5);
    EXPECT_EQ(allocator.getTotalSeats(), 10);
    EXPECT_EQ(allocator.getAvailableSeatCount(), 10);
}

TEST_F(SeatAllocatorTest, AddSeatsWithAllocations) {
    SeatAllocator allocator(5);
    allocator.allocateSeat(101);
    allocator.allocateSeat(102);
    allocator.addSeats(3);
    EXPECT_EQ(allocator.getTotalSeats(), 8);
    EXPECT_EQ(allocator.getAvailableSeatCount(), 6);
    EXPECT_EQ(allocator.getAllocatedSeatCount(), 2);
}

TEST_F(SeatAllocatorTest, AddInvalidSeatsThrowsZero) {
    SeatAllocator allocator(5);
    EXPECT_THROW(allocator.addSeats(0), std::invalid_argument);
}

TEST_F(SeatAllocatorTest, AddInvalidSeatsThrowsNegative) {
    SeatAllocator allocator(5);
    EXPECT_THROW(allocator.addSeats(-5), std::invalid_argument);
}

TEST_F(SeatAllocatorTest, ChangeTotalSeatsToSameSize) {
    SeatAllocator allocator(10);
    allocator.changeTotalSeats(10);
    EXPECT_EQ(allocator.getTotalSeats(), 10);
}

TEST_F(SeatAllocatorTest, CopyConstructor) {
    SeatAllocator allocator(5);
    allocator.allocateSeat(101);
    allocator.allocateSeat(102);
    SeatAllocator copy(allocator);
    EXPECT_EQ(copy.getTotalSeats(), allocator.getTotalSeats());
    EXPECT_EQ(copy.getAvailableSeatCount(), allocator.getAvailableSeatCount());
    EXPECT_EQ(copy.getAllocatedSeatCount(), allocator.getAllocatedSeatCount());
}

TEST_F(SeatAllocatorTest, AssignmentOperator) {
    SeatAllocator allocator(5);
    allocator.allocateSeat(101);
    SeatAllocator other(10);
    other = allocator;
    EXPECT_EQ(other.getTotalSeats(), 5);
    EXPECT_EQ(other.getAllocatedSeatCount(), 1);
}

TEST_F(SeatAllocatorTest, CloneMethod) {
    SeatAllocator allocator(5);
    allocator.allocateSeat(101);
    auto cloned = allocator.clone();
    EXPECT_EQ(cloned->getTotalSeats(), allocator.getTotalSeats());
    EXPECT_EQ(cloned->getAvailableSeatCount(), allocator.getAvailableSeatCount());
    EXPECT_EQ(cloned->getAllocatedSeatCount(), allocator.getAllocatedSeatCount());
}

TEST_F(SeatAllocatorTest, FreeSeatReturnsWaitingPassengerId) {
    SeatAllocator allocator(1);
    allocator.allocateSeat(101);
    allocator.allocateSeat(102);
    int waitingPassengerId = allocator.freeSeat(1);
    EXPECT_EQ(waitingPassengerId, 102);
}

TEST_F(SeatAllocatorTest, ProcessWaitingList_Basic) {
    SeatAllocator allocator(2);
    allocator.allocateSeat(101);
    allocator.allocateSeat(102);
    allocator.allocateSeat(103);
    allocator.allocateSeat(104);

    std::vector<int> bookedPassengers;
    auto callback = [&bookedPassengers](int passengerId) {
        bookedPassengers.push_back(passengerId);
    };

    allocator.addSeats(2);
    int processed = allocator.processWaitingList(2, callback);

    EXPECT_EQ(processed, 2);
    EXPECT_EQ(bookedPassengers.size(), 2);
    EXPECT_EQ(bookedPassengers[0], 103);
    EXPECT_EQ(bookedPassengers[1], 104);
    EXPECT_EQ(allocator.getWaitingListSize(), 0);
}

TEST_F(SeatAllocatorTest, ProcessWaitingList_MoreSeatsThanWaiting) {
    SeatAllocator allocator(2);
    allocator.allocateSeat(101);
    allocator.allocateSeat(102);
    allocator.allocateSeat(103);

    std::vector<int> bookedPassengers;
    auto callback = [&bookedPassengers](int passengerId) {
        bookedPassengers.push_back(passengerId);
    };

    allocator.addSeats(3);
    int processed = allocator.processWaitingList(3, callback);

    EXPECT_EQ(processed, 1);
    EXPECT_EQ(bookedPassengers.size(), 1);
    EXPECT_EQ(bookedPassengers[0], 103);
    EXPECT_EQ(allocator.getWaitingListSize(), 0);
}

TEST_F(SeatAllocatorTest, ProcessWaitingList_NoWaitingList) {
    SeatAllocator allocator(5);
    allocator.allocateSeat(101);

    std::vector<int> bookedPassengers;
    auto callback = [&bookedPassengers](int passengerId) {
        bookedPassengers.push_back(passengerId);
    };

    allocator.addSeats(2);
    int processed = allocator.processWaitingList(2, callback);

    EXPECT_EQ(processed, 0);
    EXPECT_TRUE(bookedPassengers.empty());
}

TEST_F(SeatAllocatorTest, ProcessWaitingList_CallbackThrows) {
    SeatAllocator allocator(2);
    allocator.allocateSeat(101);
    allocator.allocateSeat(102);
    allocator.allocateSeat(103);

    auto callback = [](int passengerId) {
        throw std::runtime_error("Booking failed");
    };

    allocator.addSeats(1);
    int processed = allocator.processWaitingList(1, callback);

    EXPECT_EQ(processed, 0);
    EXPECT_EQ(allocator.getWaitingListSize(), 1);
}

==================================================
FILE PATH: .\tests\test_ticket.cpp
==================================================

#include <gtest/gtest.h>
#include "models/Ticket.h"
#include "models/Passenger.h"

class TicketTest : public ::testing::Test {
protected:
    void SetUp() override {}
    void TearDown() override {}
};

TEST_F(TicketTest, ValidConstruction) {
    Passenger p(101, "John Doe");
    Ticket ticket(1, 5, 10, p);
    EXPECT_EQ(ticket.getId(), 1);
    EXPECT_EQ(ticket.getSeat(), 5);
    EXPECT_EQ(ticket.getTrainId(), 10);
    EXPECT_EQ(ticket.getStatus(), booked);
    EXPECT_EQ(ticket.getPassenger().getId(), 101);
    EXPECT_EQ(ticket.getPassenger().getName(), "John Doe");
}

TEST_F(TicketTest, ConstructionWithDifferentPassenger) {
    Passenger p(202, "Jane Smith");
    Ticket ticket(2, 10, 5, p);
    EXPECT_EQ(ticket.getId(), 2);
    EXPECT_EQ(ticket.getSeat(), 10);
    EXPECT_EQ(ticket.getTrainId(), 5);
    EXPECT_EQ(ticket.getPassenger().getId(), 202);
}

TEST_F(TicketTest, DefaultStatusIsBooked) {
    Passenger p(101, "John Doe");
    Ticket ticket(1, 5, 10, p);
    EXPECT_EQ(ticket.getStatus(), booked);
}

TEST_F(TicketTest, InvalidTicketIdNegative) {
    Passenger p(101, "John Doe");
    EXPECT_THROW(Ticket(-1, 5, 10, p), std::invalid_argument);
}

TEST_F(TicketTest, InvalidTicketIdZero) {
    Passenger p(101, "John Doe");
    Ticket t(0, 5, 10, p);
    EXPECT_THROW(t.setId(0), std::invalid_argument);
}

TEST_F(TicketTest, InvalidTrainIdNegative) {
    Passenger p(101, "John Doe");
    EXPECT_THROW(Ticket(1, 5, -1, p), std::invalid_argument);
}

TEST_F(TicketTest, InvalidTrainIdZero) {
    Passenger p(101, "John Doe");
    EXPECT_THROW(Ticket(1, 5, 0, p), std::invalid_argument);
}

TEST_F(TicketTest, InvalidSeatZero) {
    Passenger p(101, "John Doe");
    EXPECT_THROW(Ticket(1, 0, 10, p), std::invalid_argument);
}

TEST_F(TicketTest, InvalidSeatNegative) {
    Passenger p(101, "John Doe");
    EXPECT_THROW(Ticket(1, -5, 10, p), std::invalid_argument);
}

TEST_F(TicketTest, SetStatusToBooked) {
    Passenger p(101, "John Doe");
    Ticket ticket(1, 5, 10, p);
    ticket.setStatus(booked);
    EXPECT_EQ(ticket.getStatus(), booked);
}

TEST_F(TicketTest, SetStatusToCancelled) {
    Passenger p(101, "John Doe");
    Ticket ticket(1, 5, 10, p);
    ticket.setStatus(cancelled);
    EXPECT_EQ(ticket.getStatus(), cancelled);
}

TEST_F(TicketTest, ToggleStatusMultipleTimes) {
    Passenger p(101, "John Doe");
    Ticket ticket(1, 5, 10, p);
    ticket.setStatus(cancelled);
    EXPECT_EQ(ticket.getStatus(), cancelled);
    ticket.setStatus(booked);
    EXPECT_EQ(ticket.getStatus(), booked);
    ticket.setStatus(cancelled);
    EXPECT_EQ(ticket.getStatus(), cancelled);
}

TEST_F(TicketTest, SetIdChangesTicketId) {
    Passenger p(101, "John Doe");
    Ticket ticket(1, 5, 10, p);
    ticket.setId(100);
    EXPECT_EQ(ticket.getId(), 100);
}

TEST_F(TicketTest, SetIdDoesNotAffectOtherFields) {
    Passenger p(101, "John Doe");
    Ticket ticket(1, 5, 10, p);
    ticket.setId(200);
    EXPECT_EQ(ticket.getId(), 200);
    EXPECT_EQ(ticket.getSeat(), 5);
    EXPECT_EQ(ticket.getTrainId(), 10);
    EXPECT_EQ(ticket.getPassenger().getId(), 101);
}

TEST_F(TicketTest, BookedToCancelledWorkflow) {
    Passenger p(101, "John Doe");
    Ticket ticket(1, 5, 10, p);
    EXPECT_EQ(ticket.getStatus(), booked);
    ticket.setStatus(cancelled);
    EXPECT_EQ(ticket.getStatus(), cancelled);
}

TEST_F(TicketTest, PassengerDataIndependent) {
    Passenger p(101, "John Doe");
    Ticket ticket(1, 5, 10, p);
    p.setName("Modified Name");
    EXPECT_EQ(ticket.getPassenger().getName(), "John Doe");
}

TEST_F(TicketTest, MultipleTicketsSamePassenger) {
    Passenger p(101, "John Doe");
    Ticket ticket1(1, 5, 10, p);
    Ticket ticket2(2, 6, 10, p);
    EXPECT_EQ(ticket1.getPassenger().getId(), 101);
    EXPECT_EQ(ticket2.getPassenger().getId(), 101);
    EXPECT_NE(ticket1.getId(), ticket2.getId());
    EXPECT_NE(ticket1.getSeat(), ticket2.getSeat());
}

TEST_F(TicketTest, LargeTicketId) {
    Passenger p(101, "John Doe");
    Ticket ticket(999999, 5, 10, p);
    EXPECT_EQ(ticket.getId(), 999999);
}

TEST_F(TicketTest, LargeSeatNumber) {
    Passenger p(101, "John Doe");
    Ticket ticket(1, 10000, 10, p);
    EXPECT_EQ(ticket.getSeat(), 10000);
}

TEST_F(TicketTest, AllMaximumValues) {
    Passenger p(999999, "John Doe");
    Ticket ticket(999999, 999999, 999999, p);
    EXPECT_EQ(ticket.getId(), 999999);
    EXPECT_EQ(ticket.getSeat(), 999999);
    EXPECT_EQ(ticket.getTrainId(), 999999);
    EXPECT_EQ(ticket.getPassenger().getId(), 999999);
}

==================================================
FILE PATH: .\tests\test_ticktRepo.cpp
==================================================

//
// Created by Omar on 11/24/2025.
//
#include <gtest/gtest.h>
#include "Repo/InMemoryTicketRepository.h"
#include "models/Ticket.h"
#include "models/Passenger.h"

class TicketRepositoryTest : public ::testing::Test {
protected:
    InMemoryTicketRepository repo;
    Passenger testPassenger;

    TicketRepositoryTest() : testPassenger(1, "John Doe") {}

    void SetUp() override {
        repo.clear();
    }

    void TearDown() override {
        repo.clear();
    }
};

TEST_F(TicketRepositoryTest, SaveTicket_GeneratesId) {
    Ticket t(0, 1, 101, testPassenger);
    repo.save(t);

    EXPECT_GT(t.getId(), 0);
    EXPECT_EQ(t.getSeat(), 1);
}

TEST_F(TicketRepositoryTest, GetTicketById_Success) {
    Ticket t(0, 5, 200, testPassenger);
    repo.save(t);

    auto retrieved = repo.getTicketById(t.getId());

    // Based on your repo code, getTicketById returns optional or throws
    // Your implementation throws runtime_error if not found, but returns optional if found
    ASSERT_TRUE(retrieved.has_value());
    EXPECT_EQ(retrieved->getId(), t.getId());
    EXPECT_EQ(retrieved->getPassenger().getName(), "John Doe");
}

TEST_F(TicketRepositoryTest, GetTicketById_ThrowsWhenNotFound) {
    // Your implementation explicitly throws runtime_error for ID lookup failures
    EXPECT_THROW(repo.getTicketById(999), std::runtime_error);
}

TEST_F(TicketRepositoryTest, GetTicketByTrainAndPassenger_Success) {
    int trainId = 100;
    Passenger p(50, "Jane");
    Ticket t(0, 10, trainId, p);
    repo.save(t);

    auto result = repo.getTicketByTrainAndPassenger(trainId, p.getId());

    ASSERT_TRUE(result.has_value());
    EXPECT_EQ(result->getId(), t.getId());
}

TEST_F(TicketRepositoryTest, GetTicketByTrainAndPassenger_ReturnsNulloptWhenNotFound) {
    // Your implementation returns std::nullopt here (doesn't throw)
    auto result = repo.getTicketByTrainAndPassenger(100, 999);
    EXPECT_FALSE(result.has_value());
}

TEST_F(TicketRepositoryTest, DeleteTicket_Success) {
    Ticket t(0, 1, 100, testPassenger);
    repo.save(t);
    int id = t.getId();

    bool deleted = repo.deleteTicket(id);
    EXPECT_TRUE(deleted);

    EXPECT_THROW(repo.getTicketById(id), std::runtime_error);
}

TEST_F(TicketRepositoryTest, GetAllTickets) {
    Ticket t1(0, 1, 100, testPassenger);
    Ticket t2(0, 2, 100, testPassenger);
    repo.save(t1);
    repo.save(t2);

    auto all = repo.getAllTickets();
    EXPECT_EQ(all.size(), 2);
}

==================================================
FILE PATH: .\tests\test_train.cpp
==================================================

// ============================================================================
// TrainTest.cpp - Train Model Tests
// ============================================================================

#include <gtest/gtest.h>
#include "models/Train.h"
#include "models/SeatAllocator.h"

class TrainTest : public ::testing::Test {
protected:
    void SetUp() override {}
    void TearDown() override {}
};

// ============================================================================
// CONSTRUCTION TESTS
// ============================================================================

TEST_F(TrainTest, ValidConstruction) {
    Train train(1, "Express Train", 20);
    EXPECT_EQ(train.getTrainId(), 1);
    EXPECT_EQ(train.getTrainName(), "Express Train");
    EXPECT_EQ(train.getTotalSeats(), 20);
    EXPECT_TRUE(train.hasAvailableSeats());
}

TEST_F(TrainTest, DefaultSeatCount) {
    Train train(1, "Local Train");
    EXPECT_EQ(train.getTotalSeats(), 10);
}

TEST_F(TrainTest, ConstructionWithMinimumSeats) {
    Train train(1, "Mini Train", 1);
    EXPECT_EQ(train.getTotalSeats(), 1);
}

TEST_F(TrainTest, ConstructionWithLargeCapacity) {
    Train train(1, "Mega Train", 1000);
    EXPECT_EQ(train.getTotalSeats(), 1000);
}

TEST_F(TrainTest, SeatAllocatorCreatedAutomatically) {
    Train train(1, "Express Train", 20);
    SeatAllocator* allocator = train.getSeatAllocator();
    EXPECT_NE(allocator, nullptr);
    EXPECT_EQ(allocator->getTotalSeats(), 20);
}

// ============================================================================
// INVALID CONSTRUCTION TESTS
// ============================================================================

TEST_F(TrainTest, InvalidTrainIdNegative) {
    EXPECT_THROW(Train(-1, "Express Train", 20), std::invalid_argument);
}

TEST_F(TrainTest, InvalidTrainIdZero) {
    Train t(100, "Express Train", 20);
    EXPECT_THROW(t.setTrainId(0), std::runtime_error);
}

TEST_F(TrainTest, EmptyNameThrows) {
    EXPECT_THROW(Train(1, "", 20), std::invalid_argument);
}

TEST_F(TrainTest, NegativeSeatsThrows) {
    EXPECT_THROW(Train(1, "Express Train", -5), std::invalid_argument);
}

TEST_F(TrainTest, AllInvalidParametersThrows) {
    EXPECT_THROW(Train(-1, "", -5), std::invalid_argument);
}

// ============================================================================
// GETTER TESTS
// ============================================================================

TEST_F(TrainTest, GetTrainIdReturnsCorrectValue) {
    Train train(42, "Express Train", 20);
    EXPECT_EQ(train.getTrainId(), 42);
}

TEST_F(TrainTest, GetTrainNameReturnsCorrectValue) {
    Train train(1, "Super Express", 20);
    EXPECT_EQ(train.getTrainName(), "Super Express");
}

TEST_F(TrainTest, GetTotalSeatsReturnsCorrectValue) {
    Train train(1, "Express Train", 50);
    EXPECT_EQ(train.getTotalSeats(), 50);
}

TEST_F(TrainTest, GetSeatAllocatorReturnsValidPointer) {
    Train train(1, "Express Train", 20);
    SeatAllocator* allocator = train.getSeatAllocator();
    EXPECT_NE(allocator, nullptr);
}

// ============================================================================
// SETTER TESTS
// ============================================================================

TEST_F(TrainTest, SetValidTrainName) {
    Train train(1, "Express Train", 20);
    train.setTrainName("Super Express");
    EXPECT_EQ(train.getTrainName(), "Super Express");
}

TEST_F(TrainTest, SetEmptyNameThrows) {
    Train train(1, "Express Train", 20);
    EXPECT_THROW(train.setTrainName(""), std::invalid_argument);
}

TEST_F(TrainTest, SetTrainNameMultipleTimes) {
    Train train(1, "Express Train", 20);
    train.setTrainName("Fast Train");
    train.setTrainName("Ultra Fast Train");
    EXPECT_EQ(train.getTrainName(), "Ultra Fast Train");
}


// ============================================================================
// ADD SEATS TESTS
// ============================================================================

TEST_F(TrainTest, AddSeatsIncreasesTotalSeats) {
    Train train(1, "Express Train", 20);
    train.addSeats(10);
    EXPECT_EQ(train.getTotalSeats(), 30);
}

TEST_F(TrainTest, AddSeatsMultipleTimes) {
    Train train(1, "Express Train", 20);
    train.addSeats(5);
    train.addSeats(5);
    train.addSeats(10);
    EXPECT_EQ(train.getTotalSeats(), 40);
}

TEST_F(TrainTest, AddSeatsUpdatesAllocator) {
    Train train(1, "Express Train", 20);
    train.addSeats(10);

    SeatAllocator* allocator = train.getSeatAllocator();
    EXPECT_EQ(allocator->getTotalSeats(), 30);
}

TEST_F(TrainTest, AddInvalidSeatsZeroThrows) {
    Train train(1, "Express Train", 20);
    EXPECT_THROW(train.addSeats(0), std::invalid_argument);
}

TEST_F(TrainTest, AddInvalidSeatsNegativeThrows) {
    Train train(1, "Express Train", 20);
    EXPECT_THROW(train.addSeats(-5), std::invalid_argument);
}

TEST_F(TrainTest, AddSeatsAfterAllocations) {
    Train train(1, "Express Train", 5);
    train.getSeatAllocator()->allocateSeat(101);
    train.getSeatAllocator()->allocateSeat(102);

    train.addSeats(5);
    EXPECT_EQ(train.getTotalSeats(), 10);
    EXPECT_TRUE(train.hasAvailableSeats());
}

// ============================================================================
// SET SEATS TESTS
// ============================================================================

TEST_F(TrainTest, SetSeatsIncreasesCapacity) {
    Train train(1, "Express Train", 20);
    train.setSeats(30);
    EXPECT_EQ(train.getTotalSeats(), 30);
}

TEST_F(TrainTest, SetSeatsDecreasesCapacity) {
    Train train(1, "Express Train", 20);
    train.setSeats(15);
    EXPECT_EQ(train.getTotalSeats(), 15);
}

TEST_F(TrainTest, SetSeatsToSameValue) {
    Train train(1, "Express Train", 20);
    train.setSeats(20);
    EXPECT_EQ(train.getTotalSeats(), 20);
}

TEST_F(TrainTest, SetInvalidSeatsZeroThrows) {
    Train train(1, "Express Train", 20);
    EXPECT_THROW(train.setSeats(0), std::invalid_argument);
}

TEST_F(TrainTest, SetInvalidSeatsNegativeThrows) {
    Train train(1, "Express Train", 20);
    EXPECT_THROW(train.setSeats(-10), std::invalid_argument);
}

TEST_F(TrainTest, SetSeatsUpdatesAllocator) {
    Train train(1, "Express Train", 20);
    train.setSeats(25);

    SeatAllocator* allocator = train.getSeatAllocator();
    EXPECT_EQ(allocator->getTotalSeats(), 25);
}

TEST_F(TrainTest, SetSeatsBelowAllocatedThrows) {
    Train train(1, "Express Train", 10);
    train.getSeatAllocator()->allocateSeat(101);
    train.getSeatAllocator()->allocateSeat(102);
    train.getSeatAllocator()->allocateSeat(103);

    EXPECT_THROW(train.setSeats(2), std::out_of_range);
}

// ============================================================================
// AVAILABLE SEATS TESTS
// ============================================================================

TEST_F(TrainTest, HasAvailableSeatsInitially) {
    Train train(1, "Express Train", 20);
    EXPECT_TRUE(train.hasAvailableSeats());
}

TEST_F(TrainTest, HasAvailableSeatsAfterPartialAllocation) {
    Train train(1, "Express Train", 5);
    train.getSeatAllocator()->allocateSeat(101);
    train.getSeatAllocator()->allocateSeat(102);
    EXPECT_TRUE(train.hasAvailableSeats());
}

TEST_F(TrainTest, NoAvailableSeatsWhenFull) {
    Train train(1, "Express Train", 2);
    train.getSeatAllocator()->allocateSeat(101);
    train.getSeatAllocator()->allocateSeat(102);
    EXPECT_FALSE(train.hasAvailableSeats());
}

TEST_F(TrainTest, HasAvailableSeatsAfterFreeing) {
    Train train(1, "Express Train", 2);
    train.getSeatAllocator()->allocateSeat(101);
    train.getSeatAllocator()->allocateSeat(102);
    train.getSeatAllocator()->freeSeat(1);
    EXPECT_TRUE(train.hasAvailableSeats());
}

// ============================================================================
// COPY CONSTRUCTOR TESTS
// ============================================================================

TEST_F(TrainTest, CopyConstructorCopiesAllFields) {
    Train train(1, "Express Train", 20);
    train.getSeatAllocator()->allocateSeat(101);
    train.getSeatAllocator()->allocateSeat(102);

    Train copy(train);
    EXPECT_EQ(copy.getTrainId(), train.getTrainId());
    EXPECT_EQ(copy.getTrainName(), train.getTrainName());
    EXPECT_EQ(copy.getTotalSeats(), train.getTotalSeats());
}

TEST_F(TrainTest, CopyConstructorCreatesIndependentCopy) {
    Train train(1, "Express Train", 20);
    train.getSeatAllocator()->allocateSeat(101);

    Train copy(train);
    copy.getSeatAllocator()->allocateSeat(102);

    EXPECT_NE(train.getSeatAllocator(), copy.getSeatAllocator());
}

TEST_F(TrainTest, CopyConstructorCopiesSeatAllocator) {
    Train train(1, "Express Train", 5);
    train.getSeatAllocator()->allocateSeat(101);
    train.getSeatAllocator()->allocateSeat(102);

    Train copy(train);
    SeatAllocator* origAllocator = train.getSeatAllocator();
    SeatAllocator* copyAllocator = copy.getSeatAllocator();

    EXPECT_EQ(origAllocator->getAllocatedSeatCount(),
              copyAllocator->getAllocatedSeatCount());
}

// ============================================================================
// ASSIGNMENT OPERATOR TESTS
// ============================================================================

TEST_F(TrainTest, AssignmentOperatorCopiesAllFields) {
    Train train(1, "Express Train", 20);
    train.getSeatAllocator()->allocateSeat(101);

    Train other(2, "Local Train", 10);
    other = train;

    EXPECT_EQ(other.getTrainId(), 1);
    EXPECT_EQ(other.getTrainName(), "Express Train");
    EXPECT_EQ(other.getTotalSeats(), 20);
}

TEST_F(TrainTest, SelfAssignmentHandled) {
    Train train(1, "Express Train", 20);
    train.getSeatAllocator()->allocateSeat(101);

    train = train;

    EXPECT_EQ(train.getTrainId(), 1);
    EXPECT_EQ(train.getTrainName(), "Express Train");
    EXPECT_EQ(train.getTotalSeats(), 20);
}

TEST_F(TrainTest, AssignmentOperatorCreatesIndependentCopy) {
    Train train(1, "Express Train", 20);
    train.getSeatAllocator()->allocateSeat(101);

    Train other(2, "Local Train", 10);
    other = train;

    other.getSeatAllocator()->allocateSeat(102);

    EXPECT_EQ(train.getSeatAllocator()->getAllocatedSeatCount(), 1);
    EXPECT_EQ(other.getSeatAllocator()->getAllocatedSeatCount(), 2);
}

// ============================================================================
// CLONE METHOD TESTS
// ============================================================================

TEST_F(TrainTest, CloneCreatesExactCopy) {
    Train train(1, "Express Train", 20);
    train.getSeatAllocator()->allocateSeat(101);
    train.getSeatAllocator()->allocateSeat(102);

    auto cloned = train.clone();
    EXPECT_EQ(cloned->getTrainId(), train.getTrainId());
    EXPECT_EQ(cloned->getTrainName(), train.getTrainName());
    EXPECT_EQ(cloned->getTotalSeats(), train.getTotalSeats());
}

TEST_F(TrainTest, CloneCreatesIndependentObject) {
    Train train(1, "Express Train", 20);
    train.getSeatAllocator()->allocateSeat(101);

    auto cloned = train.clone();
    cloned->getSeatAllocator()->allocateSeat(102);

    EXPECT_EQ(train.getSeatAllocator()->getAllocatedSeatCount(), 1);
    EXPECT_EQ(cloned->getSeatAllocator()->getAllocatedSeatCount(), 2);
}

TEST_F(TrainTest, ClonePreservesSeatAllocatorState) {
    Train train(1, "Express Train", 5);
    train.getSeatAllocator()->allocateSeat(101);
    train.getSeatAllocator()->allocateSeat(102);
    train.getSeatAllocator()->allocateSeat(103);

    auto cloned = train.clone();

    EXPECT_EQ(cloned->getSeatAllocator()->getAllocatedSeatCount(), 3);
    EXPECT_EQ(cloned->getSeatAllocator()->getAvailableSeatCount(), 2);
}

// ============================================================================
// INTEGRATION WITH SEAT ALLOCATOR TESTS
// ============================================================================

TEST_F(TrainTest, AllocateSeatThroughTrain) {
    Train train(1, "Express Train", 5);
    SeatAllocator* allocator = train.getSeatAllocator();

    int seat = allocator->allocateSeat(101);
    EXPECT_EQ(seat, 1);
    EXPECT_TRUE(train.hasAvailableSeats());
}

TEST_F(TrainTest, FillTrainCompletely) {
    Train train(1, "Express Train", 3);
    SeatAllocator* allocator = train.getSeatAllocator();

    allocator->allocateSeat(101);
    allocator->allocateSeat(102);
    allocator->allocateSeat(103);

    EXPECT_FALSE(train.hasAvailableSeats());
}

TEST_F(TrainTest, AddSeatsAfterFull) {
    Train train(1, "Express Train", 2);
    SeatAllocator* allocator = train.getSeatAllocator();

    allocator->allocateSeat(101);
    allocator->allocateSeat(102);
    EXPECT_FALSE(train.hasAvailableSeats());

    train.addSeats(3);
    EXPECT_TRUE(train.hasAvailableSeats());
}

TEST_F(TrainTest, FreeSeatRestoresAvailability) {
    Train train(1, "Express Train", 2);
    SeatAllocator* allocator = train.getSeatAllocator();

    allocator->allocateSeat(101);
    allocator->allocateSeat(102);
    allocator->freeSeat(1);

    EXPECT_TRUE(train.hasAvailableSeats());
}

// ============================================================================
// EDGE CASE TESTS
// ============================================================================

TEST_F(TrainTest, SingleSeatTrain) {
    Train train(1, "Mini Train", 1);
    train.getSeatAllocator()->allocateSeat(101);
    EXPECT_FALSE(train.hasAvailableSeats());
}

TEST_F(TrainTest, LargeCapacityTrain) {
    Train train(1, "Mega Train", 10000);
    EXPECT_EQ(train.getTotalSeats(), 10000);
    EXPECT_TRUE(train.hasAvailableSeats());
}

TEST_F(TrainTest, TrainNameWithNumbers) {
    Train train(1, "Train123", 20);
    EXPECT_EQ(train.getTrainName(), "Train123");
}

TEST_F(TrainTest, TrainNameWithSpaces) {
    Train train(1, "High Speed Rail", 20);
    EXPECT_EQ(train.getTrainName(), "High Speed Rail");
}

TEST_F(TrainTest, MaximumTrainId) {
    Train train(999999, "Express Train", 20);
    EXPECT_EQ(train.getTrainId(), 999999);
}

// ============================================================================
// STRESS TESTS
// ============================================================================

TEST_F(TrainTest, AllocateAndFreeManySeats) {
    Train train(1, "Express Train", 100);
    SeatAllocator* allocator = train.getSeatAllocator();

    // Allocate 50 seats
    for (int i = 1; i <= 50; i++) {
        allocator->allocateSeat(100 + i);
    }

    // Free first 25 seats
    for (int i = 1; i <= 25; i++) {
        allocator->freeSeat(i);
    }

    EXPECT_TRUE(train.hasAvailableSeats());
    EXPECT_EQ(allocator->getAllocatedSeatCount(), 25);
}

TEST_F(TrainTest, MultipleOperationsSequence) {
    Train train(1, "Express Train", 10);

    train.addSeats(5);
    EXPECT_EQ(train.getTotalSeats(), 15);

    train.setSeats(20);
    EXPECT_EQ(train.getTotalSeats(), 20);

    train.getSeatAllocator()->allocateSeat(101);
    EXPECT_TRUE(train.hasAvailableSeats());

    train.setTrainName("Updated Express");
    EXPECT_EQ(train.getTrainName(), "Updated Express");
}



==================================================
FILE PATH: .\tests\test_trainRepo.cpp
==================================================

#include <gtest/gtest.h>
#include "Repo/InMemoryTrainRepository.h"
#include <memory>
#include <algorithm>
#include <stdexcept>
#include <optional>

class InMemoryTrainRepositoryTest : public ::testing::Test {
protected:
    InMemoryTrainRepository repo;

    void SetUp() override {
        repo.clear();
    }

    void TearDown() override {
        repo.clear();
    }
};

// ===================== Basic Save Tests =====================

TEST_F(InMemoryTrainRepositoryTest, SaveAndGetTrainById) {
    Train t1(0, "Express", 20);
    repo.save(t1);

    EXPECT_EQ(t1.getTrainName(), "Express");
    EXPECT_EQ(t1.getTotalSeats(), 20);
    EXPECT_GT(t1.getTrainId(), 0);

    auto fetched = repo.getTrainById(t1.getTrainId());
    ASSERT_TRUE(fetched.has_value());
    EXPECT_EQ(fetched->getTrainName(), "Express");
    EXPECT_EQ(fetched->getTrainId(), t1.getTrainId());
}

TEST_F(InMemoryTrainRepositoryTest, SaveModifiesOriginalTrainId) {
    Train t(0, "Test", 10);
    EXPECT_EQ(t.getTrainId(), 0);

    repo.save(t);

    // After save, the original train should have its ID updated
    EXPECT_GT(t.getTrainId(), 0);
}

// ===================== Auto-Increment ID Tests =====================

TEST_F(InMemoryTrainRepositoryTest, AutoIncrementId) {
    Train t1(0, "Express", 20);
    repo.save(t1);

    Train t2(0, "Regional", 15);
    repo.save(t2);

    EXPECT_EQ(t1.getTrainId(), 1);
    EXPECT_EQ(t2.getTrainId(), 2);
}

TEST_F(InMemoryTrainRepositoryTest, AutoIncrementSequential) {
    std::vector<int> ids;

    for (int i = 0; i < 10; ++i) {
        Train t(0, "Train" + std::to_string(i), 10);
        repo.save(t);
        ids.push_back(t.getTrainId());
    }

    // Verify sequential IDs: 1, 2, 3, ..., 10
    for (size_t i = 0; i < ids.size(); ++i) {
        EXPECT_EQ(ids[i], i + 1);
    }
}

TEST_F(InMemoryTrainRepositoryTest, AutoIncrementAfterDelete) {
    Train t1(0, "Train1", 10);
    repo.save(t1);
    EXPECT_EQ(t1.getTrainId(), 1);

    Train t2(0, "Train2", 10);
    repo.save(t2);
    EXPECT_EQ(t2.getTrainId(), 2);

    // Delete first train
    repo.deleteTrain(t1.getTrainId());

    // Next train should get ID 3, not reuse ID 1
    Train t3(0, "Train3", 10);
    repo.save(t3);
    EXPECT_EQ(t3.getTrainId(), 3);
}

// ===================== Explicit ID Tests =====================

TEST_F(InMemoryTrainRepositoryTest, SaveWithExplicitId) {
    Train t(42, "Explicit", 10);
    repo.save(t);

    EXPECT_EQ(t.getTrainId(), 42);
}

TEST_F(InMemoryTrainRepositoryTest, ExplicitIdDoesNotChangeNextId_IfLower) {
    Train t1(0, "Auto1", 10);
    repo.save(t1); // Gets ID 1, next_id becomes 2

    Train t2(0, "Auto2", 10);
    repo.save(t2); // Gets ID 2, next_id becomes 3

    Train t3(1, "Explicit", 10);
    repo.save(t3); // Should update train with ID 1

    Train t4(0, "Auto3", 10);
    repo.save(t4);
    EXPECT_EQ(t4.getTrainId(), 3);
}

TEST_F(InMemoryTrainRepositoryTest, ExplicitIdUpdatesNextId_IfHigher) {
    Train t1(0, "Auto", 10);
    repo.save(t1);
    EXPECT_EQ(t1.getTrainId(), 1);

    Train t2(100, "High", 10);
    repo.save(t2);
    EXPECT_EQ(t2.getTrainId(), 100);

    Train t3(0, "Auto2", 10);
    repo.save(t3);
    EXPECT_EQ(t3.getTrainId(), 101);
}

TEST_F(InMemoryTrainRepositoryTest, ExplicitIdEqualToNextId) {
    Train t1(0, "Auto", 10);
    repo.save(t1); // ID 1, next_id = 2

    Train t2(2, "Explicit", 10);
    repo.save(t2);
    EXPECT_EQ(t2.getTrainId(), 2);

    Train t3(0, "Auto2", 10);
    repo.save(t3);
    EXPECT_EQ(t3.getTrainId(), 3);
}

TEST_F(InMemoryTrainRepositoryTest, MultipleExplicitHighIds) {
    Train t1(50, "Train50", 10);
    repo.save(t1);

    Train t2(100, "Train100", 10);
    repo.save(t2);

    Train t3(75, "Train75", 10);
    repo.save(t3);

    Train t4(0, "Auto", 10);
    repo.save(t4);
    EXPECT_EQ(t4.getTrainId(), 101);
}



TEST_F(InMemoryTrainRepositoryTest, VeryLargeExplicitId) {
    Train t(999999, "Large", 10);
    repo.save(t);

    EXPECT_EQ(t.getTrainId(), 999999);

    Train t2(0, "Auto", 10);
    repo.save(t2);
    EXPECT_EQ(t2.getTrainId(), 1000000);
}

// ===================== Update Tests =====================

TEST_F(InMemoryTrainRepositoryTest, UpdateExistingTrain) {
    Train t1(0, "Express", 20);
    repo.save(t1);
    int originalId = t1.getTrainId();

    Train updatedTrain(originalId, "Super Express", 30);
    repo.save(updatedTrain);

    EXPECT_EQ(updatedTrain.getTrainId(), originalId);
    EXPECT_EQ(updatedTrain.getTrainName(), "Super Express");
    EXPECT_EQ(updatedTrain.getTotalSeats(), 30);

    auto all = repo.getAllTrains();
    EXPECT_EQ(all.size(), 1);
}

TEST_F(InMemoryTrainRepositoryTest, UpdatePreservesId) {
    Train t1(0, "Original", 10);
    repo.save(t1);
    int originalId = t1.getTrainId();

    Train updated(originalId, "Updated", 20);
    repo.save(updated);

    EXPECT_EQ(updated.getTrainId(), originalId);
    EXPECT_EQ(updated.getTrainName(), "Updated");
    EXPECT_EQ(updated.getTotalSeats(), 20);
}

TEST_F(InMemoryTrainRepositoryTest, UpdateDoesNotChangeNextId) {
    Train t1(0, "Train1", 10);
    repo.save(t1); // ID 1

    Train t2(0, "Train2", 10);
    repo.save(t2); // ID 2

    Train updated(t1.getTrainId(), "Updated", 20);
    repo.save(updated);

    Train t3(0, "Train3", 10);
    repo.save(t3);
    EXPECT_EQ(t3.getTrainId(), 3);
}

TEST_F(InMemoryTrainRepositoryTest, UpdateWithSeatAllocatorState) {
    Train t(0, "Test", 5);
    auto allocator = t.getSeatAllocator();
    allocator->allocateSeat(101);
    allocator->allocateSeat(102);

    repo.save(t);
    int trainId = t.getTrainId();

    EXPECT_EQ(t.getSeatAllocator()->getAvailableSeatCount(), 3);

    auto fetchedOpt = repo.getTrainById(trainId);
    ASSERT_TRUE(fetchedOpt.has_value());
    Train fetched = fetchedOpt.value();
    fetched.getSeatAllocator()->allocateSeat(103);

    repo.save(fetched);

    auto updatedOpt = repo.getTrainById(trainId);
    ASSERT_TRUE(updatedOpt.has_value());
    EXPECT_EQ(updatedOpt->getSeatAllocator()->getAvailableSeatCount(), 2);
}

TEST_F(InMemoryTrainRepositoryTest, UpdateMultipleTimes) {
    Train t(0, "Original", 10);
    repo.save(t);
    int id = t.getTrainId();

    for (int i = 1; i <= 5; ++i) {
        Train update(id, "Version" + std::to_string(i), 10 + i);
        repo.save(update);
    }

    auto finalOpt = repo.getTrainById(id);
    ASSERT_TRUE(finalOpt.has_value());
    EXPECT_EQ(finalOpt->getTrainName(), "Version5");
    EXPECT_EQ(finalOpt->getTotalSeats(), 15);

    auto all = repo.getAllTrains();
    EXPECT_EQ(all.size(), 1);
}

// ===================== Delete Tests =====================

TEST_F(InMemoryTrainRepositoryTest, DeleteTrain) {
    Train t(0, "Express", 20);
    repo.save(t);
    int id = t.getTrainId();

    bool deleted = repo.deleteTrain(id);
    EXPECT_TRUE(deleted);

    // Repo implementation throws std::runtime_error if ID not found
    EXPECT_THROW(repo.getTrainById(id), std::runtime_error);
}

TEST_F(InMemoryTrainRepositoryTest, DeleteNonExistentTrain) {
    bool result = repo.deleteTrain(999);
    EXPECT_FALSE(result);
}

TEST_F(InMemoryTrainRepositoryTest, DeleteAllTrains) {
    Train t1(0, "Train1", 10);
    Train t2(0, "Train2", 10);
    Train t3(0, "Train3", 10);

    repo.save(t1);
    repo.save(t2);
    repo.save(t3);

    EXPECT_TRUE(repo.deleteTrain(t1.getTrainId()));
    EXPECT_TRUE(repo.deleteTrain(t2.getTrainId()));
    EXPECT_TRUE(repo.deleteTrain(t3.getTrainId()));

    auto all = repo.getAllTrains();
    EXPECT_TRUE(all.empty());
}

TEST_F(InMemoryTrainRepositoryTest, DeleteSameTrainTwice) {
    Train t(0, "Test", 10);
    repo.save(t);
    int id = t.getTrainId();

    EXPECT_TRUE(repo.deleteTrain(id));
    EXPECT_FALSE(repo.deleteTrain(id));
}

TEST_F(InMemoryTrainRepositoryTest, DeleteWithExplicitId) {
    Train t(42, "Explicit", 10);
    repo.save(t);

    EXPECT_TRUE(repo.deleteTrain(42));
    EXPECT_THROW(repo.getTrainById(42), std::runtime_error);
}

// ===================== GetTrainById Tests =====================

TEST_F(InMemoryTrainRepositoryTest, GetNonExistentTrain) {
    EXPECT_THROW(repo.getTrainById(999), std::runtime_error);
}

TEST_F(InMemoryTrainRepositoryTest, GetTrainByIdReturnsCorrectTrain) {
    Train t1(0, "Train1", 10);
    Train t2(0, "Train2", 20);
    Train t3(0, "Train3", 30);

    repo.save(t1);
    repo.save(t2);
    repo.save(t3);

    auto fetched2 = repo.getTrainById(t2.getTrainId());
    ASSERT_TRUE(fetched2.has_value());
    EXPECT_EQ(fetched2->getTrainName(), "Train2");
    EXPECT_EQ(fetched2->getTotalSeats(), 20);
}

TEST_F(InMemoryTrainRepositoryTest, GetTrainByIdReturnsCopy) {
    Train t(0, "Original", 10);
    repo.save(t);
    int id = t.getTrainId();

    auto fetchedOpt = repo.getTrainById(id);
    ASSERT_TRUE(fetchedOpt.has_value());
    Train fetched = fetchedOpt.value();
    fetched.setTrainName("Modified");

    auto original = repo.getTrainById(id);
    ASSERT_TRUE(original.has_value());
    EXPECT_EQ(original->getTrainName(), "Original");
}


TEST_F(InMemoryTrainRepositoryTest, GetTrainByZeroId) {
    EXPECT_THROW(repo.getTrainById(0), std::runtime_error);
}

// ===================== GetAllTrains Tests =====================

TEST_F(InMemoryTrainRepositoryTest, GetAllTrains) {
    Train t1(0, "Express", 20);
    Train t2(0, "Regional", 15);

    repo.save(t1);
    repo.save(t2);

    auto all = repo.getAllTrains();
    EXPECT_EQ(all.size(), 2);

    std::vector<std::string> names;
    for (const auto& train : all) {
        names.push_back(train.getTrainName());
    }

    EXPECT_NE(std::find(names.begin(), names.end(), "Express"), names.end());
    EXPECT_NE(std::find(names.begin(), names.end(), "Regional"), names.end());
}

TEST_F(InMemoryTrainRepositoryTest, GetAllTrainsEmpty) {
    auto all = repo.getAllTrains();
    EXPECT_TRUE(all.empty());
}

TEST_F(InMemoryTrainRepositoryTest, GetAllTrainsAfterDelete) {
    Train t1(0, "Train1", 10);
    Train t2(0, "Train2", 15);
    Train t3(0, "Train3", 20);

    repo.save(t1);
    repo.save(t2);
    repo.save(t3);

    repo.deleteTrain(t1.getTrainId());

    auto all = repo.getAllTrains();
    EXPECT_EQ(all.size(), 2);
}

// ===================== Clear Tests =====================

TEST_F(InMemoryTrainRepositoryTest, ClearRepository) {
    Train t1(0, "Express", 20);
    Train t2(0, "Regional", 15);

    repo.save(t1);
    repo.save(t2);

    repo.clear();
    auto all = repo.getAllTrains();
    EXPECT_TRUE(all.empty());
}

TEST_F(InMemoryTrainRepositoryTest, ClearEmptyRepository) {
    repo.clear();
    auto all = repo.getAllTrains();
    EXPECT_TRUE(all.empty());
}

TEST_F(InMemoryTrainRepositoryTest, ClearResetsNextId) {
    Train t1(0, "Train1", 10);
    repo.save(t1);
    EXPECT_EQ(t1.getTrainId(), 1);

    repo.clear();

    Train t2(0, "Train2", 15);
    repo.save(t2);
    EXPECT_EQ(t2.getTrainId(), 1);

    auto all = repo.getAllTrains();
    EXPECT_EQ(all.size(), 1);
}

// ===================== Seat Allocator Tests =====================

TEST_F(InMemoryTrainRepositoryTest, SeatAllocatorWorks) {
    Train t(0, "Express", 5);
    repo.save(t);

    EXPECT_TRUE(t.hasAvailableSeats());
    EXPECT_EQ(t.getSeatAllocator()->getAvailableSeatCount(), 5);

    auto allocator = t.getSeatAllocator();
    for (int i = 1; i <= 5; ++i) {
        int seatNumber = allocator->allocateSeat(100 + i);
        EXPECT_GT(seatNumber, 0);
    }

    EXPECT_FALSE(t.hasAvailableSeats());
    EXPECT_EQ(allocator->getAvailableSeatCount(), 0);
}

TEST_F(InMemoryTrainRepositoryTest, SeatAllocationAndFreeing) {
    Train t(0, "Test Train", 3);
    repo.save(t);
    int trainId = t.getTrainId();

    auto seatAllocator = t.getSeatAllocator();
    int seat1 = seatAllocator->allocateSeat(101);
    int seat2 = seatAllocator->allocateSeat(102);

    EXPECT_EQ(seatAllocator->getAvailableSeatCount(), 1);

    repo.save(t);

    auto fetched = repo.getTrainById(trainId);
    ASSERT_TRUE(fetched.has_value());
    EXPECT_EQ(fetched->getSeatAllocator()->getAvailableSeatCount(), 1);
}

TEST_F(InMemoryTrainRepositoryTest, PreservesSeatAllocatorState) {
    Train t(0, "State Test", 3);
    auto allocator = t.getSeatAllocator();
    allocator->allocateSeat(101);
    allocator->allocateSeat(102);

    repo.save(t);

    EXPECT_EQ(t.getSeatAllocator()->getAvailableSeatCount(), 1);

    auto fetched = repo.getTrainById(t.getTrainId());
    ASSERT_TRUE(fetched.has_value());
    EXPECT_EQ(fetched->getSeatAllocator()->getAvailableSeatCount(), 1);
}

// ===================== Edge Cases and Boundary Tests =====================

TEST_F(InMemoryTrainRepositoryTest, DuplicateTrainNames) {
    Train t1(0, "Express", 10);
    Train t2(0, "Express", 15);

    repo.save(t1);
    repo.save(t2);

    EXPECT_NE(t1.getTrainId(), t2.getTrainId());

    auto all = repo.getAllTrains();
    EXPECT_EQ(all.size(), 2);
}

TEST_F(InMemoryTrainRepositoryTest, SaveEmptyNameTrainThrows) {
    // Cannot create a train with empty name
    EXPECT_THROW(Train t(5, "", 10), std::invalid_argument);
}

TEST_F(InMemoryTrainRepositoryTest, SaveValidTrain) {
    Train t(1, "Valid Train", 10);
    repo.save(t);

    auto fetched = repo.getTrainById(t.getTrainId());
    ASSERT_TRUE(fetched.has_value());
    EXPECT_EQ(fetched->getTrainName(), "Valid Train");
}
TEST_F(InMemoryTrainRepositoryTest, NegativeExplicitIdThrows) {
    // Cannot create a train with negative ID; should throw
    EXPECT_THROW(Train t(-5, "Negative", 10), std::invalid_argument);

    // Next auto-increment train works fine
    Train t2(0, "Auto", 10);
    repo.save(t2);
    EXPECT_EQ(t2.getTrainId(), 1);

    auto fetched = repo.getTrainById(t2.getTrainId());
    ASSERT_TRUE(fetched.has_value());
    EXPECT_EQ(fetched->getTrainName(), "Auto");
}





TEST_F(InMemoryTrainRepositoryTest, MultipleOperations) {
    Train t1(0, "Train A", 10);
    Train t2(0, "Train B", 15);
    Train t3(0, "Train C", 20);

    repo.save(t1);
    repo.save(t2);
    repo.save(t3);

    auto all = repo.getAllTrains();
    EXPECT_EQ(all.size(), 3);

    bool deleted = repo.deleteTrain(t2.getTrainId());
    EXPECT_TRUE(deleted);

    all = repo.getAllTrains();
    EXPECT_EQ(all.size(), 2);

    std::vector<std::string> names;
    for (const auto& train : all) {
        names.push_back(train.getTrainName());
    }
    EXPECT_NE(std::find(names.begin(), names.end(), "Train A"), names.end());
    EXPECT_NE(std::find(names.begin(), names.end(), "Train C"), names.end());
    EXPECT_EQ(std::find(names.begin(), names.end(), "Train B"), names.end());
}

TEST_F(InMemoryTrainRepositoryTest, SaveManyTrains) {
    const int COUNT = 100;
    std::vector<int> ids;

    for (int i = 0; i < COUNT; ++i) {
        Train t(0, "Train" + std::to_string(i), i + 1);
        repo.save(t);
        ids.push_back(t.getTrainId());
    }

    auto all = repo.getAllTrains();
    EXPECT_EQ(all.size(), COUNT);

    for (int i = 0; i < COUNT; ++i) {
        EXPECT_EQ(ids[i], i + 1);
    }
}

TEST_F(InMemoryTrainRepositoryTest, MixedExplicitAndAutoIds) {
    Train t1(0, "Auto1", 10);
    repo.save(t1); // ID 1
    EXPECT_EQ(t1.getTrainId(), 1);

    Train t2(50, "Explicit50", 10);
    repo.save(t2); // ID 50

    Train t3(0, "Auto2", 10);
    repo.save(t3); // ID 51
    EXPECT_EQ(t3.getTrainId(), 51);

    Train t4(25, "Explicit25", 10);
    repo.save(t4); // ID 25

    Train t5(0, "Auto3", 10);
    repo.save(t5); // ID 52
    EXPECT_EQ(t5.getTrainId(), 52);

    auto all = repo.getAllTrains();
    EXPECT_EQ(all.size(), 5);
}
TEST_F(InMemoryTrainRepositoryTest, SaveWithZeroSeats) {
    Train t(0, "ZeroSeats", 0);
    repo.save(t);

    EXPECT_EQ(t.getTotalSeats(), 0);                     // Reflects the actual Train value
    EXPECT_EQ(t.getSeatAllocator()->getAvailableSeatCount(), 10); // SeatAllocator defaults to 10
}


TEST_F(InMemoryTrainRepositoryTest, SaveWithNegativeIdThrows) {
    // Trying to create a train with a negative ID should throw
    EXPECT_THROW({
                     Train t(-10, "Negative", 10);
                     repo.save(t);
                 }, std::invalid_argument);
}

TEST_F(InMemoryTrainRepositoryTest, GetTrainWithNegativeIdThrows) {
    // Trying to fetch a train with a negative ID should throw
    EXPECT_THROW(repo.getTrainById(-10), std::runtime_error);
}

TEST_F(InMemoryTrainRepositoryTest, SaveEmptyNameTrain) {
    // Cannot create a train with empty name; should throw
    EXPECT_THROW(Train emptyNameTrain(5, "", 10), std::invalid_argument);

    // For a valid train
    Train t(1, "Valid Train", 10);
    repo.save(t);

    auto fetched = repo.getTrainById(t.getTrainId());
    ASSERT_TRUE(fetched.has_value());
    EXPECT_EQ(fetched->getTrainName(), "Valid Train");
}

==================================================
FILE PATH: .\tests\test_trainSevice.cpp
==================================================

#include <gtest/gtest.h>
#include "Services/TrainService.h"
#include "Repo/InMemoryTrainRepository.h"

class TrainServiceTest : public ::testing::Test {
protected:
    std::unique_ptr<InMemoryTrainRepository> repo;
    std::unique_ptr<TrainService> service;

    void SetUp() override {
        repo = std::make_unique<InMemoryTrainRepository>();
        service = std::make_unique<TrainService>(repo.get());
    }
};

TEST_F(TrainServiceTest, CreateTrain_Success) {
    Train train = service->createTrain("Test Train", 30);
    EXPECT_GT(train.getTrainId(), 0);
    EXPECT_EQ(train.getTrainName(), "Test Train");
    EXPECT_EQ(train.getTotalSeats(), 30);
}

TEST_F(TrainServiceTest, GetTrain_Exists) {
    Train created = service->createTrain("Test Train", 30);
    auto retrieved = service->getTrain(created.getTrainId());
    ASSERT_TRUE(retrieved.has_value());
    EXPECT_EQ(retrieved->getTrainName(), "Test Train");
}

TEST_F(TrainServiceTest, GetTrain_NotExists) {
    EXPECT_THROW(service->getTrain(999), std::runtime_error);
}

TEST_F(TrainServiceTest, GetAllTrains_Empty) {
    auto trains = service->getAllTrains();
    EXPECT_TRUE(trains.empty());
}

TEST_F(TrainServiceTest, GetAllTrains_Multiple) {
    service->createTrain("Train 1", 20);
    service->createTrain("Train 2", 30);
    service->createTrain("Train 3", 40);

    auto trains = service->getAllTrains();
    EXPECT_EQ(trains.size(), 3);
}

TEST_F(TrainServiceTest, UpdateTrain_Success) {
    Train created = service->createTrain("Old Name", 20);
    Train updated = service->updateTrain(created.getTrainId(), "New Name", 30);

    EXPECT_EQ(updated.getTrainName(), "New Name");
    EXPECT_EQ(updated.getTotalSeats(), 30);
}

TEST_F(TrainServiceTest, UpdateTrain_NotExists) {
    EXPECT_THROW(service->updateTrain(999, "Test", 30), std::runtime_error);
}

TEST_F(TrainServiceTest, DeleteTrain_Success) {
    Train created = service->createTrain("Test", 20);
    bool deleted = service->deleteTrain(created.getTrainId());
    EXPECT_TRUE(deleted);
}

TEST_F(TrainServiceTest, DeleteTrain_NotExists) {
    bool deleted = service->deleteTrain(999);
    EXPECT_FALSE(deleted);
}

TEST_F(TrainServiceTest, AddSeats_ById_Success) {
    Train created = service->createTrain("Test", 20);
    Train updated = service->addSeats(created.getTrainId(), 10);
    EXPECT_EQ(updated.getTotalSeats(), 30);
}

TEST_F(TrainServiceTest, AddSeats_ByName_Success) {
    service->createTrain("Test Train", 20);
    Train updated = service->addSeats("Test Train", 10);
    EXPECT_EQ(updated.getTotalSeats(), 30);
}

TEST_F(TrainServiceTest, AddSeats_ByName_NotExists) {
    EXPECT_THROW(service->addSeats("NonExistent", 10), std::runtime_error);
}

TEST_F(TrainServiceTest, IsAvailableSeat_True) {
    Train created = service->createTrain("Test", 20);
    EXPECT_TRUE(service->isAvailbleSeat(created.getTrainId()));
}

TEST_F(TrainServiceTest, IsAvailableSeat_NotExists) {
    EXPECT_THROW(service->isAvailbleSeat(999), std::runtime_error);
}

==================================================
FILE PATH: .\tests\structures\test_stack.cpp
==================================================

#include <gtest/gtest.h>
#include "structures/stack.h"

// Test fixture (optional, but useful if you want multiple tests)
class StackTest : public ::testing::Test {
protected:
    stack<int> s;
};

// Test that new stack is empty
TEST_F(StackTest, IsEmptyInitially) {
EXPECT_TRUE(s.empty());
EXPECT_EQ(s.size(), 0);
}

// Test push operation
TEST_F(StackTest, PushIncreasesSize) {
s.push(10);
EXPECT_FALSE(s.empty());
EXPECT_EQ(s.size(), 1);
EXPECT_EQ(s.top(), 10);

s.push(20);
EXPECT_EQ(s.size(), 2);
EXPECT_EQ(s.top(), 20);
}

// Test pop operation
TEST_F(StackTest, PopDecreasesSize) {
s.push(5);
s.push(15);

EXPECT_EQ(s.top(), 15);
s.pop();
EXPECT_EQ(s.top(), 5);
EXPECT_EQ(s.size(), 1);

s.pop();
EXPECT_TRUE(s.empty());
EXPECT_EQ(s.size(), 0);
}

// Test popping from empty stack throws
TEST_F(StackTest, PopOnEmptyThrows) {
EXPECT_THROW(s.pop(), std::runtime_error);
}

// Test top on empty stack throws
TEST_F(StackTest, TopOnEmptyThrows) {
EXPECT_THROW(s.top(), std::runtime_error);
}

// Test multiple push/pop
TEST_F(StackTest, PushPopSequence) {
for (int i = 0; i < 5; ++i) {
s.push(i * 10);
EXPECT_EQ(s.top(), i * 10);
}

for (int i = 4; i >= 0; --i) {
EXPECT_EQ(s.top(), i * 10);
s.pop();
}

EXPECT_TRUE(s.empty());
}

